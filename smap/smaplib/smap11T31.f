      PROGRAM MAINBF
**
**    **************************************************************
**    *   U.K. UNIVERSITIES GLOBAL ATMOSPHERIC MODELLING PROJECT   *
**    *                                                            *
**    *      DIAGNOSTIC PROGRAM FOR THE READING UNIVERSITY SGCM    *
**    *                                                            *
**    *                      VERSION SMAP1.1                       *
**    *                                                            *
**    *                     AUTHOR : R.BRUGGE                      *
**    *                                                            *
**    * History:                                                   *
**    *   1.0   : Initial release                      Oct 1994    *
**    *   1.1   : Addition of transient fluxes         Sep 1995    *
**    *                                                            *
**    *                      DATE : AUG  1995                      *
**    **************************************************************
**
**    Function - to control the running of the 'SMAP Program'
**    Com used - /COMIOC/NCFICH,NCUTF,/COMDAT/LASCII,LUTF14,
**          YNAME
**    Com changed - none
**    Calls - ANALYS,CHANNL,CHCLOS,CHHEAD,CONST,DATAIN,DATCHK,DINIT,
**          ENDOP,EUTF14,HEADER,INIOP,INIT,PARCHK,UTF14,SECOND
**    Files read - none
**    Files written - NCFICH
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COUNTER/IRECCOUNT

c      CALL SECOND(STIME)

C**************************************
C SET UP COUNTER FOR NUMBER OF OUTPUT RECORDS FOR USE IN OTHER PROGRAMS
      IRECCOUNT=0
C OPEN FILES FOR USE TO INTERFACE WITH XGPLOT
      OPEN(7,FILE='gridout',FORM='UNFORMATTED')
C     OPEN(8,FILE='titlesout')
      OPEN(30,FILE='nrecsout')
C**************************************

**    Check the parameters
      CALL PARCHK

**    Declare which channels are used for i/o, work space, etc.
      CALL CHANNL

**    Printout header information, describing the run. Additional
**          information will be output when read/calculated/modified
      CALL HEADER

**    Read input data from namelists (these are optionally created by
**          the data preprocessor) - this data is read from NCNAME
      CALL DATAIN

**    Check the user-supplied data
      CALL DATCHK

**    Print out channel information
      CALL CHHEAD

**    Specify physical/mathematical constants
      CALL CONST

**    Define any derived data, and any other general data
      CALL INIT

**    Initialise diagnostics and calculate diagnostic-specific
**    constants etc. Note that input data was checked in DATCHK etc.
      CALL DINIT

**    Write UTF header
      IF(LUTF14) THEN
         IF(LASCII) CALL UTF14(YNAME,NCUTF)
      ENDIF

**    Produce any output that is required prior to the time loop
      CALL INIOP

**    Start of the time loop
      CALL ANALYS
**    End of the time loop

**    Produce output at the end of the time-analysis
      CALL ENDOP

**    Write UTF tail
      IF(LUTF14) THEN
         IF(LASCII) CALL EUTF14(NCUTF)
      ENDIF

**    Close work files, etc
CHACK
C*****dirty hack: don't close fortran channels to avoid crashin on internal 
C     write statements in FTNN
C     CALL CHCLOS
C************

c      CALL SECOND(FTIME)
c      ETIME=FTIME-STIME
c**    Write timings to unit 6 and NCFICH
c      WRITE(6,6000)FTIME,ETIME
c      WRITE(NCFICH,6000)FTIME,ETIME
c6000  FORMAT(/' ***  EXECUTION TIME =',F10.1,' SECONDS ***'
c     -      /'***  TOTAL TIME USED =',F10.1,' SECONDS ***')

      STOP
      END
      SUBROUTINE CHANNL
**    Function - to declare channel numbers used by the program
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /PHDIAG/NCPH,/XPDIAG/NCXP,/CODIAG/NCCO,
**          /SGDIAG/NCSG,/G3DIAG/NCG3,/TRDIAG/NCTR,/T3DIAG/
**          NCT3,/F3DIAG/NCF3,/TFDIAG/NCTF,/ODDIAG/NCOD,/O3DIAG/NCO3
**    Com changed - /COMIOC/all elements,/COMPTH/YCPTHT,YCPTHH,
**          YCPTHC
**    Params used - /PARAM3/JPPHMX,JPCOMX,/PARAM1/JPNL
**    Called by - MAINBF
**    Calls - CHOPEN,DACNST
**    Files read - NCNAME
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      CHARACTER*80 YCPTHT,YCPTHH,YCPTHC
      COMMON /COMPTH/YCPTHT,YCPTHH,YCPTHC
      COMMON /IPATHL/NLENTD,NLENHD,NLENCD
      COMMON /F3DIAG/NCF3,NF3PL(JPTFMX)
      COMMON /G3DIAG/NCG3,NG3PL(JPSGMX),NG3
      COMMON /O3DIAG/NCO3,NO3PL(JPODMX),NO3
      LOGICAL LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN
      COMMON /ODDIAG/LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN,
     -      NCOD,NVODHR(JPNL),VODSFC(JPNL)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      COMMON /T3DIAG/NCT3,NT3PL(JPTRMX),NT3
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN
      COMMON /TRDIAG/LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN,
     -      NCTR,NVTRHR(JPNL),VTRSFC(JPNL)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      CHARACTER*1 YOBLNK

**    Warning - the following channels are used by the data
**          preprocessor:
**          Channel 10 - user written input data to preprocessor
**          Channel 11 - the namelist file used as input to SMAP
**          Channel 12 - used as work space by preprocessor (may be
**                used by SMAP)

**    NCFICH - information written to here can be used to produce
**          microfiche
      DATA NCFICH/3/

**    NCPH - will contain output from 'PH' routines (set in DATAIN)
**    NCXP - will contain output from 'XP' routines (set in DATAIN)
**    NCCO - will contain output from 'CO' routines (set in DATAIN)
**    NCSG - will contain output from 'SG' routines (set in DATAIN)
**    NCG3 - will contain output from 'G3' routines (set in DATAIN)
**    NCTR - will contain output from 'TR' routines (set in DATAIN)
**    NCT3 - will contain output from 'T3' routines (set in DATAIN)
**    NCTF - will contain output from 'TF' routines (set in DATAIN)
**    NCF3 - will contain output from 'F3' routines (set in DATAIN)
**    NCOD - will contain output from 'OD' routines (set in DATAIN)
**    NCO3 - will contain output from 'O3' routines (set in DATAIN)
**    NCZFWK - will contain output from 'ZF' routines (set in DATAIN)

**    NCHIST - MARS history data file
      DATA NCHIST/9/

**    NCNAME - channel containing namelist information
      DATA NCNAME/11/

**    NCSURF - Surface physics data file
      DATA NCSURF/13/

**    NCAIRM - channel containing horizontal land/air masks if JPJGL=1
      DATA NCAIRM/14/

**    NCROGG - channel containing JPJG orography latitudes if JPJGL=1
      DATA NCROGG/15/

**    NCROGS - channel containing the spectral orography data file
      DATA NCROGS/16/

**    NCLEG - used to store the Legendre functions and their derivatives
**          when JPJGP=1
**    NCZFWK - used to store ZF time-series data
      DATA NCZFWK/66/

      DATA NCLEG/25/

**    NCTJIN - channel containing input binary trajectories
**    NCTJOP - channel containing output binary trajectories
      DATA NCTJIN/26/
      DATA NCTJOP/27/

**    NCGP - used to store current values of 3D model gridpoint fields
**    and surface model gridpoint fields
      DATA NCGP/41,42,43/

**    NCTRC - used to store current values of 3D tracer gridpoint fields
      DATA NCTRC/44/

**    NCTRAC - used to store time-accumulated values of 3D tracer
**    gridpoint fields
      DATA NCTRAC/45/

**    NCTRAC - used to store time-averaged values of 3D tracer
**    gridpoint fields
      DATA NCTRAV/46/

**    NCUTF - used to store the UTFs
      DATA NCUTF/65/

**    NCGPAC - used to store time-accumulated values of 3D
**    model gridpoint fields and surface model gridpoint fields
      DATA NCGPAC/68,69,70/

**    NCGPAV - used to store time-averaged values of 3D
**    model gridpoint fields and surface model gridpoint fields
      DATA NCGPAV/71,72,73/

**    NCGPTS - work space for time-series GP diagnostics
      DATA NCGPTS/74/

**    NCGHTS - work space for time-series GH diagnostics
      DATA NCGHTS/75/

**    NCGZTS - work space for time-series GZ diagnostics
      DATA NCGZTS/76/

**    NCGMTS - work space for time-series GM diagnostics
      DATA NCGMTS/77/

**    NCGPTS - work space for time-series TP diagnostics
      DATA NCTPTS/78/

**    NCGHTS - work space for time-series TH diagnostics
      DATA NCTHTS/79/

**    NCGZTS - work space for time-series TZ diagnostics
      DATA NCTZTS/80/

**    NCGMTS - work space for time-series TM diagnostics
      DATA NCTMTS/81/

**    NCOPTS - work space for time-series OP diagnostics
      DATA NCOPTS/82/

**    NCOHTS - work space for time-series OH diagnostics
      DATA NCOHTS/83/

**    NCOZTS - work space for time-series OZ diagnostics
      DATA NCOZTS/84/

**    NCOMTS - work space for time-series OM diagnostics
      DATA NCOMTS/85/

**    NCODAC - used to store time-accumulated optional 3D gridpoint
**    fields
      DATA NCODAC/86/

**    NCODAV - used to store time-averaged optional 3D gridpoint
**    fields
      DATA NCODAV/87/

**    NCODC - used to store current values of optional 3D gridpoint
**    fields
      DATA NCODC/88/

**    NCETWK - used to store miscellaneous gridpoint fields on
**    sigma levels
      DATA NCETWK/89/

**    NCTF1, NCTF2 - workspace for transient flux calculations
      DATA NCTF1/90/,NCTF2/91/

**    NCPHY3 - work space for time-average PH diagnostics
      DATA NCPHY3/94/

**    NCPHY4 - work space for time-series PH diagnostics
      DATA NCPHY4/95/

**    NCPHY5 - work space for time-average PH diagnostics
      DATA NCPHY5/96/

**    NCDYN1 - work space for time-average XP diagnostics
      DATA NCDYN1/97/

**    NCDYN2 - work space for time-series XP diagnostics
      DATA NCDYN2/98/

**    NCDYN3 - work space for time-average XP diagnostics
      DATA NCDYN3/92/

**    NCSGSW - work channel used to switch SG/TR array indices
      DATA NCSGSW/99/

      REWIND NCNAME
**    Read in the file paths
      YOBLNK=' '
      WRITE(YCPTHT,'(80A1)') (YOBLNK,J=1,80)
      WRITE(YCPTHH,'(80A1)') (YOBLNK,J=1,80)
      WRITE(YCPTHC,'(80A1)') (YOBLNK,J=1,80)
      READ(NCNAME,5000)YCPTHT
      READ(NCNAME,5000)YCPTHH
      READ(NCNAME,5000)YCPTHC
5000  FORMAT(A)

**    Direct access file constants determined
      CALL DACNST
      CALL CHOPEN

      RETURN
      END
      SUBROUTINE CHHEAD
**    Function - to output channel numbers used by the program
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /PHDIAG/NCPH,/XPDIAG/NCXP,/CODIAG/NCCO,
**          /COMIOC/all elements,/G3DIAG/NCG3,/SGDIAG/NCSG,
**          /T3DIAG/NCT3,/TRDIAG/NCTR,/F3DIAG/NCF3,/TFDIAG/NCTF,
**          /ODDIAG/NCOD,/O3DIAG/NCO3,/ZFDIAG/NCZF
**    Com changed - none
**    Params used - /PARAM3/JPPHMX,JPCOMX,/PARAM1/JPNL
**    Called by - MAINBF
**    Calls - none
**    Files read - none
**    Files written - NCFICH
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /G3DIAG/NCG3,NG3PL(JPSGMX),NG3
      COMMON /F3DIAG/NCF3,NF3PL(JPTFMX)
      COMMON /O3DIAG/NCO3,NO3PL(JPODMX),NO3
      LOGICAL LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN
      COMMON /ODDIAG/LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN,
     -      NCOD,NVODHR(JPNL),VODSFC(JPNL)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      COMMON /T3DIAG/NCT3,NT3PL(JPTRMX),NT3
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN
      COMMON /TRDIAG/LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN,
     -      NCTR,NVTRHR(JPNL),VTRSFC(JPNL)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      LOGICAL LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      COMMON /ZFDIAG/NCZF,NZFPR(JPZFMX),NZFPL(JPZFMX),
     -      CINTZF(JPZFMX),NVZFHR(JPNL),
     -      NZF,FACTZF(2,JPZFMX),NFLDZF(4,JPZFMX),VZFSFC(JPNL),
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM

**    Write out channel information to unit 6 and NCFICH
      WRITE(6,6000)'CHANNEL NUMBER','CHANNEL NAME','DESCRIPTION'
6000  FORMAT(1X,A20,A20,A80)
      WRITE(NCFICH,6000)'CHANNEL NUMBER','CHANNEL NAME','DESCRIPTION'

      WRITE(6,6010)NCG3,'NCG3','SG 3-D OUTPUT'
      WRITE(NCFICH,6010)NCG3,'NCG3','SG 3-D OUTPUT'

      WRITE(6,6010)NCT3,'NCT3','TR 3-D OUTPUT'
      WRITE(NCFICH,6010)NCT3,'NCT3','TR 3-D OUTPUT'

      WRITE(6,6010)NCF3,'NCF3','TF 3-D OUTPUT'
      WRITE(NCFICH,6010)NCF3,'NCF3','TF 3-D OUTPUT'

      WRITE(6,6010)NCO3,'NCO3','OD 3-D OUTPUT'
      WRITE(NCFICH,6010)NCO3,'NCO3','OD 3-D OUTPUT'

      WRITE(6,6010)NCOD,'NCOD','OD DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCOD,'NCOD','OD DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCFICH,'NCFICH','MICROFICHE O/P CHANNEL'
      WRITE(NCFICH,6010)NCFICH,'NCFICH','MICROFICHE O/P CHANNEL'

      WRITE(6,6010)NCSG,'NCSG','SG DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCSG,'NCSG','SG DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCTR,'NCTR','TR DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCTR,'NCTR','TR DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCTF,'NCTF','TF DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCTF,'NCTF','TF DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCZF,'NCZF','ZF DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCZF,'NCZF','ZF DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCPH,'NCPH','PH DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCPH,'NCPH','PH DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCXP,'NCXP','XP DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCXP,'NCXP','XP DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCCO,'NCCO','CO DIAGNOSTIC OUTPUT'
      WRITE(NCFICH,6010)NCCO,'NCCO','CO DIAGNOSTIC OUTPUT'

      WRITE(6,6010)NCHIST,'NCHIST','HISTORY DATA FILE'
      WRITE(NCFICH,6010)NCHIST,'NCHIST','HISTORY DATA FILE'

      WRITE(6,6010)NCNAME,'NCNAME','INPUT CHANNEL FOR NAMELIST DATA'
      WRITE(NCFICH,6010)NCNAME,'NCNAME',
     -      'INPUT CHANNEL FOR NAMELIST DATA'

      WRITE(6,6010)NCSURF,'NCSURF','SURFACE DATA FILE'
      WRITE(NCFICH,6010)NCSURF,'NCSURF','SURFACE DATA FILE'

      WRITE(6,6010)NCAIRM,'NCAIRM','HORIZONTAL LAND/AIR MASKS'
      WRITE(NCFICH,6010)NCAIRM,'NCAIRM','HORIZONTAL LAND/AIR MASKS'

      WRITE(6,6010)NCROGG,'NCROGG','GRIDPOINT OROGRAPHY DATA'
      WRITE(NCFICH,6010)NCROGG,'NCROGG','GRIDPOINT OROGRAPHY DATA'

      WRITE(6,6010)NCROGS,'NCROGS','SPECTRAL OROGRAPHY DATA FILE'
      WRITE(NCFICH,6010)NCROGS,'NCROGS','SPECTRAL OROGRAPHY DATA FILE'

      WRITE(6,6010)NCLEG,'NCLEG',
     -      'CONTAINS LEGENDRE FUNCTIONS/DERIVATIVES'
      WRITE(NCFICH,6010)NCLEG,'NCLEG',
     -      'CONTAINS LEGENDRE FUNCTIONS/DERIVATIVES'

      WRITE(6,6010)NCTJIN,'NCTJIN','INPUT BINARY TRAJECTORIES'
      WRITE(NCFICH,6010)NCTJIN,'NCTJIN','INPUT BINARY TRAJECTORIES'

      WRITE(6,6010)NCTJOP,'NCTJOP','OUTPUT BINARY TRAJECTORIES'
      WRITE(NCFICH,6010)NCTJOP,'NCTJOP','OUTPUT BINARY TRAJECTORIES'

**    Change the following variable if NCTJWK is altered in routine
**    TJINIT.
      ITJCHL=28
      WRITE(6,6010)ITJCHL,'NCTJWK','TRAJECTORY WORK CHANNEL'
      WRITE(NCFICH,6010)ITJCHL,'NCTJWK','TRAJECTORY WORK CHANNEL'

      WRITE(6,6010)NCGP(1),'NCGP(1)','3D GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGP(1),'NCGP(1)','3D GRIDPOINT DATA'

      WRITE(6,6010)NCGP(2),'NCGP(2)','SURFACE GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGP(2),'NCGP(2)','SURFACE GRIDPOINT DATA'

      WRITE(6,6010)NCGP(3),'NCGP(3)','HALF-LEVEL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGP(3),'NCGP(3)','HALF-LEVEL GRIDPOINT DATA'

      WRITE(6,6010)NCTRC,'NCTRC','3D TRACER GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCTRC,'NCTRC','3D TRACER GRIDPOINT DATA'

      WRITE(6,6010)NCTRAC,'NCTRAC',
     -      '3D TIME ACCUMULATED TRACER GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCTRAC,'NCTRAC',
     -      '3D TIME ACCUMULATED TRACER GRIDPOINT DATA'

      WRITE(6,6010)NCTRAV,'NCTRAV',
     -      '3D TIMEAVERAGED TRACER GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCTRAV,'NCTRAV',
     -      '3D TIMEAVERAGED TRACER GRIDPOINT DATA'

      WRITE(6,6010)NCUTF,'NCUTF','UTF FILE'
      WRITE(NCFICH,6010)NCUTF,'NCUTF','UTF FILE'

      WRITE(6,6010)NCZFWK,'NCZFWK','ZF TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCZFWK,'NCZFWK','ZF TIME-SERIES WORK FILE'

      WRITE(6,6010)NCGPAC(1),'NCGPAC(1)',
     -      '3D TIME ACCUMULATED GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGPAC(1),'NCGPAC(1)',
     -      '3D TIME ACCUMULATED GRIDPOINT DATA'

      WRITE(6,6010)NCGPAC(2),'NCGPAC(2)',
     -      'TIME ACCUMULATED SURFACE GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGPAC(2),'NCGPAC(2)',
     -      'TIME ACCUMULATED SURFACE GRIDPOINT DATA'

      WRITE(6,6010)NCGPAC(3),'NCGPAC(3)',
     -      'TIME ACCUMULATED HALF-LEVEL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGPAC(3),'NCGPAC(3)',
     -      'TIME ACCUMULATED HALF-LEVEL GRIDPOINT DATA'

      WRITE(6,6010)NCGPAV(1),'NCGPAV(1)',
     -      '3D TIMEAVERAGED GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGPAV(1),'NCGPAV(1)',
     -      '3D TIMEAVERAGED GRIDPOINT DATA'

      WRITE(6,6010)NCGPAV(2),'NCGPAV(2)',
     -      'TIMEAVERAGED SURFACE GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGPAV(2),'NCGPAV(2)',
     -      'TIMEAVERAGED SURFACE GRIDPOINT DATA'

      WRITE(6,6010)NCGPAV(3),'NCGPAV(3)',
     -      'TIME AVERAGED HALF-LEVEL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCGPAV(3),'NCGPAV(3)',
     -      'TIME AVERAGED HALF-LEVEL GRIDPOINT DATA'

      WRITE(6,6010)NCGPTS,'NCGPTS','GP TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCGPTS,'NCGPTS','GP TIME-SERIES WORK FILE'

      WRITE(6,6010)NCGHTS,'NCGHTS','GH TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCGHTS,'NCGHTS','GH TIME-SERIES WORK FILE'

      WRITE(6,6010)NCGZTS,'NCGZTS','GZ TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCGZTS,'NCGZTS','GZ TIME-SERIES WORK FILE'

      WRITE(6,6010)NCGMTS,'NCGMTS','GM TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCGMTS,'NCGMTS','GM TIME-SERIES WORK FILE'

      WRITE(6,6010)NCTPTS,'NCTPTS','TP TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCTPTS,'NCTPTS','TP TIME-SERIES WORK FILE'

      WRITE(6,6010)NCTHTS,'NCTHTS','TH TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCTHTS,'NCTHTS','TH TIME-SERIES WORK FILE'

      WRITE(6,6010)NCTZTS,'NCTZTS','TZ TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCTZTS,'NCTZTS','TZ TIME-SERIES WORK FILE'

      WRITE(6,6010)NCTMTS,'NCTMTS','TM TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCTMTS,'NCTMTS','TM TIME-SERIES WORK FILE'

      WRITE(6,6010)NCOPTS,'NCOPTS','OP TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCOPTS,'NCOPTS','OP TIME-SERIES WORK FILE'

      WRITE(6,6010)NCOHTS,'NCOHTS','OH TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCOHTS,'NCOHTS','OH TIME-SERIES WORK FILE'

      WRITE(6,6010)NCOZTS,'NCOZTS','OZ TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCOZTS,'NCOZTS','OZ TIME-SERIES WORK FILE'

      WRITE(6,6010)NCOMTS,'NCOMTS','OM TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCOMTS,'NCOMTS','OM TIME-SERIES WORK FILE'

      WRITE(6,6010)NCODAC,'NCODAC',
     -      '3D TIME ACCUMULATED OPTIONAL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCODAC,'NCODAC',
     -      '3D TIME ACCUMULATED OPTIONAL GRIDPOINT DATA'

      WRITE(6,6010)NCODAV,'NCODAV',
     -      '3D TIMEAVERAGED OPTIONAL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCODAV,'NCODAV',
     -      '3D TIMEAVERAGED OPTIONAL GRIDPOINT DATA'

      WRITE(6,6010)NCODC,'NCODC','3D OPTIONAL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCODC,'NCODC','3D OPTIONAL GRIDPOINT DATA'

      WRITE(6,6010)NCETWK,'NCETWK','MISC. SIGMA LEVEL GRIDPOINT DATA'
      WRITE(NCFICH,6010)NCETWK,
     -      'NCETWK','MISC. SIGMA LEVEL GRIDPOINT DATA'

      WRITE(6,6010)NCTF1,'NCTF1','TF WORK FILE'
      WRITE(NCFICH,6010)NCTF1,'NCTF1','TF WORK FILE'

      WRITE(6,6010)NCTF2,'NCTF2','TF WORK FILE'
      WRITE(NCFICH,6010)NCTF2,'NCTF2','TF WORK FILE'

      WRITE(6,6010)NCDYN3,'NCDYN3','XP TIME-AVERAGE WORK FILE'
      WRITE(NCFICH,6010)NCDYN3,'NCDYN3','XP TIME-AVERAGE WORK FILE'

      WRITE(6,6010)NCPHY3,'NCPHY3','PH TIME-AVERAGE WORK FILE'
      WRITE(NCFICH,6010)NCPHY3,'NCPHY3','PH TIME-AVERAGE WORK FILE'

      WRITE(6,6010)NCPHY4,'NCPHY4','PH TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCPHY4,'NCPHY4','PH TIME-SERIES WORK FILE'

      WRITE(6,6010)NCPHY5,'NCPHY5','PH TIME-AVERAGE WORK FILE'
      WRITE(NCFICH,6010)NCPHY5,'NCPHY5','PH TIME-AVERAGE WORK FILE'

      WRITE(6,6010)NCDYN1,'NCDYN1','XP TIME-AVERAGE WORK FILE'
      WRITE(NCFICH,6010)NCDYN1,'NCDYN1','XP TIME-AVERAGE WORK FILE'

      WRITE(6,6010)NCDYN2,'NCDYN2','XP TIME-SERIES WORK FILE'
      WRITE(NCFICH,6010)NCDYN2,'NCDYN2','XP TIME-SERIES WORK FILE'

      WRITE(6,6010)NCSGSW,'NCSGSW','SG/TR INDEX SWITCHING CHANNEL'
      WRITE(NCFICH,6010)NCSGSW,'NCSGSW','SG/TR INDEX SWITCHING CHANNEL'
6010  FORMAT(11X,I3,7X,A20,A80)

      RETURN
      END
      SUBROUTINE DACNST
**    Function - to determine direct access file constants
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - /COMNGP/all elements
**    Params used - /PARAM1/JPNHEM,JPNL,JPJG,/PARAM2/JPMGPP,
**          /PARAM3/JPTRMX
**    Called by - CHANNL
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)
**
**    NOTE : IF CHANGES ARE MADE TO THIS ROUTINE, THEY MAY NEED TO
**           BE INCLUDED IN FUNCTION TJPRTF
**

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG

**    Define record sizes of direct access files prior to OPENing
      NRSZ3D=4*JPMGPP*JPNHEM*JPNL
      NRSZSF=4*JPMGPP*JPNHEM
      NRSZHL=4*JPMGPP*JPNHEM*(JPNL+1)
      NRSZ3A=4*JPMGPP*JPNHEM*JPNL*JPJG
      NRSZSA=4*JPMGPP*JPNHEM*JPJG
      NRSZHA=4*JPMGPP*JPNHEM*(JPNL+1)*JPJG
c      NRSZ3D=8*JPMGPP*JPNHEM*JPNL
c      NRSZSF=8*JPMGPP*JPNHEM
c      NRSZHL=8*JPMGPP*JPNHEM*(JPNL+1)
c      NRSZ3A=8*JPMGPP*JPNHEM*JPNL*JPJG
c      NRSZSA=8*JPMGPP*JPNHEM*JPJG
c      NRSZHA=8*JPMGPP*JPNHEM*(JPNL+1)*JPJG
c
**    Define initial record (first of JG sequential records) for the
**    storage of the model gridpoint fields in direct access files
**    NCGP and NCGPAV
      NR1SF=1
      NR1CHI=JPJG+1
      NR1VO=2*JPJG+1
      NR1D=3*JPJG+1
      NR1OM=4*JPJG+1
      NR1U=5*JPJG+1
      NR1V=6*JPJG+1
      NR1T=7*JPJG+1
      NR1GH=8*JPJG+1
      NR1Q=9*JPJG+1
      NR1H=10*JPJG+1
      NR1AP=11*JPJG+1
      NR1TH=12*JPJG+1
      NR1EPV=13*JPJG+1
      NR1FU=14*JPJG+1
      NR1FV=15*JPJG+1
      NR1MSF=16*JPJG+1
      NR1ALM=17*JPJG+1

      NR1PSF=1
      NR1PSL=JPJG+1
      NR1APJ=2*JPJG+1
      NR1APM=3*JPJG+1
      NR1THS=4*JPJG+1

      NR1PHL=1

**    NRMSK2 corresponds to the position of the NR1ALM (ie land/air
**    mask data) on NCGPAC. Likewise, NRMSK3 applies to NR1TH (on theta
**    surfaces, only, ie sigma function).
      NRMSK2=(NR1ALM-1)/JPJG+1
      NRMSK3=(NR1TH-1)/JPJG+1

**    Define initial record (first of JG sequential records) for the
**    storage of the model tracer fields in direct access files
**    NCTRC and NCTRAV
      DO 100 J=1,JPTRMX
      NR1TR(J)=(J-1)*JPJG+1
100   CONTINUE

**    Define initial record (first of JPJG sequential records) for the
**    storage of the optional 3D fields in direct access files
      NR1RHG=1
      NR1MMG=JPJG+1
      NR1SPG=2*JPJG+1
      NR1ELG=3*JPJG+1
      NR1NAG=4*JPJG+1
      NR1UGG=5*JPJG+1
      NR1VGG=6*JPJG+1

      RETURN
      END
      SUBROUTINE DATAIN
**    Function - to read in input and namelist data supplied by the
**          preprocessor and/or user. Note that the directory
**          pathnames have already been read.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCNAME,NCFICH
**    Com changed - /COMDAT/all elements,
**          /XPDIAG/all elements,/COMAVG/LMASSW,LAVMSK,LAVSIG
**          /DIAGTP/all elements,/PHDIAG/all elements,/COMTIM/
**          NFREQD,NFREQP,NFREQA,TSPD,/OUTCON/RNTAPE,/INIDAT/all
**          elements,/LVDIAG/OUTLEV,/ORDIAG/
**          all elements,/CODIAG/all elements,/SGDIAG/all elements,
**          /GHDIAG/all elements,/GZDIAG/all elements,/GMDIAG/all
**          elements,/GPDIAG/all elements,/G3DIAG/all elements,
**          /COMTRV/LGCMTR,/T3DIAG/all elements,/THDIAG/all elements,
**          /TMDIAG/all elements,/TPDIAG/all elements,/TRDIAG/all
**          elements/TZDIAG/all elements,/F3DIAG/all elements,
**          /FHDIAG/all elements,/FMDIAG/all elements,/FPDIAG/all
**          elements,/FZDIAG/all elements,/TFDIAG/all elements,
**          /ODDIAG/all elements,/OHDIAG/all elements,/OZDIAG/all
**          elements,/OMDIAG/all elements,/OPDIAG/all elements,
**          /O3DIAG/all elements,/ZFDIAG/all elements,/TJDIAG/all
**          elements,/MODELC/all elements
**    Params used -
**          JPNEG,JP999,JPGP2,JPTP2,JPFP2,JPTF2,JPTF4,/PARAM3/JPPHMX,
**          JPXPMX,JPCOMX,JPSGMX,JPGPPF,JPTRMX,JPTPPF,JPTFMX,
**          JPFPPF,JPODMX,JPOPPF,JPZFMX,JPTJMX,/PARAM1/JPNL
**    Called by - MAINBF
**    Calls - none
**    Files read - NCNAME
**    Files written - NCFICH
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      REAL JPNEG,JP999
      PARAMETER(JPNEG=-0.1,JP999=-999.0,JPGP2=JPGPPF*2,JPTP2=JPTPPF*2)
      PARAMETER(JPFP2=JPFPPF*2,JPTF2=JPTFMX*2,JPTF4=JPTFMX*4)
      PARAMETER(JPZF2=JPZFMX*2,JPZF4=JPZFMX*4)
      PARAMETER(JPOP2=JPOPPF*2)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMMON /F3DIAG/NCF3,NF3PL(JPTFMX)
      LOGICAL LDFHSL
      COMMON /FHDIAG/NFHPR(JPTFMX),NFHPL(JPTFMX),CINTFH(JPTFMX),LDFHSL
      LOGICAL LDFMMM
      COMMON /FMDIAG/LDFMMM,VFMEW,VFMEWA(2),NFMPR(JPTFMX),
     -      NFMPL(JPTFMX),CINTFM(JPTFMX)
      LOGICAL LDFPCP
      COMMON /FPDIAG/NFPPF,VFPPF(2,JPFPPF),NFPPR(JPTFMX),
     -      NFPPL(JPTFMX),LDFPCP
      LOGICAL LDFZZM
      COMMON /FZDIAG/LDFZZM,VFZNS,VFZNSA(2),NFZPR(JPTFMX),
     -      NFZPL(JPTFMX),CINTFZ(JPTFMX)
      COMMON /G3DIAG/NCG3,NG3PL(JPSGMX),NG3
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      COMMON /INIDAT/NYEAR,NDAY,NMIN
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      COMMON /O3DIAG/NCO3,NO3PL(JPODMX),NO3
      LOGICAL LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN
      COMMON /ODDIAG/LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN,
     -      NCOD,NVODHR(JPNL),VODSFC(JPNL)
      LOGICAL LDOHSL,LDOHCT,LDOHED
      COMMON /OHDIAG/LDOHSL,LDOHCT,LDOHED,VOHTS(2),
     -      NOHPR(JPODMX),NOHPL(JPODMX),NOH,NOHVEC(JPODMX),
     -      CINTOH(JPODMX)
      LOGICAL LDOMMM,LDOMTS
      COMMON /OMDIAG/LDOMMM,VOMEW,LDOMTS,VOMEWA(2),NOMPR(JPODMX),
     -      NOMPL(JPODMX),NOM,NOMVEC(JPODMX),CINTOM(JPODMX)
      LOGICAL LDOPCT,LDOPCP
      COMMON /OPDIAG/LDOPCT,NOPPF,VOPPF(2,JPOPPF),NOPPR(JPODMX),
     -      NOPPL(JPODMX),NOP,CINTOP(JPODMX),LDOPCP
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      LOGICAL LDOZZM,LDOZTS
      COMMON /OZDIAG/LDOZZM,VOZNS,LDOZTS,VOZNSA(2),NOZPR(JPODMX),
     -      NOZPL(JPODMX),NOZ,NOZVEC(JPODMX),CINTOZ(JPODMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      COMMON /T3DIAG/NCT3,NT3PL(JPTRMX),NT3
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LDTHSL,LDTHCT,LDTHED,LTHDOB
      COMMON /THDIAG/LDTHSL,LDTHCT,LDTHED,VTHTS(2),
     -      NTHPR(JPTRMX),NTHPL(JPTRMX),NTH,NTHVEC(JPTRMX),
     -      CINTTH(JPTRMX),LTHDOB
      LOGICAL LUTFTJ,LBINTJ,LUTFLV
      CHARACTER*2 YTYPTJ
      CHARACTER*6 YTJDUM
      CHARACTER*80 YINBIN,YOPBIN
      COMMON /TJDIAG/NTJATT,NATTR(JPTJMX),LUTFTJ,LBINTJ,
     -      NGRPTJ,LUTFLV,YTYPTJ,YTJDUM,YINBIN,YOPBIN
      LOGICAL LDTMMM,LDTMTS
      COMMON /TMDIAG/LDTMMM,VTMEW,LDTMTS,VTMEWA(2),NTMPR(JPTRMX),
     -      NTMPL(JPTRMX),NTM,NTMVEC(JPTRMX),CINTTM(JPTRMX)
      LOGICAL LDTPCT,LDTPCP,LTPDOB
      COMMON /TPDIAG/LDTPCT,NTPPF,VTPPF(2,JPTPPF),NTPPR(JPTRMX),
     -      NTPPL(JPTRMX),NTP,CINTTP(JPTRMX),LDTPCP,LTPDOB
      LOGICAL LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN
      COMMON /TRDIAG/LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN,
     -      NCTR,NVTRHR(JPNL),VTRSFC(JPNL)
      LOGICAL LDTZZM,LDTZTS
      COMMON /TZDIAG/LDTZZM,VTZNS,LDTZTS,VTZNSA(2),NTZPR(JPTRMX),
     -      NTZPL(JPTRMX),NTZ,NTZVEC(JPTRMX),CINTTZ(JPTRMX)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      LOGICAL LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      COMMON /ZFDIAG/NCZF,NZFPR(JPZFMX),NZFPL(JPZFMX),
     -      CINTZF(JPZFMX),NVZFHR(JPNL),
     -      NZF,FACTZF(2,JPZFMX),NFLDZF(4,JPZFMX),VZFSFC(JPNL),
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      CHARACTER*1 YOBLNK
      CHARACTER*20 YONULL

**    Namelists
      NAMELIST /GLOBAL/BEGDAY,ENDDAY,YTYPSF,LWRITE,LASCII,LSCRAT,
     -      LUTF14,LROGR,NSIGFG,NFREQD,NFREQP,NFREQA,RNTAPE,
     -      YNAME,
     -      NASCII,LMASSW,LAVMSK,LAVSIG
      NAMELIST /FLXTYP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      NAMELIST /SMSPEC/TSPD,NYEAR,NDAY,NMIN,LGCMTR,TMEAN,LHISPH,
     -      LHISXP,LDRY,LDIABH,BEGDYP,LVD,LBL,AKVV,CD
      NAMELIST /PHDATA/NCPH,NPHPR,NPHPL,CINTPH,LDPHLL,LDPHZM,LDPHMM,
     -      LDPHGM,LDPHTD,LDPHIN,VPHEW,VPHEWA,VPHEWS,VPHNS,
     -      VPHNSA,VPHNSS,VPHAA,VPHAS,LDPHTS,NPH
      NAMELIST /XPDATA/NCXP,NXPPR,NXPPL,CINTXP,LDXPZM,
     -      LDXPLM,LDXPTD,LDXPIN,LDXPTS,NXP
      NAMELIST /LVDATA/OUTLEV
      NAMELIST /ORDATA/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      NAMELIST /CODATA/NCCO,NWAVET,NCOPR,NVCOHR
      NAMELIST /G3DATA/NCG3,NG3PL,NG3
      NAMELIST /GHDATA/LDGHSL,LDGHCT,LDGHED,VGHTS,NGHPR,NGHPL,NGH,
     -      NGHVEC,CINTGH
      NAMELIST /GMDATA/LDGMMM,VGMEW,VGMEWA,LDGMTS,NGMPR,NGMPL,NGM,
     -      NGMVEC,CINTGM
      NAMELIST /GPDATA/NGPPF,VGPPF,LDGPCT,NGPPR,NGPPL,NGP,CINTGP,
     -      LDGPCP
      NAMELIST /GZDATA/LDGZZM,VGZNS,VGZNSA,LDGZTS,NGZPR,NGZPL,NGZ,
     -      NGZVEC,CINTGZ
      NAMELIST /SGDATA/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR,VSGSFC
      NAMELIST /T3DATA/NCT3,NT3PL,NT3
      NAMELIST /THDATA/LDTHSL,LDTHCT,LDTHED,VTHTS,NTHPR,NTHPL,NTH,
     -      NTHVEC,CINTTH,LTHDOB
      NAMELIST /TMDATA/LDTMMM,VTMEW,VTMEWA,LDTMTS,NTMPR,NTMPL,NTM,
     -      NTMVEC,CINTTM
      NAMELIST /TPDATA/NTPPF,VTPPF,LDTPCT,NTPPR,NTPPL,NTP,CINTTP,
     -      LDTPCP,LTPDOB
      NAMELIST /TRDATA/LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN,
     -      NCTR,NVTRHR,VTRSFC
      NAMELIST /TZDATA/LDTZZM,VTZNS,VTZNSA,LDTZTS,NTZPR,NTZPL,NTZ,
     -      NTZVEC,CINTTZ
      NAMELIST /F3DATA/NCF3,NF3PL
      NAMELIST /FHDATA/NFHPR,NFHPL,CINTFH,LDFHSL
      NAMELIST /FMDATA/LDFMMM,VFMEW,VFMEWA,NFMPR,NFMPL,CINTFM
      NAMELIST /FPDATA/NFPPF,VFPPF,NFPPR,NFPPL,LDFPCP
      NAMELIST /FZDATA/LDFZZM,VFZNS,VFZNSA,NFZPR,NFZPL,CINTFZ
      NAMELIST /TFDATA/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR,
     -      VTFSFC,TFCUT,NTF,FACTTF,NFLDTF,LTFTOT,LTFHP,LTFLP
      NAMELIST /O3DATA/NCO3,NO3PL,NO3
      NAMELIST /OHDATA/LDOHSL,LDOHCT,LDOHED,VOHTS,NOHPR,NOHPL,NOH,
     -      NOHVEC,CINTOH
      NAMELIST /OMDATA/LDOMMM,VOMEW,VOMEWA,LDOMTS,NOMPR,NOMPL,NOM,
     -      NOMVEC,CINTOM
      NAMELIST /OPDATA/NOPPF,VOPPF,LDOPCT,NOPPR,NOPPL,NOP,CINTOP,
     -      LDOPCP
      NAMELIST /OZDATA/LDOZZM,VOZNS,VOZNSA,LDOZTS,NOZPR,NOZPL,NOZ,
     -      NOZVEC,CINTOZ
      NAMELIST /ODDATA/LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN,
     -      NCOD,NVODHR,VODSFC
      NAMELIST /ZFDATA/NCZF,NZFPR,NZFPL,CINTZF,NZF,FACTZF,NFLDZF,
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM,VZFSFC,
     -      NVZFHR
      NAMELIST /TJDATA/NTJATT,NATTR,LUTFTJ,LBINTJ,NGRPTJ,LUTFLV,
     -      YTYPTJ,YINBIN,YOPBIN

**    Default values for all namelist entries
      DATA BEGDAY/-1.0/,ENDDAY/-1.0/,YTYPSF/'ET'/,LWRITE/.TRUE./,
     -      LASCII/.TRUE./,LSCRAT/.FALSE./,
     -      LUTF14/.TRUE./,LROGR/.TRUE./,NSIGFG/2/,
     -      NFREQD/-1/,NFREQP/0/,NFREQA/0/,RNTAPE/0.0/,NASCII/2/,
     -      YNAME(1)/'        '/,YNAME(2)/'        '/,LMASSW/.FALSE./,
     -      LAVMSK/.FALSE./,LAVSIG/.FALSE./
      DATA LDPH/.FALSE./,LDXP/.FALSE./,LDCO/.FALSE./,
     -      LDSG/.FALSE./,LDTR/.FALSE./,LDTF/.FALSE./,LDOD/.FALSE./,
     -      LDZF/.FALSE./,LDTJ/.FALSE./
      DATA TSPD/0.0/,LGCMTR/.FALSE./,TMEAN/JPNL*0.0/,LHISPH/.FALSE./,
     -      LHISXP/.FALSE./,LDRY/.FALSE./,LDIABH/.TRUE./,BEGDYP/0.0/,
     -      LBL/.FALSE./,LVD/.FALSE./,CD/0.001/,AKVV/1.0/
      DATA NYEAR/8701/,NDAY/1512/,NMIN/0/
      DATA NCPH/3/,NPHPR/JPPHMX*0/,NPHPL/JPPHMX*0/,CINTPH/JPPHMX*JPNEG/,
     -      LDPHLL/.TRUE./,LDPHZM/.TRUE./,LDPHMM/.FALSE./,
     -      LDPHGM/.TRUE./,LDPHTD/.TRUE./,
     -      LDPHIN/.FALSE./,VPHEW/JP999/,VPHEWA/2*JP999/,
     -      VPHEWS/2*JP999/,VPHNS/JP999/,VPHNSA/2*JP999/,
     -      VPHNSS/2*JP999/,VPHAA/4*JP999/,VPHAS/4*JP999/,
     -      LDPHTS/.FALSE./,NPH/0/
      DATA NCXP/3/,NXPPR/JPXPMX*0/,NXPPL/JPXPMX*0/,CINTXP/JPXPMX*JPNEG/,
     -      LDXPZM/.TRUE./,
     -      LDXPLM/.FALSE./,LDXPTD/.TRUE./,
     -      LDXPIN/.FALSE./,LDXPTS/.FALSE./,NXP/0/
      DATA OUTLEV/JPNL*0.0/
      DATA LROGPR/.TRUE./,LROGPL/.TRUE./,CINTOR/200.0/,LMSKH/.TRUE./,
     -      LMSKNS/.TRUE./,LMSKWE/.TRUE./
      DATA NWAVET/10/,NCCO/3/,NCOPR/JPCOMX*0/,NVCOHR/JPNL*0/
      DATA NCG3/1/,NG3PL/JPSGMX*0/,NG3/0/
      DATA LDGHSL/.FALSE./,LDGHCT/.FALSE./,LDGHED
     -      /.FALSE./,VGHTS/2*JP999/,NGHPR/JPSGMX*0/,NGHPL/JPSGMX*0/,
     -      NGH/0/,NGHVEC/JPSGMX*0/,CINTGH/JPSGMX*JPNEG/
      DATA LDGMMM/.FALSE./,VGMEW/JP999/,VGMEWA/2*JP999/,LDGMTS/.FALSE./,
     -      NGMPR/JPSGMX*0/,NGMPL/JPSGMX*0/,
     -      NGM/0/,NGMVEC/JPSGMX*0/,CINTGM/JPSGMX*JPNEG/
      DATA NGPPF/0/,VGPPF/JPGP2*JP999/,LDGPCT/.FALSE./,LDGPCP/.FALSE./,
     -      NGPPR/JPSGMX*0/,NGPPL/JPSGMX*0/,
     -      NGP/0/,CINTGP/JPSGMX*JPNEG/
      DATA LDGZZM/.FALSE./,VGZNS/JP999/,VGZNSA/2*JP999/,LDGZTS/.FALSE./,
     -      NGZPR/JPSGMX*0/,NGZPL/JPSGMX*0/,
     -      NGZ/0/,NGZVEC/JPSGMX*0/,CINTGZ/JPSGMX*JPNEG/
      DATA LDGH/.FALSE./,LDGZ/.TRUE./,LDGM/.FALSE./,LDGP/.FALSE./,
     -      LDG3/.FALSE./,LDSGTD/.TRUE./,LDSGTS/.FALSE./,
     -      LDSGIN/.FALSE./,NCSG/3/,NVSGHR/JPNL*0/,VSGSFC/JPNL*0.0/
      DATA NCT3/1/,NT3PL/JPTRMX*0/,NT3/0/
      DATA LDTHSL/.FALSE./,LDTHCT/.FALSE./,LDTHED/.FALSE./,
     -      VTHTS/2*JP999/,NTHPR/JPTRMX*0/,NTHPL/JPTRMX*0/,NTH/0/,
     -      NTHVEC/JPTRMX*0/,CINTTH/JPTRMX*JPNEG/,LTHDOB/.FALSE./
      DATA LDTMMM/.FALSE./,VTMEW/JP999/,VTMEWA/2*JP999/,
     -      LDTMTS/.FALSE./,NTMPR/JPTRMX*0/,NTMPL/JPTRMX*0/,NTM/0/,
     -      NTMVEC/JPTRMX*0/,CINTTM/JPTRMX*JPNEG/
      DATA NTPPF/0/,VTPPF/JPTP2*JP999/,LDTPCT/.FALSE./,
     -      NTPPR/JPTRMX*0/,NTPPL/JPTRMX*0/,NTP/0/,CINTTP/JPTRMX*JPNEG/,
     -      LDTPCP/.FALSE./,LTPDOB/.FALSE./
      DATA LDTH/.FALSE./,LDTZ/.TRUE./,LDTM/.FALSE./,LDTP/.FALSE./,
     -      LDT3/.FALSE./,LDTRTD/.TRUE./,LDTRTS/.FALSE./,
     -      LDTRIN/.FALSE./,NCTR/3/,NVTRHR/JPNL*0/,VTRSFC/JPNL*0.0/
      DATA LDTZZM/.FALSE./,VTZNS/JP999/,VTZNSA/2*JP999/,LDTZTS/.FALSE./,
     -      NTZPR/JPTRMX*0/,NTZPL/JPTRMX*0/,NTZ/0/,
     -      NTZVEC/JPTRMX*0/,CINTTZ/JPTRMX*JPNEG/
      DATA NCTF/3/,LDFH/.FALSE./,LDFZ/.TRUE./,LDFM/.FALSE./,
     -      LDFP/.FALSE./,LDF3/.FALSE./,NVTFHR/JPNL*0/,
     -      VTFSFC/JPNL*0.0/,TFCUT/3.0/,NTF/0/,LTFTOT/.TRUE./,
     -      LTFHP/.TRUE./,LTFLP/.TRUE./
      DATA NFLDTF/JPTF4*0/,FACTTF/JPTF2*0.0/
      DATA NCF3/1/,NF3PL/JPTFMX*0/
      DATA LDFHSL/.FALSE./,NFHPR/JPTFMX*0/,NFHPL/JPTFMX*0/,
     -      CINTFH/JPTFMX*JPNEG/
      DATA LDFMMM/.FALSE./,VFMEW/JP999/,VFMEWA/2*JP999/,
     -      NFMPR/JPTFMX*0/,NFMPL/JPTFMX*0/,CINTFM/JPTFMX*JPNEG/
      DATA LDFPCP/.FALSE./,NFPPF/0/,VFPPF/JPFP2*JP999/,
     -      NFPPR/JPTFMX*0/,NFPPL/JPTFMX*0/
      DATA LDFZZM/.FALSE./,VFZNS/JP999/,VFZNSA/2*JP999/,NFZPR/JPTFMX*0/,
     -      NFZPL/JPTFMX*0/,CINTFZ/JPTFMX*JPNEG/
      DATA NCO3/1/,NO3PL/JPODMX*0/,NO3/0/
      DATA LDOHSL/.FALSE./,LDOHCT/.FALSE./,LDOHED
     -      /.FALSE./,VOHTS/2*JP999/,NOHPR/JPODMX*0/,NOHPL/JPODMX*0/,
     -      NOH/0/,NOHVEC/JPODMX*0/,CINTOH/JPODMX*JPNEG/
      DATA LDOMMM/.FALSE./,VOMEW/JP999/,VOMEWA/2*JP999/,LDOMTS/.FALSE./,
     -      NOMPR/JPODMX*0/,NOMPL/JPODMX*0/,
     -      NOM/0/,NOMVEC/JPODMX*0/,CINTOM/JPODMX*JPNEG/
      DATA NOPPF/0/,VOPPF/JPOP2*JP999/,LDOPCT/.FALSE./,LDOPCP/.FALSE./,
     -      NOPPR/JPODMX*0/,NOPPL/JPODMX*0/,
     -      NOP/0/,CINTOP/JPODMX*JPNEG/
      DATA LDOZZM/.FALSE./,VOZNS/JP999/,VOZNSA/2*JP999/,LDOZTS/.FALSE./,
     -      NOZPR/JPODMX*0/,NOZPL/JPODMX*0/,
     -      NOZ/0/,NOZVEC/JPODMX*0/,CINTOZ/JPODMX*JPNEG/
      DATA LDOH/.FALSE./,LDOZ/.TRUE./,LDOM/.FALSE./,LDOP/.FALSE./,
     -      LDO3/.FALSE./,LDODTD/.TRUE./,LDODTS/.FALSE./,
     -      LDODIN/.FALSE./,NCOD/3/,NVODHR/JPNL*0/,VODSFC/JPNL*0.0/
      DATA NCZF/3/,NZFPR/JPZFMX*0/,NZFPL/JPZFMX*0/,CINTZF/JPZFMX*JPNEG/,
     -      NZF/0/,FACTZF/JPZF2*0.0/,NFLDZF/JPZF4*0/,
     -      LZFEDF/.FALSE./,LZFMNF/.FALSE./,LDZFIN/.FALSE./,
     -      LDZFTD/.FALSE./,LDZFTS/.FALSE./,LDZFZM/.FALSE./,
     -      LDZFLM/.FALSE./,NVZFHR/JPNL*0/,VTFSFC/JPNL*0.0/
      DATA NTJATT/0/,NATTR/JPTJMX*0/,LUTFTJ/.FALSE./,LBINTJ/.FALSE./,
     -      NGRPTJ/25/,LUTFLV/.FALSE./,YTYPTJ/'IS'/
      DATA YONULL/'                    '/

      YOBLNK=' '
      YINBIN=YONULL//YONULL//YONULL//YONULL
      YOPBIN=YONULL//YONULL//YONULL//YONULL

**    Pathnames already read from NCNAME
      READ(NCNAME,GLOBAL)
**    NAME(1) and NAME(2) currently not defined
      READ(NCNAME,FLXTYP)
      READ(NCNAME,SMSPEC)
      READ(NCNAME,PHDATA)
      READ(NCNAME,XPDATA)
      READ(NCNAME,LVDATA)
      READ(NCNAME,ORDATA)
      READ(NCNAME,CODATA)
      READ(NCNAME,SGDATA)
      READ(NCNAME,GHDATA)
      READ(NCNAME,GZDATA)
      READ(NCNAME,GMDATA)
      READ(NCNAME,GPDATA)
      READ(NCNAME,G3DATA)
      READ(NCNAME,TRDATA)
      READ(NCNAME,THDATA)
      READ(NCNAME,TZDATA)
      READ(NCNAME,TMDATA)
      READ(NCNAME,TPDATA)
      READ(NCNAME,T3DATA)
      READ(NCNAME,TFDATA)
      READ(NCNAME,FHDATA)
      READ(NCNAME,FZDATA)
      READ(NCNAME,FMDATA)
      READ(NCNAME,FPDATA)
      READ(NCNAME,F3DATA)
      READ(NCNAME,ODDATA)
      READ(NCNAME,OHDATA)
      READ(NCNAME,OZDATA)
      READ(NCNAME,OMDATA)
      READ(NCNAME,OPDATA)
      READ(NCNAME,O3DATA)
      READ(NCNAME,ZFDATA)
      READ(NCNAME,TJDATA)

**    Write out the file paths - this is done in INIT

**    Write out the namelists to output and to fiche
      WRITE(6,6060)
      WRITE(NCFICH,6060)
6060  FORMAT(1X,//'NAMELIST DATA READ BY PROGRAM'/)
      WRITE(6,GLOBAL)
      WRITE(6,6100)YOBLNK
6100  FORMAT(1X,A)
      WRITE(6,FLXTYP)
      WRITE(6,6100)YOBLNK
      WRITE(6,SMSPEC)
      WRITE(6,6100)YOBLNK
      WRITE(6,PHDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,XPDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,LVDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,ORDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,CODATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,SGDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,GHDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,GZDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,GMDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,GPDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,G3DATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,TRDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,THDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,TZDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,TMDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,TPDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,T3DATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,TFDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,FHDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,FZDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,FMDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,FPDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,F3DATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,ZFDATA)
      WRITE(6,6100)YOBLNK
      WRITE(6,TJDATA)
      WRITE(6,6100)YOBLNK

      WRITE(NCFICH,GLOBAL)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,FLXTYP)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,SMSPEC)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,PHDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,XPDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,LVDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,ORDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,CODATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,SGDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,GHDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,GZDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,GMDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,GPDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,G3DATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,TRDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,THDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,TZDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,TMDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,TPDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,T3DATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,TFDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,FHDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,FZDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,FMDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,FPDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,F3DATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,ZFDATA)
      WRITE(NCFICH,6100)YOBLNK
      WRITE(NCFICH,TJDATA)
      WRITE(NCFICH,6100)YOBLNK

      RETURN
      END
      SUBROUTINE AVGCHK(LPMASS,LPMSK,LPSIG,YPTYP,KERR)
**    Function - to check mask and weighting factors
**    Args in -
**               LPMASS  - .TRUE. if user has requested that SG
**                         fields be multiplied by the isentropic
**                         mass factor (sigma) (=LMASSW)
**               LPMSK   - .TRUE. if user has requested use of
**                         land/air mask in the calculation of
**                         averages (eg spatial and temporal) (=LAVMSK)
**               LPSIG   - .TRUE. if user has requested use of
**                         sigma-weighting when computing isentropic
**                         surface averages (=LAVSIG)
**               YPTYP   - CHARACTER*2 surface type
**               KERR    - Error flag
**    Args out -
**               LPMASS  - changed to .FALSE. if output is not on
**                         isentropic surfaces
**               LPMSK   - changed to .FALSE. if output is on model
**                         levels, and currently set to .FALSE. if
**                         output is on pressure levels
**               LPSIG   - changed to .FALSE. if output not on
**                         isentropic surfaces, or if LPMASS is .TRUE.
**               KERR    - Set to 999 if possible conflicting flags
**                         set by the user
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Called by - DATCHK
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      CHARACTER*2 YPTYP
      LOGICAL LPMASS,LPMSK,LPSIG

**    It should be noted that the value of AIRLL set in the routine
**    LLAIR should be related to which of the above logical flags
**    are allowed on the output surfaces.

**    Currently, land/air masks are not employed when computing
**    averages on pressure surfaces. This is for compatibility with
**    the old BGFLUX program. Thus LPMSK should be set to .FALSE.
**    for compatibility when output is on pressure surfaces.

**    Currently, LPSIG and LPMSK are only employed in the
**    calculation of temporal, zonal mean and meridional mean averages.

**    Unless output surface type is isentropic, LPMASS must be .FALSE.
      IF(YPTYP.NE.'TH'.AND.LPMASS) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'AVGCHK: OUTPUT SURFACE TYPE NOT ISENTROPIC, BUT',
     -         ' USER HAS REQUESTED USE OF SIGMA-WEIGHTED FIELDS',
     -         /,' SIGMA-WEIGHTED FIELDS NOT PRODUCED; LMASSW=.FALSE.')
         LPMASS=.FALSE.
      ENDIF

**    Unless output surface type is isentropic, LPSIG must be .FALSE.
      IF(YPTYP.NE.'TH'.AND.LPSIG) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'AVGCHK: OUTPUT SURFACE TYPE NOT ISENTROPIC, BUT',
     -         ' USER HAS REQUESTED USE OF SIGMA-WEIGHTED AVERAGES',
     -         /,' SIGMA-WEIGHTED FIELDS NOT PRODUCED; LAVSIG=.FALSE.')
         LPSIG=.FALSE.
      ENDIF

**    When output is on model surfaces, there is no need to use the
**    land/air mask; thus LPMSK should be set to .FALSE.
      IF(YPTYP.EQ.'ET'.AND.LPMSK) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'AVGCHK: OUTPUT SURFACE TYPE IS SIGMA, SO',
     -         ' NO NEED TO SET LAVMSK=.TRUE.')
         LPMSK=.FALSE.
      ENDIF

**    (TEMPORARY CHANGE ONLY - see value of AIRLL in routine LLAIR)
**    Land/air mask not used when output is on pressure surfaces.
      IF(YPTYP.EQ.'IS'.AND.LPMSK) THEN
         WRITE(6,6030)
6030     FORMAT(1X,'AVGCHK: OUTPUT SURFACE TYPE IS PRESSURE:',
     -         ' PROGRAM SETS LAVMSK=.TRUE. FOR COMPATIBILITY WITH ',
     -         /,' OLD VERSION OF BGFLUX PROGRAM')
         LPMSK=.FALSE.
      ENDIF

**    Possible error if user has set LMASSW and LAVSIG both .TRUE.
      IF(LPSIG.AND.LPMASS) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'AVGCHK: ERROR - BOTH LMASSW AND LAVSIG HAVE BEEN',
     -         ' SET .TRUE.')
         LPSIG=.FALSE.
         KERR=999
      ENDIF

**    Possible error if user has set LAVMSK and LAVSIG both .TRUE.
      IF(LPSIG.AND.LPMSK) THEN
         WRITE(6,6050)
6050     FORMAT(1X,'AVGCHK: ERROR -BOTH LAVMSK AND LAVSIG HAVE BEEN',
     -         ' SET .TRUE.')
         LPMSK=.FALSE.
         KERR=999
      ENDIF

      RETURN
      END
      SUBROUTINE CHKCO(KERR)
**    Function - to check CO data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/LWRITE,/CODIAG/NWAVET,NCOPR,NVCOHR
**    Com changed - /DIAGTP/LDCO
**    Params used - /PARAM1/JPNL,JPNN,/PARAM3/JPCOMX
**    Called by - DATCHK
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      DIMENSION ICOFLD(JPCOMX)
      LOGICAL LOVALU
**    ICOFLD - allowed CO field codes
      DATA ICOFLD/1,2,3,4,5,6/

**    Check that printing has been requested - if not, switch off CO
**          diagnostics
      IF(.NOT.LWRITE) THEN
         PRINT 6000
6000     FORMAT(1X,'CHKCO: CO DIAGNOSTICS SWITCHED OFF SINCE NO ',
     -         'PRINTING HAS BEEN REQUESTED')
         LDCO=.FALSE.
         RETURN
      ENDIF

**    Check valid code numbers in NCOPR
      IF(NCOPR(1).NE.0) THEN
         DO 2000 K=1,JPCOMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPCOMX
         IF((NCOPR(K).EQ.ICOFLD(J)).OR.(NCOPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKCO: ERROR IN NCOPR VALUES')
         ENDIF
2000     CONTINUE
      ELSE
**       Switch off CO diagnostics if no fields specified
         PRINT 6025
6025     FORMAT(1X,'CHKCO: CO DIAGNOSTICS SWITCHED OFF - NO FIELDS'
     -         ' SELECTED')
         LDCO=.FALSE.
      ENDIF

**    Check that the maximum total wavenumber requested is
**          greater than 0
      IF(NWAVET.LT.1) THEN
         PRINT 6010
6010     FORMAT(1X,'CHKCO: ERROR, NWAVET<1')
         KERR=999
      ENDIF

**    Check that NWAVET is not greater than JPNN
      IF(NWAVET.GT.JPNN) THEN
         PRINT 6015
6015     FORMAT(1X,'CHKCO: WARNING, NWAVET REDUCED TO JPNN')
         NWAVET=JPNN
      ENDIF

**    Check that all NVCOHR values are valid
      LOVALU=.TRUE.
      DO 3000 J=1,JPNL
      IF((NVCOHR(J).LT.0).OR.(NVCOHR(J).GT.JPNL)) LOVALU=.FALSE.
3000  CONTINUE
      IF(.NOT.LOVALU) THEN
         PRINT 6030
6030     FORMAT(1X,'CHKCO: ERROR IN NVCOHR VALUES')
         KERR=999
      ENDIF

      RETURN
      END
      SUBROUTINE CHKF3(KERR)
**    Function - to check F3 data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /TFDIAG/NTF,/F3DIAG/NCF3,/DIAGTP/LDTF,/COMDAT/
**          LASCII
**    Com changed - /F3DIAG/NF3PL,/TFDIAG/LDF3
**    Params used - /PARAM1/JPNL,/PARAM3/JPTFMX
**    Called by - CHKTF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMMON /F3DIAG/NCF3,NF3PL(JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LOVALU

**    TF/F3 diagnostics require that LDTF and LDF3 are set to .TRUE.
      IF(LDTF.AND.(.NOT.LDF3)) THEN
         PRINT 6000
6000     FORMAT(1X,'CHKF3: WARNING - F3 DIAGNOSTICS SWITCHED OFF',
     -         ' LDTF/LDF3 FLAGS NOT BOTH SET')
         RETURN
      ENDIF

**    Check that UTFs are requested - if not, ensure NF3PL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NF3PL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKF3: NF3PL VALUES CHANGED - NO O/P')
            DO 1100 K=1,JPTFMX
1100        NF3PL(K)=0
         ENDIF
      ENDIF

**    Check valid code numbers in NT3PL
      IF(NF3PL(1).NE.0) THEN
         DO 3000 K=1,NTF
         LOVALU=.FALSE.
         IF(NF3PL(K).LE.NTF.AND.NF3PL(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKF3: ERROR IN NF3PL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NF3PL(1) is zero
      IF(NF3PL(1).EQ.0.AND.LDF3) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKF3: F3 DIAGNOSTICS SWITCHED OFF, NF3PL(1)=0')
         LDF3=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDF3) RETURN

      IF(NTF.LT.JPTFMX) THEN
         DO 2001 J=NTF+1,JPTFMX
         NF3PL(J)=0
2001     CONTINUE
      ENDIF

**    Check channel for output of 3-D fields
      IF(LDF3.AND.NCF3.LE.0) THEN
         PRINT 6050
6050     FORMAT(1X,'CHKF3: ERROR - F3 DIAGNOSTICS REQUESTED BUT',
     -         ' NCF3 CHANNEL NUMBER INVALID')
         KERR=999
      ENDIF

      RETURN
      END
      SUBROUTINE CHKFH(KERR)
**    Function - to check FH data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /TFDIAG/NTF,NVTFHR,VTFSFC/COMDAT/LWRITE,LASCII,YTYPSF,
**          /DIAGTP,LDTF,/FHDIAG/LDFHSL
**    Com changed - /FHDIAG/NFHPR,NFHPL,/TFDIAG/LDFH
**    Params used - /PARAM1/JPNL,/PARAM3/JPTRMX
**    Called by - CHKTF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDFHSL
      COMMON /FHDIAG/NFHPR(JPTFMX),NFHPL(JPTFMX),CINTFH(JPTFMX),LDFHSL
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LOVALU

**    TF/FH diagnostics require that LDTF and LDFH are set to .TRUE.
      IF((.NOT.LDTF).OR.(.NOT.LDFH)) THEN
         IF(LDFHSL) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKFH: WARNING - FH DIAGNOSTICS SWITCHED OFF',
     -            ' HORIZONTAL LDTF/LDFH FLAGS NOT BOTH SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NFHPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NFHPR(1).NE.0) THEN
            PRINT 6005
6005        FORMAT(1X,'CHKFH: NFHPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPTFMX
1000        NFHPR(K)=0
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NFHPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NFHPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKFH: NFHPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPTFMX
1100        NFHPL(K)=0
         ENDIF
      ENDIF

**    Check valid code numbers in NFHPR
      IF(NFHPR(1).NE.0) THEN
         DO 2000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFHPR(K).LE.NTF.AND.NFHPR(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKFH: ERROR IN NFHPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NFHPL
      IF(NFHPL(1).NE.0) THEN
         DO 3000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFHPL(K).LE.NTF.AND.NFHPL(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKFH: ERROR IN NFHPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

      IF(NTF.LT.JPTFMX) THEN
         DO 2001 J=NTF+1,JPTFMX
         NFHPL(J)=0
         NFHPR(J)=0
2001     CONTINUE
      ENDIF

**    Check that NVTFHR or VTFSFC have been set if LDFHSL is .TRUE.
      IF(LDFHSL.AND.(YTYPSF.EQ.'ET').AND.(NVTFHR(1).EQ.0)) THEN
         PRINT 6055
6055     FORMAT(1X,'CHKFH: ERROR - HORIZONTAL SLICE O/P REQUIRES'
     -         ' NVTFHR TO BE SPECIFIED FOR O/P ON SIGMA SURFACES')
         KERR=999
      ENDIF
      ZDELTA=1.0E-3
      IF(LDFHSL.AND.(YTYPSF.NE.'ET').AND.(VTFSFC(1).LE.ZDELTA)) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKFH: ERROR - HORIZONTAL SLICE O/P REQUIRES'
     -         ' VTFSFC TO BE SPECIFIED FOR O/P ON NON-SIGMA SURFACES')
         KERR=999
      ENDIF

      IF(NFHPL(1).EQ.0.AND.NFHPR(1).EQ.0) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'CHKFH: FH DIAGNOSTICS SWITCHED OFF, NO FIELDS',
     -         ' SELECTED FOR PRINT OR PLOT')
         LDFH=.FALSE.
      ENDIF

      RETURN
      END
      SUBROUTINE CHKFM(KERR)
**    Function - to check FM data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /TFDIAG/NTF,/FMDIAG/VFMEW,VFMEWA,LDFMMM,
**          /DIAGTP/LDTF,/COMDAT/LASCII,LWRITE
**    Com changed - /FMDIAG/NFMPR,NFMPL/TFDIAG/LDFM
**    Params used - /PARAM1/JPNL,/PARAM3/JPTRMX
**    Called by - CHKTF
**    Calls - LATCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDFMMM
      COMMON /FMDIAG/LDFMMM,VFMEW,VFMEWA(2),NFMPR(JPTFMX),
     -      NFMPL(JPTFMX),CINTFM(JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LOVALU

**    TR/TM diagnostics require that LDTR and LDTM are set to .TRUE.
      IF((.NOT.LDTF).OR.(.NOT.LDFM)) THEN
         IF((LDFMMM).OR.(VFMEW.GT.-90.0).OR.
     -         (VFMEWA(1).GT.-90.0).OR.(VFMEWA(2).GT.-90.0)) THEN
             PRINT 6000
6000         FORMAT(1X,'CHKFM: WARNING - FM DIAGNOSTICS SWITCHED OFF',
     -            ' LDTF/LDFM FLAGS NOT BOTH SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NFMPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NFMPR(1).NE.0) THEN
            PRINT 6005
6005        FORMAT(1X,'CHKFM: NFMPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPTFMX
1000        NFMPR(K)=0
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NFMPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NFMPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKFM: NFMPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPTFMX
1100        NFMPL(K)=0
         ENDIF
      ENDIF

**    Check valid code numbers in NFMPR
      IF(NFMPR(1).NE.0) THEN
         DO 2000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFMPR(K).LE.NTF.AND.NFMPR(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKMM: ERROR IN NMMPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NFMPL
      IF(NFMPL(1).NE.0) THEN
         DO 3000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFMPL(K).LE.NTF.AND.NFMPL(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKFM: ERROR IN NFMPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

      IF(NTF.LT.JPTFMX) THEN
         DO 2001 J=NTF+1,JPTFMX
         NFMPL(J)=0
         NFMPR(J)=0
2001     CONTINUE
      ENDIF

      IF(NFMPL(1).EQ.0.AND.NFMPR(1).EQ.0) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'CHKFM: FM DIAGNOSTICS SWITCHED OFF, NO FIELDS',
     -         ' SELECTED FOR PRINT OR PLOT')
         LDFM=.FALSE.
      ENDIF

**    Check validity of VTMEW AND VTMEWA values
      CALL LATCHK(VFMEW,1,-999.0,'(TF) FM VFMEW')
      CALL LATCHK(VFMEWA,2,-999.0,'(TF) FM VFMEWA')

      RETURN
      END
      SUBROUTINE CHKFP(KERR)
**    Function - to check FP data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /TPDIAG/NFPPR,NFPPL,NFPPF,VFPPF,LDFPCP,/DIAGTP/LDTF,
**          /COMDAT/LWRITE,LASCII
**    Com changed - /FPDIAG/NFPPR,NFPPL/TFDIAG/LDFP
**    Params used - /PARAM1/JPNL,/PARAM3/JPTFMX,JPFPPF
**    Called by - CHKTF
**    Calls - LATCHK,LNGCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDFPCP
      COMMON /FPDIAG/NFPPF,VFPPF(2,JPFPPF),NFPPR(JPTFMX),
     -      NFPPL(JPTFMX),LDFPCP
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LOVALU

**    TF/FP diagnostics require that LDTF and LDFP are set to .TRUE.
      IF((.NOT.LDTF).OR.(.NOT.LDFP)) THEN
         IF(LDFPCP) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKFP: WARNING - FP DIAGNOSTICS SWITCHED OFF',
     -            ' LDTF/LDFP FLAGS NOT BOTH SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NFPPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NFPPR(1).NE.0) THEN
            PRINT 6060
6060        FORMAT(1X,'CHKFP: NFPPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPTFMX
1000        NFPPR(K)=0
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NFPPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NFPPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKFP: NFPPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPTFMX
1100        NFPPL(K)=0
         ENDIF
      ENDIF

**    Check valid code numbers in NFPPR
      IF(NFPPR(1).NE.0) THEN
         DO 2000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFPPR(K).LE.NTF.AND.NFPPR(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKFP: ERROR IN NFPPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NFPPL
      IF(NFPPL(1).NE.0) THEN
         DO 3000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFPPL(K).LE.NTF.AND.NFPPL(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKFP: ERROR IN NFPPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

      IF(NTF.LT.JPTFMX) THEN
         DO 2001 J=NTF+1,JPTFMX
         NFPPL(J)=0
         NFPPR(J)=0
2001     CONTINUE
      ENDIF

      IF(NFPPL(1).EQ.0.AND.NFPPR(1).EQ.0) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'CHKFP: FP DIAGNOSTICS SWITCHED OFF, NO FIELDS',
     -         ' SELECTED FOR PRINT OR PLOT')
         LDFP=.FALSE.
      ENDIF

**    Check validity of profile coordinates
      IF(NFPPF.LT.0.OR.NFPPF.GT.JPFPPF) THEN
         PRINT 6050
6050     FORMAT(1X,'CHKFP: ERROR - INVALID NFPPF')
         RETURN
      ENDIF

      IF(NFPPF.GT.0) THEN
         DO 100 JL=1,NFPPF
         CALL LATCHK(VFPPF(1,JL),1,-999.0,'(TF) FP VFPPF')
         CALL LNGCHK(VFPPF(2,JL),1,-999.0,'(TF) FP VFPPF')
         IF((VFPPF(1,JL).LT.-90.0).OR.(VFPPF(2,JL).LT.-90.0)) THEN
            PRINT 6080
6080        FORMAT(1X,'CHKFP: ERROR - INVALID PROFILE COORDINATES')
            KERR=999
         ENDIF
100      CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE CHKFZ(KERR)
**    Function - to check FZ data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /TFDIAG/NTF,/FZDIAG/VFZNS,VFZNSA,LDFZZM,
**          /DIAGTP/LDTF,/COMDAT/LWRITE,LASCII
**    Com changed - /FZDIAG/NFZPR,NFZPL,/TFDIAG/LDFZ
**    Params used - /PARAM1/JPNL,/PARAM3/JPTFMX
**    Called by - CHKTF
**    Calls - LNGCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDFZZM
      COMMON /FZDIAG/LDFZZM,VFZNS,VFZNSA(2),NFZPR(JPTFMX),
     -      NFZPL(JPTFMX),CINTFZ(JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LOVALU

**    TF/FZ diagnostics require that LDTF and LDFZ are set to .TRUE.
      IF((.NOT.LDTF).OR.(.NOT.LDFZ)) THEN
         IF((LDFZZM).OR.(VFZNS.GT.0.0).OR.
     -         (VFZNSA(1).GT.0.0).OR.(VFZNSA(2).GT.0.0)) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKFZ: WARNING - FZ DIAGNOSTICS SWITCHED OFF,',
     -            ' LDTF/LDTZ FLAGS NOT BOTH SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NFZPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NFZPR(1).NE.0) THEN
            PRINT 6005
6005        FORMAT(1X,'CHKFZ: NFZPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPTFMX
1000        NFZPR(K)=0
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NFZPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NFZPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKFZ: NFZPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPTFMX
1100        NFZPL(K)=0
         ENDIF
      ENDIF

**    Check valid code numbers in NFZPR
      IF(NFZPR(1).NE.0) THEN
         DO 2000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFZPR(K).LE.NTF.AND.NFZPR(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKFZ: ERROR IN NFZPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NFZPL
      IF(NFZPL(1).NE.0) THEN
         DO 3000 K=1,NTF
         LOVALU=.FALSE.
         IF(NFZPL(K).LE.NTF.AND.NFZPL(K).GE.0) LOVALU=.TRUE.
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKFZ: ERROR IN NFZPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

      IF(NTF.LT.JPTFMX) THEN
         DO 2001 J=NTF+1,JPTFMX
         NFZPL(J)=0
         NFZPR(J)=0
2001     CONTINUE
      ENDIF

      IF(NFZPL(1).EQ.0.AND.NFZPR(1).EQ.0) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'CHKFZ: FZ DIAGNOSTICS SWITCHED OFF, NO FIELDS',
     -         ' SELECTED FOR PRINT OR PLOT')
         LDFZ=.FALSE.
      ENDIF

**    Check validity of VFZNS AND VFZNSA values
      CALL LNGCHK(VFZNS,1,-999.0,'(TF) FZ VFZNS')
      CALL LNGCHK(VFZNSA,2,-999.0,'(TF) FZ VFZNSA')

      RETURN
      END
      SUBROUTINE CHKG3(KERR)
**    Function - to check G3 data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /SGDIAG/LDG3,/G3DIAG/NCG3,/DIAGTP/LDSG,/COMDAT/LASCII
**    Com changed - /G3DIAG/NG3,NG3PL,NG3PR
**    Params used - /PARAM1/JPNL,/PARAM3/JPSGMX
**    Called by - CHKSG
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMMON /G3DIAG/NCG3,NG3PL(JPSGMX),NG3
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      DIMENSION ISGFLD(JPSGMX)
      LOGICAL LOVALU

**    ISGFLD - allowed SG field codes
      DO 100 J=1,JPSGMX
      ISGFLD(J)=J
100   CONTINUE

**    SG/G3 diagnostics require that LDSG and LDG3 are set to .TRUE.
      IF((.NOT.LDSG).OR.(.NOT.LDG3)) THEN
         IF(NCG3.GT.0) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKG3: WARNING - G3 DIAGNOSTICS REQUESTED BUT',
     -            ' HORIZONTAL LDSG/LDG3 FLAGS NOT SET')
            RETURN
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NG3PL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NG3PL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKG3: NG3PL VALUES CHANGED - NO O/P')
            DO 1100 K=1,JPSGMX
1100        NG3PL(K)=0
**          Reset value of NG3
            NG3=0
         ENDIF
      ENDIF

**    Check valid code numbers in NG3PL
      IF(NG3PL(1).NE.0) THEN
         DO 3000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPSGMX
         IF((NG3PL(K).EQ.ISGFLD(J)).OR.(NG3PL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKG3: ERROR IN NG3PL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NG3 is zero
      IF(NG3.EQ.0.AND.LDG3) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKG3: G3 DIAGNOSTICS SWITCHED OFF, NG3=0')
         LDG3=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDG3) RETURN

**    Check that NG3 is non-zero, and less than JPSGMX
      IF(NG3.LE.0.OR.(NG3.GT.JPSGMX)) THEN
         PRINT 6040
6040     FORMAT(1X,'CHKG3 : INVALID VALUE FOR NG3')
         KERR=999
      ENDIF

**    Check channel for output of 3-D fields
      IF(LDG3.AND.NCG3.LE.0) THEN
         PRINT 6050
6050     FORMAT(1X,'CHKG3: ERROR - G3 DIAGNOSTICS REQUESTED BUT',
     -         ' NCG3 CHANNEL NUMBER INVALID')
         KERR=999
      ENDIF

      RETURN
      END
      SUBROUTINE CHKGH(KERR)
**    Function - to check GH data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /SGDIAG/NVSGHR,VSGSFC,/GHDIAG/LDGHSL,LDGHCT,NGHVEC,
**          VGHTS,/DIAGTP/LDSG,/COMDAT/YTYPSF.LWRITE,LASCII
**    Com changed - /GHDIAG/NGHPR,NGHPL,NGH,/SGDIAG/LDGH
**    Params used - /PARAM1/JPNL,JPNHEM,JPMOCT,/PARAM3/JPSGMX
**    Called by - CHKSG
**    Calls - LATCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LOVALU
      DIMENSION ISGFLD(JPSGMX)

**    ISGFLD - allowed SG field codes
      DO 100 J=1,JPSGMX
      ISGFLD(J)=J
100   CONTINUE

**    SG/GH diagnostics require that LDSG and LDGH are set to .TRUE.
      IF((.NOT.LDSG).OR.(.NOT.LDGH)) THEN
         IF((LDGHSL).OR.(LDGHCT).OR.(VGHTS(1).GT.-90.0).OR.
     -         (VGHTS(2).GT.-90.0)) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKGH: WARNING - GH DIAGNOSTICS REQUESTED BUT',
     -            ' HORIZONTAL LDSG/LDGH FLAGS NOT SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NGHPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NGHPR(1).NE.0) THEN
            PRINT 6005
6005        FORMAT(1X,'CHKGH: NGHPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPSGMX
1000        NGHPR(K)=0
**          Reset value of NGH
            NGH=0
            DO 1001 K=1,JPSGMX
            IF(NGHPL(K).GT.0) NGH=NGH+1
1001        CONTINUE
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NGHPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NGHPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKGH: NGHPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPSGMX
1100        NGHPL(K)=0
**          Reset value of NGH
            NGH=0
            DO 1101 K=1,JPSGMX
            IF(NGHPR(K).GT.0) NGH=NGH+1
1101        CONTINUE
         ENDIF
      ENDIF

**    Check valid code numbers in NGHPR
      IF(NGHPR(1).NE.0) THEN
         DO 2000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPSGMX
         IF((NGHPR(K).EQ.ISGFLD(J)).OR.(NGHPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKGH: ERROR IN NGHPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NGHPL
      IF(NGHPL(1).NE.0) THEN
         DO 3000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPSGMX
         IF((NGHPL(K).EQ.ISGFLD(J)).OR.(NGHPL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKGH: ERROR IN NGHPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NGH is zero
      IF(NGH.EQ.0.AND.LDGH) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKGH: GH DIAGNOSTICS SWITCHED OFF, NGH=0')
         LDGH=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDGH) RETURN

**    Check that NGHVEC values correspond to NGHPL values
      IF(NGHVEC(1).NE.0) THEN
         DO 3500 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3600 J=1,JPSGMX
         IF((NGHVEC(K).EQ.NGHPL(J)).OR.(NGHVEC(K).EQ.0)) LOVALU=.TRUE.
3600     CONTINUE
         IF(.NOT.LOVALU) THEN
            PRINT 6050
6050        FORMAT(1X,'CHKGH: NGHVEC CORRESPONDS TO NON-PLOTTED FIELD')
         ENDIF
3500     CONTINUE
      ENDIF

**    Check that NGH is non-zero, and less than JPSGMX
      IF(NGH.LE.0.OR.(NGH.GT.JPSGMX)) THEN
         PRINT 6040
6040     FORMAT(1X,'CHKGH : INVALID VALUE FOR NGH')
         KERR=999
      ENDIF

**    Check that NVSGHR or VSGSFC have been set if LDGHSL is .TRUE.
      IF(LDGHSL.AND.(YTYPSF.EQ.'ET').AND.(NVSGHR(1).EQ.0)) THEN
         PRINT 6055
6055     FORMAT(1X,'CHKGH: ERROR - HORIZONTAL SLICE O/P REQUIRES',
     -         ' NVSGHR TO BE SPECIFIED FOR O/P ON SIGMA SURFACES')
         KERR=999
      ENDIF
      ZDELTA=1.0E-3
      IF(LDGHSL.AND.(YTYPSF.NE.'ET').AND.(VSGSFC(1).LE.ZDELTA)) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKGH: ERROR - HORIZONTAL SLICE O/P REQUIRES',
     -         ' VSGSFC TO BE SPECIFIED FOR O/P ON NON-SIGMA SURFACES')
         KERR=999
      ENDIF

**    Check validity of VGHTS values
      CALL LATCHK(VGHTS,2,-999.0,'(SG) GH VGHTS')


      RETURN
      END
      SUBROUTINE CHKGM(KERR)
**    Function - to check GM data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /SGDIAG/NVSGHR,VSGSFC,/GMDIAG/all elements,
**          /DIAGTP/LDSG,/COMDAT/YTYPSF.LASCII,LWRITE
**    Com changed - /GMDIAG/NGMPR,NGMPL,NGM,/SGDIAG/LDGM
**    Params used - /PARAM1/JPNL,JPNHEM.JPMOCT,/PARAM3/JPSGMX
**    Called by - CHKSG
**    Calls - LATCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      DIMENSION ISGFLD(JPSGMX)
      LOGICAL LOVALU

**    ISGFLD - allowed SG field codes
      DO 100 J=1,JPSGMX
      ISGFLD(J)=J
100   CONTINUE


**    SG/GM diagnostics require that LDSG and LDGM are set to .TRUE.
      IF((.NOT.LDSG).OR.(.NOT.LDGM)) THEN
         IF((LDGMMM).OR.(LDGMTS).OR.(VGMEW.GT.-90.0).OR.
     -         (VGMEWA(1).GT.-90.0).OR.(VGMEWA(2).GT.-90.0)) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKGM: WARNING - GM DIAGNOSTICS REQUESTED BUT',
     -            ' HORIZONTAL LDSG/LDGM FLAGS NOT SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NGMPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NGMPR(1).NE.0) THEN
            PRINT 6005
6005        FORMAT(1X,'CHKGM: NGMPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPSGMX
1000        NGMPR(K)=0
**          Reset value of NGM
            NGM=0
            DO 1001 K=1,JPSGMX
            IF(NGMPL(K).GT.0) NGM=NGM+1
1001        CONTINUE
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NGMPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NGMPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKGM: NGMPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPSGMX
1100        NGMPL(K)=0
**          Reset value of NGM
            NGM=0
            DO 1101 K=1,JPSGMX
            IF(NGMPR(K).GT.0) NGM=NGM+1
1101        CONTINUE
         ENDIF
      ENDIF

**    Check valid code numbers in NGMPR
      IF(NGMPR(1).NE.0) THEN
         DO 2000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPSGMX
         IF((NGMPR(K).EQ.ISGFLD(J)).OR.(NGMPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKGM: ERROR IN NGMPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NGMPL
      IF(NGMPL(1).NE.0) THEN
         DO 3000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPSGMX
         IF((NGMPL(K).EQ.ISGFLD(J)).OR.(NGMPL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKGM: ERROR IN NGMPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NGM is zero
      IF(NGM.EQ.0.AND.LDGM) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKGM: GM DIAGNOSTICS SWITCHED OFF, NGM=0')
         LDGM=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDGM) RETURN

**    Check that NGMVEC values correspond to NGMPL values
      IF(NGMVEC(1).NE.0) THEN
         DO 3500 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3600 J=1,JPSGMX
         IF((NGMVEC(K).EQ.NGMPL(J)).OR.(NGMVEC(K).EQ.0)) LOVALU=.TRUE.
3600     CONTINUE
         IF(.NOT.LOVALU) THEN
            PRINT 6050
6050        FORMAT(1X,'CHKGM: NGMVEC CORRESPONDS TO NON-PLOTTED FIELD')
         ENDIF
3500     CONTINUE
      ENDIF

**    Check that NGM is non-zero, and less than JPSGMX
      IF(NGM.LE.0.OR.(NGM.GT.JPSGMX)) THEN
         PRINT 6040
6040     FORMAT(1X,'CHKGM : INVALID VALUE FOR NGM')
         KERR=999
      ENDIF

**    Check that NVSGHR or VSGSFC have been set if LDGMTS is .TRUE.
      IF(LDGMTS.AND.(YTYPSF.EQ.'ET').AND.(NVSGHR(1).EQ.0)) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKGM: ERROR - MERIDIONAL TIMESERIES O/P REQUIRES',
     -         ' NVSGHR TO BE SPECIFIED FOR O/P ON SIGMA SURFACES')
         KERR=999
      ENDIF
      ZDELTA=1.0E-3
      IF(LDGMTS.AND.(YTYPSF.NE.'ET').AND.(VSGSFC(1).LE.ZDELTA)) THEN
         PRINT 6070
6070     FORMAT(1X,'CHKGM: ERROR - MERIDIONAL TIMESERIES O/P REQUIRES',
     -         ' VSGSFC TO BE SPECIFIED FOR O/P ON NON-SIGMA SURFACES')
         KERR=999
      ENDIF

**    Check validity of VGMEW AND VGMEWA values
      CALL LATCHK(VGMEW,1,-999.0,'(SG) GM VGMEW')
      CALL LATCHK(VGMEWA,2,-999.0,'(SG) GM VGMEWA')



      RETURN
      END
      SUBROUTINE CHKGP(KERR)
**    Function - to check GP data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /GPDIAG/all elements,/DIAGTP/LDSG,/COMDAT/LASCII,
**          LWRITE,YTYPSF
**    Com changed - /SGDIAG/LDGP,/GPDIAG/NGPPR,NGPPL,NGP,LDGPCT
**    Params used - /PARAM1/JPNL,JPNHEM.JPMOCT,/PARAM3/JPSGMX,JPGPPF
**    Called by - CHKSG
**    Calls - LATCHK,LNGCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      DIMENSION ISGFLD(JPSGMX)
      LOGICAL LOVALU

**    ISGFLD - allowed SG field codes
      DO 100 J=1,JPSGMX
      ISGFLD(J)=J
100   CONTINUE


**    SG/GP diagnostics require that LDSG and LDGP are set to .TRUE.
      IF((.NOT.LDSG).OR.(.NOT.LDGP)) THEN
         IF((LDGPCT).OR.(VGPPF(1,1).GT.-90.0).OR.(LDGPCP)) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKGP: WARNING - GP DIAGNOSTICS REQUESTED BUT',
     -            ' HORIZONTAL LDSG/LDGP FLAGS NOT SET')
            RETURN
         ENDIF
      ENDIF

**    LDGPCT only valid if output is on model surfaces
      IF(YTYPSF.NE.'ET'.AND.LDGPCT) THEN
         PRINT 6005
6005     FORMAT(1X,'CHKGP: ERROR - GP COLUMN TOTALS CANNOT BE FOUND',
     -         'WHEN OUTPUT NOT ON ET SURFACES')
         LDGPCT=.FALSE.
         KERR=999
      ENDIF

*    Check that printing has been requested - if not, ensure
**          NGPPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NGPPR(1).NE.0) THEN
            PRINT 6060
6060        FORMAT(1X,'CHKGP: NGPPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPSGMX
1000        NGPPR(K)=0
**          Reset value of NGP
            NGP=0
            DO 1001 K=1,JPSGMX
            IF(NGPPL(K).GT.0) NGP=NGP+1
1001        CONTINUE
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NGPPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NGPPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKGP: NGPPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPSGMX
1100        NGPPL(K)=0
**          Reset value of NGP
            NGP=0
            DO 1101 K=1,JPSGMX
            IF(NGPPR(K).GT.0) NGP=NGP+1
1101        CONTINUE
         ENDIF
      ENDIF

**    Check valid code numbers in NGPPR
      IF(NGPPR(1).NE.0) THEN
         DO 2000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPSGMX
         IF((NGPPR(K).EQ.ISGFLD(J)).OR.(NGPPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKGP: ERROR IN NGPPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NGPPL
      IF(NGPPL(1).NE.0) THEN
         DO 3000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPSGMX
         IF((NGPPL(K).EQ.ISGFLD(J)).OR.(NGPPL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKGP: ERROR IN NGPPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NGP is zero
      IF(NGP.EQ.0.AND.LDGP) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKGP: GP DIAGNOSTICS SWITCHED OFF, NGP=0')
         LDGP=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDGP) RETURN

**    Check that NGP is non-zero, and less than JPSGMX
      IF(NGP.LE.0.OR.(NGP.GT.JPSGMX)) THEN
         PRINT 6040
6040     FORMAT(1X,'CHKGP : INVALID VALUE FOR NGP')
         KERR=999
      ENDIF

**    Check validity of profile coordinates (IPROFL is max no. of
**    profiles allowed)
      IF(NGPPF.LT.0.OR.NGPPF.GT.JPGPPF) THEN
         PRINT 6045
6045     FORMAT(1X,'CHKGP: ERROR - INVALID NGPPF')
         KERR=999
         RETURN
      ENDIF

      IF(NGPPF.GT.0) THEN
         DO 4000 JL=1,NGPPF
         CALL LATCHK(VGPPF(1,JL),1,-999.0,'(SG) GP VGPPF')
         CALL LNGCHK(VGPPF(2,JL),1,-999.0,'(SG) GP VGPPF')
         IF((VGPPF(1,JL).LT.-90.0).OR.(VGPPF(2,JL).LT.-90.0)) THEN
            PRINT 6080
6080        FORMAT(1X,'CHKGP: ERROR - INVALID PROFILE COORDINATES')
            KERR=999
         ENDIF
4000     CONTINUE
      ENDIF


      RETURN
      END
      SUBROUTINE CHKGZ(KERR)
**    Function - to check GZ data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /SGDIAG/NVSGHR,VSGSFC,/GZDIAG/all elements,
**          /DIAGTP/LDSG,/COMDAT/YTYPSF,LASCII,LWRITE
**    Com changed - /SGDIAG/LDGZ,/GZDIAG/NGZPR,NGZPL,NGZ
**    Params used - /PARAM1/JPNL,JPMOCT,JPNHEM,/PARAM3/JPSGMX
**    Called by - CHKSG
**    Calls - LNGCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      DIMENSION ISGFLD(JPSGMX)
      LOGICAL LOVALU

**    ISGFLD - allowed SG field codes
      DO 100 J=1,JPSGMX
      ISGFLD(J)=J
100   CONTINUE

**    SG/GZ diagnostics require that LDSG and LDGZ are set to .TRUE.
      IF((.NOT.LDSG).OR.(.NOT.LDGZ)) THEN
         IF((LDGZZM).OR.(LDGZTS).OR.(VGZNS.GT.0.0).OR.
     -         (VGZNSA(1).GT.0.0).OR.(VGZNSA(2).GT.0.0)) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKGZ: WARNING - GZ DIAGNOSTICS REQUESTED BUT',
     -            ' HORIZONTAL LDSG/LDGZ FLAGS NOT SET')
            RETURN
         ENDIF
      ENDIF

**    Check that printing has been requested - if not, ensure
**          NGZPR=0 for all elements
      IF(.NOT.LWRITE) THEN
         IF(NGZPR(1).NE.0) THEN
            PRINT 6005
6005        FORMAT(1X,'CHKGZ: NGZPR VALUES CHANGED - NO PRINTING')
            DO 1000 K=1,JPSGMX
1000        NGZPR(K)=0
**          Reset value of NGZ
            NGZ=0
            DO 1001 K=1,JPSGMX
            IF(NGZPL(K).GT.0) NGZ=NGZ+1
1001        CONTINUE
         ENDIF
      ENDIF

**    Check that UTFs are requested - if not, ensure NGZPL=0
**          for all elements
      IF(.NOT.LASCII) THEN
         IF(NGZPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKGZ: NGZPL VALUES CHANGED - NO PLOTTING')
            DO 1100 K=1,JPSGMX
1100        NGZPL(K)=0
**          Reset value of NGZ
            NGZ=0
            DO 1101 K=1,JPSGMX
            IF(NGZPR(K).GT.0) NGZ=NGZ+1
1101        CONTINUE
         ENDIF
      ENDIF

**    Check valid code numbers in NGZPR
      IF(NGZPR(1).NE.0) THEN
         DO 2000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPSGMX
         IF((NGZPR(K).EQ.ISGFLD(J)).OR.(NGZPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKGZ: ERROR IN NGZPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NGZPL
      IF(NGZPL(1).NE.0) THEN
         DO 3000 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPSGMX
         IF((NGZPL(K).EQ.ISGFLD(J)).OR.(NGZPL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKGZ: ERROR IN NGZPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NGZ is zero
      IF(NGZ.EQ.0.AND.LDGZ) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKGZ: GZ DIAGNOSTICS SWITCHED OFF, NGZ=0')
         LDGZ=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDGZ) RETURN

**    Check that NGZVEC values correspond to NGZPL values
      IF(NGZVEC(1).NE.0) THEN
         DO 3500 K=1,JPSGMX
         LOVALU=.FALSE.
         DO 3600 J=1,JPSGMX
         IF((NGZVEC(K).EQ.NGZPL(J)).OR.(NGZVEC(K).EQ.0)) LOVALU=.TRUE.
3600     CONTINUE
         IF(.NOT.LOVALU) THEN
            PRINT 6050
6050        FORMAT(1X,'CHKGZ: NGZVEC CORRESPONDS TO NON-PLOTTED FIELD')
         ENDIF
3500     CONTINUE
      ENDIF

**    Check that NGZ is non-zero, and less than JPSGMX
      IF(NGZ.LE.0.OR.(NGZ.GT.JPSGMX)) THEN
         PRINT 6040
6040     FORMAT(1X,'CHKGZ : INVALID VALUE FOR NGZ')
         KERR=999
      ENDIF

**    Check that NVSGHR or VSGSFC have been set if LDGZTS is .TRUE.
      IF(LDGZTS.AND.(YTYPSF.EQ.'ET').AND.(NVSGHR(1).EQ.0)) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKGZ: ERROR - ZONAL TIMESERIES O/P REQUIRES',
     -         ' NVSGHR TO BE SPECIFIED FOR O/P ON SIGMA SURFACES')
         KERR=999
      ENDIF
      ZDELTA=1.0E-3
      IF(LDGZTS.AND.(YTYPSF.NE.'ET').AND.(VSGSFC(1).LE.ZDELTA)) THEN
         PRINT 6070
6070     FORMAT(1X,'CHKGZ: ERROR - ZONAL TIMESERIES O/P REQUIRES',
     -         ' VSGSFC TO BE SPECIFIED FOR O/P ON NON-SIGMA SURFACES')
         KERR=999
      ENDIF

**    Check validity of VGZNS AND VGZNSA values
      CALL LNGCHK(VGZNS,1,-999.0,'(SG) GZ VGZNS')
      CALL LNGCHK(VGZNSA,2,-999.0,'(SG) GZ VGZNSA')


      RETURN
      END
      SUBROUTINE CHKLV(KERR)
**    Function - to check output-level data input by user
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,/LVDIAG/OUTLEV
**    Com changed - none
**    Params used - /PARAM1/JPNL
**    Called by - DATCHK
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)

**    Check values of OUTLEV; values of 0.0 are allowed, so check for
**    values less than -1.0E-10
      ZTOL=-1.0E-3
      IF(YTYPSF.EQ.'IS') THEN
**       Pressure level output - values should be in mb
         DO 1000 J=1,JPNL
         IF(OUTLEV(J).LT.ZTOL) THEN
            PRINT 6000,OUTLEV(J)
6000        FORMAT(1X,'CHKLV: INVALID OUTPUT PRESSURE LEVEL : ',F12.3)
            KERR=999
         ELSE IF(OUTLEV(J).GT.1200.0) THEN
            PRINT 6000,OUTLEV(J)
            KERR=999
         ENDIF
1000     CONTINUE
      ELSE IF(YTYPSF.EQ.'TH') THEN
**       Isentropic level output - values should be in deg Kelvin
         DO 1100 J=1,JPNL
         IF(OUTLEV(J).LT.ZTOL) THEN
            PRINT 6010,OUTLEV(J)
6010        FORMAT(1X,'CHKLV: INVALID OUTPUT THETA LEVEL : ',F12.3,
     -            ' KELVIN')
            KERR=999
         ELSE IF(OUTLEV(J).LT.250.0.AND.OUTLEV(J).GT.-ZTOL) THEN
            PRINT 6020,OUTLEV(J)
6020        FORMAT(1X,'CHKLV: WARNING, OUTPUT THETA LEVEL = ',F12.3,
     -            ' KELVIN')
         ELSE IF(OUTLEV(J).GT.5000.0) THEN
            PRINT 6020,OUTLEV(J)
         ENDIF
1100     CONTINUE
      ENDIF
**    OUTLEV field not used when output is on model levels

      RETURN
      END
      SUBROUTINE CHKOR(KERR)
**    Function - to check orographic data input by user
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,LASCII,LWRITE
**    Com changed - /ORDIAG/LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE,
**          /COMDAT/LROGR
**    Params used - none
**    Called by - DATCHK
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE

**    Initial orography (geopotential) output requires LROGR=.TRUE.,
**    LASCII and/or LWRITE set to .TRUE. (as appropriate), and
**    LROGPR and/or LROGPL set to .TRUE.
      IF(.NOT.LROGR) THEN
         IF(LROGPR) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKOR: LROGPR SET TO .FALSE. SINCE LROGR IS ',
     -            'FALSE')
            LROGPR=.FALSE.
         ENDIF
         IF(LROGPL) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKOR: LROGPL SET TO .FALSE. SINCE LROGR IS ',
     -            'FALSE')
            LROGPL=.FALSE.
         ENDIF
      ENDIF
      IF(LROGPL.AND..NOT.LASCII) THEN
         PRINT 6020
6020     FORMAT(1X,'CHKOR: LROGPL SET TO .FALSE. SINCE NO ',
     -         'UTFS REQUESTED')
         LROGPL=.FALSE.
      ENDIF
      IF(LROGPR.AND..NOT.LWRITE) THEN
         PRINT 6030
6030     FORMAT(1X,'CHKOR: LROGPR SET TO .FALSE. SINCE NO ',
     -         'PRINTED OUTPUT REQUESTED')
         LROGPR=.FALSE.
      ENDIF

**    Orographic masks requires pressure level output (this will
**    change in future to include theta surface output), and
**    LASCII set to .TRUE.
      IF(YTYPSF.NE.'IS') THEN
         IF(LMSKH.OR.LMSKNS.OR.LMSKWE) THEN
            PRINT 6050
6050        FORMAT(1X,'CHKOR: OROGRAPHIC MASKS SWITCHED OFF - OUTPUT',
     -            ' IS NOT ON PRESSURE SURFACES')
            LMSKH=.FALSE.
            LMSKNS=.FALSE.
            LMSKWE=.FALSE.
         ENDIF
      ENDIF
      IF(.NOT.LASCII.AND.(LMSKH.OR.LMSKNS.OR.LMSKWE)) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKOR: OROGRAPHIC MASKS SWITCHED OFF - NO',
     -         ' UTF OUTPUT REQUESTED')
      ENDIF

      RETURN
      END
      SUBROUTINE CHKPH(KERR)
**    Function - to check PH data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/LWRITE,LASCII,BEGDAY,ENDDAY,/PHDIAG/NPHPR,NPHPL,
**          VPHEW,VPHEWA,VPHEWS,VPHNS,VPHNSA,VPHNSS,VPHAA,VPHAS,NPH,
**          /MODELC/LHISPH
**    Com changed - /PHDIAG/LDPHTS,LDPHTD,NPHPR,NPHPL,NPH,/DIAGTP/LDPH
**    Params used - /PARAM3/JPPHMX,/PARAM1/JPMOCT,JPNHEM
**    Called by - DATCHK
**    Calls - LATCHK,LNGCHK
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      DIMENSION IPHFLD(JPPHMX)
      LOGICAL LOVALU,LOBOX

**    IPHFLD - allowed PH field codes
      DO 500 J=1,JPPHMX
      IPHFLD(J)=J
500   CONTINUE

      IF(LDPH.AND..NOT.LHISPH) THEN
         PRINT 6500
6500     FORMAT(1X,'CHKPH: PH HISTORY DATA DOES NOT EXIST; PH ',
     -         'DIAGNOSTICS TURNED OFF')
         LDPH=.FALSE.
         RETURN
      ENDIF

**    Check if printing has been requested
      IF(.NOT.LWRITE) THEN
         IF(NPHPR(1).NE.0) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKPH: NPHPR NON ZERO, BUT NO PRINTING SETUP')
            DO 1000 K=1,JPPHMX
1000        NPHPR(K)=0
**          Reset value of NPH
            NPH=0
            DO 1001 K=1,JPPHMX
            IF(NPHPL(K).GT.0) NPH=NPH+1
1001        CONTINUE
         ENDIF
      ENDIF

**    Check if UTFs are requested
      IF(.NOT.LASCII) THEN
         IF(NPHPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKPH: NPHPL NON ZERO, BUT NO PLOTTING SETUP')
            DO 1100 K=1,JPPHMX
1100        NPHPL(K)=0
**          Reset value of NPH
            NPH=0
            DO 1101 K=1,JPPHMX
            IF(NPHPR(K).GT.0) NPH=NPH+1
1101        CONTINUE
         ENDIF
      ENDIF

**    Check valid code numbers in NPHPR
      IF(NPHPR(1).NE.0) THEN
         DO 2000 K=1,JPPHMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPPHMX
         IF((NPHPR(K).EQ.IPHFLD(J)).OR.(NPHPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKPH: ERROR IN NPHPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NPHPL
      IF(NPHPL(1).NE.0) THEN
         DO 3000 K=1,JPPHMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPPHMX
         IF((NPHPL(K).EQ.IPHFLD(J)).OR.(NPHPL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKPH: ERROR IN NPHPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch off diagnostics if NPH is zero
      IF(NPH.EQ.0.AND.LDPH) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKPH: PH DIAGNOSTICS SWITCHED OFF, NPH=0')
         LDPH=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDPH) RETURN

**    Switch off time-series and time-averaging calculations if
**    ENDDAY is not greater than BEGDAY
      IF(ENDDAY.LE.BEGDAY) THEN
         IF(LDPHTS) THEN
            WRITE(6,6100)
6100        FORMAT(1X,'CHKPH: PH TIME-SERIES SWITCHED OFF, SINCE ',
     -            'ENDDAY.LE.BEGDAY')
            LDPHTS=.FALSE.
         ENDIF
         IF(LDPHTD) THEN
            WRITE(6,6110)
6110        FORMAT(1X,'CHKPH: PH TIME-AVERAGES (D) SWITCHED OFF,',
     -            ' SINCE ENDDAY.LE.BEGDAY')
            LDPHTD=.FALSE.
         ENDIF
      ENDIF

**    Check valid latitudes for EW slices
      CALL LATCHK(VPHEW,1,-999.0,'VPHEW')
      CALL LATCHK(VPHEWA,2,-999.0,'VPHEWA')
      CALL LATCHK(VPHEWS,2,-999.0,'VPHEWS')

**    Check valid longitudes for NS slices
      CALL LNGCHK(VPHNS,1,-999.0,'VPHNS')
      CALL LNGCHK(VPHNSA,2,-999.0,'VPHNSA')
      CALL LNGCHK(VPHNSS,2,-999.0,'VPHNSS')

**    Check valid box limits
      CALL LATCHK(VPHAA(1),2,-999.0,'VPHAA')
      CALL LATCHK(VPHAS(1),2,-999.0,'VPHAS')
      CALL LNGCHK(VPHAA(3),2,-999.0,'VPHAA')
      CALL LNGCHK(VPHAS(3),2,-999.0,'VPHAS')

**    Switch off box calculations if one lat/long limit=-999.0
      LOBOX=.TRUE.
      DO 1200 J=1,4
      IF(VPHAA(J).LT.-900.0) LOBOX=.FALSE.
1200  CONTINUE
      IF(.NOT.LOBOX) THEN
         DO 1150 J=1,4
         VPHAA(J)=-999.0
1150     CONTINUE
      ENDIF

      LOBOX=.TRUE.
      DO 1205 J=1,4
      IF(VPHAS(J).LT.-900.0) LOBOX=.FALSE.
1205  CONTINUE
      IF(.NOT.LOBOX) THEN
         DO 1300 J=1,4
         VPHAS(J)=-999.0
1300     CONTINUE
      ENDIF


**    Check value of NPH
      IF((NPH.LE.0).OR.(NPH.GT.JPPHMX)) THEN
         KERR=999
         PRINT 6040,NPH
6040     FORMAT(1X,'CHKPH: INVALID VALUE FOR NPH : ',I5)
      ENDIF

**    Switch off diagnostics if no time-control selected
      IF((.NOT.LDPHTS).AND.(.NOT.LDPHTD).AND.
     -      (.NOT.LDPHIN)) THEN
         PRINT 6150
6150     FORMAT(1X,'CHKPH: NO TIME CONTROLS FOR PH DIAGNOSTICS ',
     -      ': PH DIAGNOSTICS SWITCHED OFF')
         LDPH=.FALSE.
      ENDIF

      RETURN
      END
      SUBROUTINE CHKSG(KERR)
**    Function - to check SG data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/LWRITE,LASCII,BEGDAY,ENDDAY,/SGDIAG/
**          NVSGHR,VSGSFC,LDSGTD,LDSGTS,LDSGIN,LDGH,LDGZ,LDGM,LDGP,LDG3,
**          /COMDAT/YTYPSF,/LVDIAG/OUTLEV
**    Com changed - /DIAGTP/LDSG
**    Params used - /PARAM1/JPNL,/PARAM3/JPSGMX
**    Called by - DATCHK
**    Calls - CHKGH,CHKGZ,GHKGM,CHKGP,CHKG3
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LOVALU

**    Switch off time-series and time-averaging calculations if
**    ENDDAY is not greater than BEGDAY
      IF(ENDDAY.LE.BEGDAY) THEN
         IF(LDSGTS) THEN
            WRITE(6,6100)
6100        FORMAT(1X,'CHKSG: SG TIME-SERIES SWITCHED OFF, SINCE ',
     -            'ENDDAY.LE.BEGDAY')
            LDSGTS=.FALSE.
         ENDIF
         IF(LDSGTD) THEN
            WRITE(6,6110)
6110        FORMAT(1X,'CHKSG: SG TIME-AVERAGES (D) SWITCHED OFF,',
     -            ' SINCE ENDDAY.LE.BEGDAY')
            LDSGTD=.FALSE.
         ENDIF
      ENDIF

**    NVSGHR values only used when output is on model surfaces, and
**    VSGSFC values only used when output is on non-model surfaces
      IF((NVSGHR(1).NE.0).AND.(YTYPSF.NE.'ET')) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKSG: NVSGHR VALUE(S) SUPPLIED, BUT NOT USED')
      ENDIF
      IF((NVSGHR(1).LE.0).AND.(YTYPSF.EQ.'ET')) THEN
         PRINT 6065
6065     FORMAT(1X,'CHKSG: NVSGHR VALUES NOT SUPPLIED,',
     -         ' OUTPUT MAY BE SUPPRESSED')
      ENDIF
      IF((VSGSFC(1).GT.0.0).AND.(YTYPSF.EQ.'ET')) THEN
         PRINT 6070
6070     FORMAT(1X,'CHKSG: VSGSFC VALUE(S) SUPPLIED, BUT NOT USED')
      ENDIF
      IF((VSGSFC(1).LE.0.0).AND.(YTYPSF.NE.'ET')) THEN
         PRINT 6075
6075     FORMAT(1X,'CHKSG: VSGSFC VALUES NOT SUPPLIED,',
     -         ' OUTPUT MAY BE SUPPRESSED')
      ENDIF

**    Check that VSGSFC values are a subset of OUTLEV values if they are
**    to be used. ZDELTA is a small parameter to allow two REAL values
**    to be compared
      ZDELTA=1.0E-3
      IF(YTYPSF.NE.'ET') THEN
         DO 4000 K=1,JPNL
         IF(VSGSFC(K).GT.0.0) THEN
            ZSFCP=VSGSFC(K)+ZDELTA
            ZSFCM=VSGSFC(K)-ZDELTA
            LOVALU=.FALSE.
            DO 4100 J=1,JPNL
            IF(ZSFCM.LE.OUTLEV(J).AND.ZSFCP.GE.OUTLEV(J)) LOVALU=.TRUE.
4100        CONTINUE
            IF(.NOT.LOVALU) THEN
               PRINT 6080,VSGSFC(K)
6080           FORMAT(1X,'CHKSG: VSGSFC CORRESPONDS TO INVALID LEVEL ',
     -               F12.3)
            ENDIF
         ENDIF
4000     CONTINUE
      ENDIF

**    Check that NVSGHR values lie in the range 1 to JPNL
      IF(YTYPSF.EQ.'ET') THEN
         DO 5000 J=1,JPNL
         IF(NVSGHR(J).NE.0) THEN
            IF(NVSGHR(J).LT.1.OR.NVSGHR(J).GT.JPNL) THEN
               PRINT 6090
6090           FORMAT(1X,'CHKSG: INVALID NVSGHR VALUE')
               KERR=999
            ENDIF
         ENDIF
5000     CONTINUE
      ENDIF

**    Switch off diagnostics if no time-control selected
      IF((.NOT.LDSGTS).AND.(.NOT.LDSGTD).AND.(.NOT.LDSGIN)) THEN
         PRINT 6150
6150     FORMAT(1X,'CHKSG: NO TIME CONTROLS FOR SG DIAGNOSTICS ',
     -      ': SG DIAGNOSTICS SWITCHED OFF')
         LDSG=.FALSE.
      ENDIF

      IF(LDSG) THEN
         CALL CHKGH(KERR)
         CALL CHKGZ(KERR)
         CALL CHKGM(KERR)
         CALL CHKGP(KERR)
         CALL CHKG3(KERR)
      ENDIF

      LOVALU=(LDGH.OR.LDGZ.OR.LDGM.OR.LDGP.OR.LDG3).AND.
     -      (LDSGTD.OR.LDSGIN.OR.LDSGTS).AND.LDSG
      IF(.NOT.LOVALU) THEN
         PRINT 6200
6200     FORMAT(1X,'CHKSG: WARNING -- SG DIAGNOSTICS SWITCHED OFF')
         LDSG=.FALSE.
         KERR=999
      ENDIF

      RETURN
      END
      SUBROUTINE CHKSTP
**    Function - to check that history file contains data at intervals
**          of NFREQD
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMTIM/NSTART,NEND,NFREQD,TSPD,/OUTCON/RNTAPE,
**          /COMIOC/NCHIST
**    Com changed - /PHDIAG/LDPHTD,/XPDIAG/LDXPTD
**    Params used - /PARAM3/JPPHMX,JPXPMX
**    Called by - DINIT
**    Calls - RCHECK
**    Files read - NCHIST
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      DIMENSION ITIMES(10)

**    If time-averages have been requested and accumulated history
**    variables are to be read in, check that NFREQD equals the
**    time-interval between history writes; if not then incorrect
**    values will be assigned to these averages. 10 history records
**    (at different times) are examined.
      IF(LDPHTD.OR.LDXPTD) THEN
         ISTEP=NSTART-NFREQD
         DO 300 JTIM=1,10
         ISTEP=ISTEP+NFREQD
         CALL RCHECK(NCHIST,RNTAPE,ISTEP,TSPD)
         READ(NCHIST)ZKOUNT,ZMTAPE,ZDAY
         ITIMES(JTIM)=NINT(ZDAY*TSPD)
         IF(ISTEP.EQ.NEND) THEN
            IELEM=JTIM
            GO TO 310
         ENDIF
300      CONTINUE
         IELEM=10
310      CONTINUE
         IF(IELEM.EQ.1) THEN
            WRITE(6,6000)
6000        FORMAT(1X,'CHKSTP: UNABLE TO CHECK IF USER HAS SUPPLIED ',
     -            'A SUITABLE VALUE FOR NFREQD')
         ELSE
            IDIFF=ITIMES(2)-ITIMES(1)
            IDMAX=IDIFF
            IDMIN=IDIFF
            IF(IELEM.GT.2) THEN
               DO 311 J=2,IELEM-1
               IDIFF=ITIMES(J+1)-ITIMES(J)
               IDMAX=MAX0(IDIFF,IDMAX)
               IDMIN=MAX0(IDIFF,IDMIN)
311            CONTINUE
            ENDIF
            IF((IDMAX.NE.IDMIN).OR.(IDMAX.NE.NFREQD)) THEN
               WRITE(6,6005) IDMAX,IDMIN,NFREQD
6005           FORMAT(1X,'CHKSTP: NFREQD DOES NOT MATCH HISTORY ',
     -            'INTERVAL'
     -            /' HISTORY INTERVALS RANGE FROM ',I10,' TO ',I10
     -            /' NFREQD DEFINED TO BE ',I10,/' AS A RESULT ',
     -            'SOME PH/XP TIME AVERAGES WILL BE INCORRECT')
               LDPHTD=.FALSE.
               LDXPTD=.FALSE.
            ENDIF
         ENDIF
         REWIND NCHIST
      ENDIF

      RETURN
      END
      SUBROUTINE CHKTF(KERR)
**    Function - to check TF data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/BEGDAY,ENDDAY,YTYPSF,NFREQD,
**          /TFDIAG/NVTFHR,VTFSFC,TFCUT,FACTTF,NTF,
**          /COMTIM/TSPD,/COMTRV/LGCMTR,/LVDIAG/OUTLEV
**    Com changed - /DIAGTP/LDTF,/TFDIAG/NFLDTF
**    Params used - JPALOW,/PARAM1/JPNL,/PARAM3/JPTRMX,JPSGMX,JPTFMX
**    Called by - DATCHK
**    Calls - CHKVAL,CHKFH,CHKFZ,CHKFM,CHKFP,CHKF3
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      PARAMETER(JPALOW=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LOVALU,LOEQN(JPTRMX),LOCODE
      DIMENSION ITFFLD(0:JPALOW)

**    Switch off transient flux calculations if
**    ENDDAY is not greater than BEGDAY
      IF(ENDDAY.LE.BEGDAY) THEN
         WRITE(6,6100)
6100     FORMAT(1X,'CHKTF: TF CALCULATIONS SWITCHED OFF, SINCE ',
     -         'ENDDAY.LE.BEGDAY')
         LDTF=.FALSE.
      ENDIF

**    Switch off transient fluxes if no output requested.
      IF((.NOT.LTFTOT).AND.(.NOT.LTFHP).AND.(.NOT.LTFLP)) THEN
         WRITE(6,6105)
6105     FORMAT(1X,'CHKTF: TOTAL, HIGH- AND LOW-PASS COMPONENTS ',
     -         'NOT REQUESTED; TF CALCULATIONS TURNED OFF')
         LDTF=.FALSE.
      ENDIF

**    Ensure that TFCUT is not less than NFREQD/TSPD
      ZTFCUT=FLOAT(NFREQD)/TSPD
      IF((TFCUT-ZTFCUT).LT.-1E-5) THEN
C         NWARN=NWARN+1
         WRITE(6,6107)
6107     FORMAT(1X,'CHKTF: TF CALCULATIONS SWITCHED OFF, SINCE ',
     -         'TFCUT.LE.NFREQD/TSPD')
         LDTF=.FALSE.
         RETURN
      ENDIF

**    ISMP = no. of samples, ISMPLO = samples in each low pass,
**    ISMPHI = no. of high pass samples
      ISMP=NINT((ENDDAY-BEGDAY)*TSPD)/NFREQD+1
      ISMPLO=NINT(TFCUT*TSPD)/NFREQD
      ISMPHI=ISMP/ISMPLO
      ZEND=BEGDAY+FLOAT((ISMPHI*ISMPLO-1)*NFREQD)/TSPD
      ZTFCUT=FLOAT(ISMPLO)*FLOAT(NFREQD)/TSPD

      IF(ISMP.LT.2) THEN
         WRITE(6,6110)ISMP
6110     FORMAT(1X,'CHKTF ERROR: ONLY ',I5,' SAMPLES REQUESTED ',
     -         'FOR TRANSIENT FLUX CALCULATIONS')
         LDTF=.FALSE.
      ENDIF
      IF(ISMPLO.LT.1) THEN
         WRITE(6,6120)ISMPLO
6120     FORMAT(1X,'CHKTF ERROR: ',I5,' SAMPLES REQUESTED ',
     -         'FOR LOW-PASS TRANSIENT FLUX CALCULATIONS')
         LDTF=.FALSE.
      ENDIF
      IF(ISMPHI.LT.1) THEN
         WRITE(6,6130)ISMPHI
6130     FORMAT(1X,'CHKTF ERROR: ',I5,' SAMPLES REQUESTED ',
     -         'FOR HIGH-PASS TRANSIENT FLUX CALCULATIONS')
         LDTF=.FALSE.
      ENDIF
      IF(ABS(ZEND-ENDDAY).GT.1.0E-3) THEN
         WRITE(6,6140)
6140     FORMAT(1X,'CHKTF: DIAGNOSTIC PERIOD MUST BE A MULTIPLE OF ',
     -         'LOW PASS AVERAGING PERIOD'/
     -         '  TRANSIENT FLUXES SWITCHED OFF')
         LDTF=.FALSE.
      ENDIF
      IF(ABS(ZTFCUT-TFCUT).GT.1.0E-3) THEN
         WRITE(6,6150)
6150     FORMAT(1X,'CHKTF: TFCUT NOT COMPATIBLE WITH TIMESTEP ',
     -         'AND NFREQD'/
     -         '  TRANSIENT FLUXES SWITCHED OFF')
         LDTF=.FALSE.
      ENDIF

**    Switch off diagnostics if NTF is zero or too large
      IF(NTF.LE.0.AND.LDTF) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKTF: TF DIAGNOSTICS SWITCHED OFF, NTF<=0')
         LDTF=.FALSE.
         RETURN
      ENDIF
      IF(NTF.GT.JPTFMX.AND.LDTF) THEN
         PRINT 6036
6036     FORMAT(1X,'CHKTF: TF DIAGNOSTICS SWITCHED OFF, NTF TOO LARGE')
         LDTF=.FALSE.
         RETURN
      ENDIF

      IF(.NOT.LDTF) RETURN

**    NVTFHR values only used when output is on model surfaces, and
**    VTFSFC values only used when output is on non-model surfaces
      IF((NVTFHR(1).NE.0).AND.(YTYPSF.NE.'ET')) THEN
         PRINT 6060
6060     FORMAT(1X,'CHKTF: NVTFHR VALUE(S) SUPPLIED, BUT NOT USED')
      ENDIF
      IF((NVTFHR(1).LE.0).AND.(YTYPSF.EQ.'ET')) THEN
         PRINT 6065
6065     FORMAT(1X,'CHKTF: NVTFHR VALUES NOT SUPPLIED,'
     -         ' OUTPUT MAY BE SUPPRESSED')
      ENDIF
      IF((VTFSFC(1).GT.0.0).AND.(YTYPSF.EQ.'ET')) THEN
         PRINT 6070
6070     FORMAT(1X,'CHKTF: VTFSFC VALUE(S) SUPPLIED, BUT NOT USED')
      ENDIF
      IF((VTFSFC(1).LE.0.0).AND.(YTYPSF.NE.'ET')) THEN
         PRINT 6075
6075     FORMAT(1X,'CHKTF: VTFSFC VALUES NOT SUPPLIED,'
     -         ' OUTPUT MAY BE SUPPRESSED')
      ENDIF

**    Check that VTFSFC values are a subset of OUTLEV values if they are
**    to be used. ZDELTA is a small parameter to allow two REAL values
**    to be compared
      ZDELTA=1.0E-3
      IF(YTYPSF.NE.'ET') THEN
         DO 4000 K=1,JPNL
         IF(VTFSFC(K).GT.0.0) THEN
            ZSFCP=VTFSFC(K)+ZDELTA
            ZSFCM=VTFSFC(K)-ZDELTA
            LOVALU=.FALSE.
            DO 4100 J=1,JPNL
            IF(ZSFCM.LE.OUTLEV(J).AND.ZSFCP.GE.OUTLEV(J)) LOVALU=.TRUE.
4100        CONTINUE
            IF(.NOT.LOVALU) THEN
               PRINT 6080,VTFSFC(K)
6080           FORMAT(1X,'CHKTF: VTFSFC CORRESPONDS TO INVALID LEVEL ',
     -               F12.3)
            ENDIF
         ENDIF
4000     CONTINUE
      ENDIF

**    Check that NVTFHR values lie in the range 1 to JPNL
      IF(YTYPSF.EQ.'ET') THEN
         DO 5000 J=1,JPNL
         IF(NVTFHR(J).NE.0) THEN
            IF(NVTFHR(J).LT.1.OR.NVTFHR(J).GT.JPNL) THEN
               PRINT 6090
6090           FORMAT(1X,'CHKTF: INVALID NVTFHR VALUE')
               KERR=999
            ENDIF
         ENDIF
5000     CONTINUE
      ENDIF

**    Permissible field codes are 1->14, 17->19 and
**          101->100+JPTRMX (the latter only if tracer code was used
**          in the original GCM run). A value of 0 can be used to
**          signify a null field.
      ITFFLD(0)=0
      DO 100 J=1,JPALOW
      IF(J.LE.JPSGMX) THEN
         ITFFLD(J)=J
      ELSE IF(LGCMTR) THEN
         ITFFLD(J)=100+J-JPSGMX
      ELSE
         ITFFLD(J)=0
      ENDIF
      IF((J.EQ.15).OR.(J.EQ.16).OR.(J.EQ.20).OR.(J.EQ.21)) ITFFLD(J)=0
100   CONTINUE

**    Now check each formula in turn, and determine its validity
      DO 200 J=1,JPTFMX
      LOEQN(J)=.TRUE.
**    First multiplicative factor
      IF((ABS(FACTTF(1,J)).LT.1.0E-3).AND.((NFLDTF(1,J).NE.0).OR.
     -      (NFLDTF(2,J).NE.0))) THEN
         WRITE(6,6200) J
6200     FORMAT(1X,'CHKTF ERROR: FIRST FACTOR OF EQN ',I2,' IS ZERO')
         KERR=999
         LOEQN(J)=.FALSE.
         NFLDTF(1,J)=0
         NFLDTF(2,J)=0
      ENDIF
**    Second multiplicative factor
      IF((ABS(FACTTF(2,J)).LT.1.0E-3).AND.((NFLDTF(3,J).NE.0).OR.
     -      (NFLDTF(4,J).NE.0))) THEN
         WRITE(6,6210) J
6210     FORMAT(1X,'CHKTF ERROR: SECOND FACTOR OF EQN ',I2,' IS ZERO')
         KERR=999
         LOEQN(J)=.FALSE.
         NFLDTF(3,J)=0
         NFLDTF(4,J)=0
      ENDIF
**    If both factors are zero, equation is invalid
      IF(ABS(FACTTF(1,J)).LT.1.0E-3.AND.
     -      ABS(FACTTF(2,J)).LT.1.0E-3) THEN
         LOEQN(J)=.FALSE.
         GO TO 200
      ENDIF
**    Check each field code
      CALL CHKVAL(LOCODE,NFLDTF(1,J),4,ITFFLD(0),JPALOW+1)
      IF(.NOT.LOCODE) THEN
         WRITE(6,6220)J,NFLDTF(1,J),NFLDTF(2,J),NFLDTF(3,J),NFLDTF(4,J)
6220     FORMAT(1X,'CHKTF ERROR: EQN ',I2,' INVALID FIELD CODE ',
     -         /'ONE OF THE FOLLOWING IS INCORRECT ',4I5)
         KERR=999
         NFLDTF(1,J)=0
         NFLDTF(2,J)=0
         NFLDTF(3,J)=0
         NFLDTF(4,J)=0
         LOEQN(J)=.FALSE.
      ENDIF
200   CONTINUE
**    Finally, check validity of first NTF equations
      IVALID=0
      DO 300 J=1,NTF
      IF(LOEQN(J)) IVALID=IVALID+1
300   CONTINUE
      IF(NTF.NE.IVALID) THEN
         WRITE(6,6300)
6300     FORMAT(1X,'CHKTF ERROR: EITHER NTF IS WRONG, OR ONE OF THE ',
     -         'FIRST NTF EQNS IS INVALID')
         KERR=999
      ENDIF

      IF(LDTF) THEN
         CALL CHKFH(KERR)
         CALL CHKFZ(KERR)
         CALL CHKFM(KERR)
         CALL CHKFP(KERR)
         CALL CHKF3(KERR)
      ENDIF

      LOVALU=(LDFH.OR.LDFZ.OR.LDFM.OR.LDFP.OR.LDF3).AND.LDTF
      IF(.NOT.LOVALU) THEN
         PRINT 6400
6400     FORMAT(1X,'CHKTF: WARNING -- TF DIAGNOSTICS SWITCHED OFF')
         LDTF=.FALSE.
         KERR=999
      ENDIF

      RETURN
      END
      SUBROUTINE CHKVAL(LPCODE,KFIELD,KDIM1,KALLOW,KDIM2)
**    Function - to check the values in one array against the values
**          in another, and return a flag indicating if the first
**          is a subset of the second.
**    Args in -
**               KFIELD  - Array of values to be checked
**               KDIM1   - Number of values to be checked
**               KALLOW  - Array of permissible values
**               KDIM2   - Number of permissible values
**    Args out -
**               LPCODE  - .TRUE. if values in array KFIELD are a
**                         subset of those in KALLOW
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - CHKTF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      LOGICAL LPCODE,LOVALU
      DIMENSION KFIELD(KDIM1),KALLOW(KDIM2)

      LPCODE=.TRUE.
      DO 100 J=1,KDIM1
      LOVALU=.FALSE.
      DO 200 JC=1,KDIM2
      IF(KFIELD(J).EQ.KALLOW(JC)) LOVALU=.TRUE.
200   CONTINUE
      IF(.NOT.LOVALU) THEN
         LPCODE=.FALSE.
         RETURN
      ENDIF
100   CONTINUE

      RETURN
      END
      SUBROUTINE CHKXP(KERR)
**    Function - to check XP data input
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**    Args out -
**               KERR    - Error flag
**    Args for work - none
**    Com used - /COMDAT/LWRITE,LASCII,BEGDAY,ENDDAY,
**          /XPDIAG/NXPPR,NXPPL,NXP,/MODELC/LHISXP
**    Com changed - /XPDIAG/LDXPTS,LDPHTD,/XPDIAG/NXPPR,NXPPL,NXP,
**          /DIAGTP/LDXP
**    Params used - /PARAM1/JPNL,/PARAM3/JPXPMX
**    Called by - DATCHK
**    Calls - NONE
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      DIMENSION IXPFLD(JPXPMX)
      LOGICAL LOVALU

**    IXPFLD - allowed XP field codes
      DO 100 J=1,JPXPMX
      IXPFLD(J)=J
100   CONTINUE

      IF(LDXP.AND..NOT.LHISXP) THEN
         PRINT 6500
6500     FORMAT(1X,'CHKXP: XP HISTORY DATA DOES NOT EXIST; XP ',
     -         'DIAGNOSTICS TURNED OFF')
         LDXP=.FALSE.
         RETURN
      ENDIF

**    Check if printing has been requested
      IF(.NOT.LWRITE) THEN
         IF(NXPPR(1).NE.0) THEN
            PRINT 6000
6000        FORMAT(1X,'CHKXP: NXPPR NON ZERO, BUT NO PRINTING SETUP')
            DO 1000 K=1,JPXPMX
1000        NXPPR(K)=0
**          Reset value of NXP
            NXP=0
            DO 1001 J=1,JPXPMX
            IF(NXPPL(J).GT.0) NXP=NXP+1
1001        CONTINUE
         ENDIF
      ENDIF

**    Check if UTFs are requested
      IF(.NOT.LASCII) THEN
         IF(NXPPL(1).NE.0) THEN
            PRINT 6010
6010        FORMAT(1X,'CHKXP: NXPPL NON ZERO, BUT NO PLOTTING SETUP')
            DO 1100 K=1,JPXPMX
1100        NXPPL(K)=0
**          Reset value of NXP
            NXP=0
            DO 1101 J=1,JPXPMX
            IF(NXPPR(J).GT.0) NXP=NXP+1
1101        CONTINUE
         ENDIF
      ENDIF

**    Check valid code numbers in NXPPR
      IF(NXPPR(1).NE.0) THEN
         DO 2000 K=1,JPXPMX
         LOVALU=.FALSE.
         DO 2100 J=1,JPXPMX
         IF((NXPPR(K).EQ.IXPFLD(J)).OR.(NXPPR(K).EQ.0)) LOVALU=.TRUE.
2100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6020
6020        FORMAT(1X,'CHKXP: ERROR IN NXPPR VALUES')
         ENDIF
2000     CONTINUE
      ENDIF

**    Check valid code numbers in NXPPL
      IF(NXPPL(1).NE.0) THEN
         DO 3000 K=1,JPXPMX
         LOVALU=.FALSE.
         DO 3100 J=1,JPXPMX
         IF((NXPPL(K).EQ.IXPFLD(J)).OR.(NXPPL(K).EQ.0)) LOVALU=.TRUE.
3100     CONTINUE
         IF(.NOT.LOVALU) THEN
            KERR=999
            PRINT 6030
6030        FORMAT(1X,'CHKXP: ERROR IN NXPPL VALUES')
         ENDIF
3000     CONTINUE
      ENDIF

**    Switch of diagnostics if NXP is zero
      IF(NXP.EQ.0.AND.LDXP) THEN
         PRINT 6035
6035     FORMAT(1X,'CHKXP: XP DIAGNOSTICS SWITCHED OFF, NXP=0')
         LDXP=.FALSE.
         RETURN
      ENDIF
      IF(.NOT.LDXP) RETURN

**    Time series output not produced unless averages on model levels
**    requested
      IF(LDXPTS.AND.(.NOT.LDXPLM)) THEN
         PRINT 6050
6050     FORMAT(1X,'CHKXP: XP TIME SERIES SWITCHED OFF SINCE LEVEL ',
     -         'AVERAGES NOT REQUESTED')
         LDXPTS=.FALSE.
      ENDIF

**    Switch off time-series and time-averaging calculations if
**    ENDDAY is not greater than BEGDAY
      IF(ENDDAY.LE.BEGDAY) THEN
         IF(LDXPTS) THEN
            WRITE(6,6100)
6100        FORMAT(1X,'CHKXP: XP TIME-SERIES SWITCHED OFF, SINCE ',
     -            'ENDDAY.LE.BEGDAY')
            LDXPTS=.FALSE.
         ENDIF
         IF(LDXPTD) THEN
            WRITE(6,6110)
6110        FORMAT(1X,'CHKXP: XP TIME-AVERAGES (D) SWITCHED OFF,',
     -            ' SINCE ENDDAY.LE.BEGDAY')
            LDXPTD=.FALSE.
         ENDIF
      ENDIF
**    Check value of NXP
      IF((NXP.LE.0).OR.(NXP.GT.JPXPMX)) THEN
         KERR=999
         PRINT 6040,NXP
6040     FORMAT(1X,'CHKXP: INVALID VALUE FOR NXP : ',I5)
      ENDIF

**    Switch off diagnostics if no time-control selected
      IF((.NOT.LDXPTS).AND.(.NOT.LDXPTD).AND.(.NOT.LDXPIN)) THEN
         PRINT 6150
6150     FORMAT(1X,'CHKXP: NO TIME CONTROLS FOR XP DIAGNOSTICS ',
     -      ': XP DIAGNOSTICS SWITCHED OFF')
         LDXP=.FALSE.
      ENDIF

      RETURN
      END
      SUBROUTINE DATCHK
**    Function - to check the namelist data supplied by the
**          preprocessor and/or user.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMPTH/all elements,/COMDAT/BEGDAY,ENDDAY,LWRITE,
**          LASCII,LUTF14,NSIGFG,YTYPSF,NFREQD,NFREQP,NFREQA,
**          /DIAGTP/LDPH,LDCO,LDTF,LDSG,LDOD,LDZF,LDTJ,
**          /INIDAT
**          /all elements,/COMTIM/TSPD,/COMAVG/LMASSW,LAVMSK,LAVSIG
**    Com changed - /COMDAT/NSIGFG,NASCII,/DIAGTP/LDXP,LDPH,LDTR
**    Params used - JPNSFC(No. of different surface types available for
**          use)
**    Called by - MAINBF
**    Calls - CHKPH,ABORT,CHKXP,CHKLV,CHKOR,CHKCO,CHKSG,AVGCHK,
**          CHKTR,CHKTF,CHKOD,CHKZF,CHKTJ
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNSFC=3)
      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      CHARACTER*80 YCPTHT,YCPTHH,YCPTHC
      COMMON /COMPTH/YCPTHT,YCPTHH,YCPTHC
      COMMON /IPATHL/NLENTD,NLENHD,NLENCD
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMMON /INIDAT/NYEAR,NDAY,NMIN
      LOGICAL LOSFC
      CHARACTER*20 YOBLAN
      CHARACTER*2 YOCSFC(JPNSFC)
      CHARACTER*80 YOBLNK
      DATA YOCSFC/'ET','IS','TH'/

**    IERR - error flag, a value of 999 will cause the program to fail
      IERR=0

**    Path variables should not be empty
      YOBLAN='                    '
      YOBLNK=YOBLAN//YOBLAN//YOBLAN//YOBLAN
      IF((YCPTHT.EQ.YOBLNK).OR.(YCPTHH.EQ.YOBLNK)
     -      .OR.(YCPTHC.EQ.YOBLNK))THEN
         PRINT 6010
6010     FORMAT(1X,'DATCHK: ONE OF THE PATH VARIABLES HAS NOT BEEN SET')
         IERR=999
      ENDIF

**    Check for possible errors in BEGDAY and ENDDAY
      IF(BEGDAY.LT.0.0.OR.(ENDDAY.LT.0.0)) THEN
         PRINT 6020
6020     FORMAT(1X,'DATCHK: ONE OR BOTH OF BEGDAY AND ENDDAY NOT SET')
         IERR=999
      ENDIF
      IF(ENDDAY.LT.BEGDAY) THEN
         PRINT 6030
6030     FORMAT(1X,'DATCHK: BEGDAY .LT. ENDDAY')
         IERR=999
      ENDIF

**    Check that one or both of LWRITE and LASCII has been set to .TRUE.
      IF((.NOT.LWRITE).AND.(.NOT.LASCII)) THEN
         PRINT 6040
6040     FORMAT(1X,'DATCHK: NO OUTPUT REQUESTED')
         IERR=999
      ENDIF

**    If LASCII is .TRUE., ensure that LUTF14 is set
**    to .TRUE.
      IF(LASCII) THEN
         IF(.NOT.LUTF14)THEN
            PRINT 6060
6060        FORMAT(1X,'DATCHK: LASCII = .TRUE., AND NO UTF VERSION',
     -            ' REQUESTED')
            IERR=999
         ENDIF
      ENDIF

**    Check that NASCII is non-zero
      IF(NASCII.EQ.0) THEN
         PRINT 6065
6065     FORMAT(1X,'NASCII CANNOT BE ZERO - RESET TO 2')
         NASCII=2
      ENDIF

**    Check that NSIGFG is one of 2, 3, 4 or 5
      IF(NSIGFG.LT.2) THEN
         PRINT 6080
6080     FORMAT(1X,'DATCHK: NSIGFG TOO SMALL - RESET TO 2')
         NSIGFG=2
      ELSE IF(NSIGFG.GT.5) THEN
         PRINT 6090
6090     FORMAT(1X,'DATCHK: NSIGFG TOO LARGE - RESET TO 5')
         NSIGFG=5
      ENDIF

**    Check that YTYPSF has been correctly set
      LOSFC=.FALSE.
      DO 100 J=1,JPNSFC
      IF(YTYPSF.EQ.YOCSFC(J)) LOSFC=.TRUE.
100   CONTINUE
      IF(.NOT.LOSFC) THEN
         PRINT 6100
6100     FORMAT(1X,'DATCHK: YTYPSF INCORRECTLY SET')
         IERR=999
      ENDIF

**    Check values of NFREQD, NFREQP, NFREQA
      IF(NFREQD.LE.0) THEN
         PRINT 6120
6120     FORMAT(1X,'DATCHK: NFREQD IS NOT > 0')
         IERR=999
      ENDIF
      IF(LWRITE.AND.(NFREQP.LE.0)) THEN
         PRINT 6140
6140     FORMAT(1X,'DATCHK: NFREQP MUST NOT BE 0 FOR PRINTOUT')
         IERR=999
      ENDIF
      IF(LASCII.AND.(NFREQA.LE.0)) THEN
         PRINT 6160
6160     FORMAT(1X,'DATCHK: NFREQA MUST NOT BE 0 FOR UTF OUTPUT')
         IERR=999
      ENDIF
      IF(NFREQD.GT.0) THEN
**       NFREQP and NFREQA must be an exact multiple of NFREQD
         IF(LWRITE.AND.(NFREQP.NE.NFREQD*(NFREQP/NFREQD))) THEN
            PRINT 6180
6180        FORMAT(1X,'DATCHK: NFREQP NOT A MULTIPLE OF NFREQD')
            IERR=999
         ENDIF
         IF(LASCII.AND.(NFREQA.NE.NFREQD*(NFREQA/NFREQD))) THEN
            PRINT 6200
6200        FORMAT(1X,'DATCHK: NFREQA NOT A MULTIPLE OF NFREQD')
            IERR=999
         ENDIF
      ENDIF

**    Check that TSPD > 0
      IF(TSPD.LE.0.0) THEN
         PRINT 6220
6220     FORMAT(1X,'DATCHK: TSPD <= 0.0')
         IERR=999
      ENDIF

**    Check validity of NYEAR, NDAY and NMIN
      IMM=NYEAR-(NYEAR/100)*100
      IF((IMM.LT.1).OR.(IMM.GT.12)) THEN
         PRINT 6330,IMM
6330     FORMAT(1X,'***WARNING : ',
     -         '      MONTH OF YEAR IS ',I5)
      ENDIF
      IDD=NDAY/100
      IHH=NDAY-(NDAY/100)*100
      IF((IDD.LT.1).OR.(IDD.GT.31)) THEN
         PRINT 6340,IDD
6340     FORMAT(1X,'***WARNING : ',
     -         '      DAY OF MONTH IS ',I5)
      ENDIF
      IF((IHH.LT.0).OR.(IHH.GT.24)) THEN
         PRINT 6350,IHH
6350     FORMAT(1X,'***WARNING : ',
     -         '      HOUR OF DAY IS ',I5)
      ENDIF
      IF((NMIN.LT.0).OR.(IMM.GT.59)) THEN
         PRINT 6360,NMIN
6360     FORMAT(1X,'***WARNING : ',
     -         '      MINUTE TIME IS ',I5)
      ENDIF
      IF((IMM.EQ.2.AND.IDD.GT.29).OR.(IMM.EQ.4.AND.IDD.GT.30)
     -      .OR.(IMM.EQ.6.AND.IDD.GT.30).OR.(IMM.EQ.9.AND.IDD.GT.30)
     -      .OR.(IMM.EQ.11.AND.IDD.GT.30)) THEN
         PRINT 6370,IMM,IDD
6370     FORMAT(1X,'***WARNING*** : ',
     -         '      MONTH AND DATE INCOMPATIBLE - ',2I5)
      ENDIF

CC**    Ensure XP diagnostics only with 'ET' surfaces
CC      IF(YTYPSF.NE.'ET'.AND.LDXP) THEN
CC         PRINT 6300,YTYPSF
CC6300     FORMAT(1X,'DATCHK: SURFACE TYPE NOT ET - XP DIAGNOSTICS',
CC     -         ' SWITCHED OFF')
CC         LDXP=.FALSE.
CC      ENDIF

      CALL AVGCHK(LMASSW,LAVMSK,LAVSIG,YTYPSF,IERR)

CC    Temporary code until routines have been checked
      LDTR=.FALSE.
      LDOD=.FALSE.
      LDZF=.FALSE.
      LDTJ=.FALSE.
CC    End of temporary code

      IF(LDPH) CALL CHKPH(IERR)
      IF(LDXP) CALL CHKXP(IERR)

      CALL CHKLV(IERR)
      CALL CHKOR(IERR)

      IF(LDCO) CALL CHKCO(IERR)
      IF(LDSG) CALL CHKSG(IERR)
      IF(LDTF) CALL CHKTF(IERR)
      IF(IERR.EQ.999) CALL ABORT

      RETURN
      END
      SUBROUTINE LATCHK(PLAT,KDIM,PDEFLT,YPDIAG)
**    Function - to check validity of latitude values
**    Args in -
**               PLAT    - Latitude value(s)
**               KDIM    - Number of latitude values input
**               PDEFLT  - Default values to be used if input
**                         values are incorrect
**               YPDIAG  - Diagnostics for which latitudes are being
**                         checked
**    Args out -
**               PLAT    - Latitude value(s)
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNHEM
**    Called by - CHKPH,CHKGH,CHKGM,CHKGP,CHKTH,CHKTM,CHKTP
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      DIMENSION PLAT(KDIM)
      CHARACTER*(*) YPDIAG

      IF(JPNHEM.EQ.2) THEN
         ZLATMN=-90.0
      ELSE
         ZLATMN=0.0
      ENDIF

      IF(KDIM.EQ.1) THEN
         IF((PLAT(1).GT.90.0).OR.(PLAT(1).LT.ZLATMN)) THEN
            IF(PLAT(1).NE.PDEFLT) THEN
               PRINT 6000,YPDIAG,ZLATMN
6000           FORMAT(1X,'SOME E-W SLICES OF ',A,
     -               /' FIELDS SWITCHED OFF SINCE LATITUDE OUTSIDE ',
     -               ' RANGE ',F5.1,' -> 90.0')
               PLAT(1)=PDEFLT
            ENDIF
         ENDIF
      ELSE IF(KDIM.EQ.2) THEN
         IF((PLAT(1).LT.ZLATMN).OR.(PLAT(2).GT.90.0).OR.
     -         (PLAT(2).LT.ZLATMN).OR.(PLAT(1).GT.90.0).OR.
     -         (PLAT(1).GT.PLAT(2))) THEN
            IF((PLAT(1).NE.PDEFLT).OR.PLAT(2).NE.PDEFLT) THEN
               PRINT 6000,YPDIAG
               PLAT(1)=PDEFLT
               PLAT(2)=PDEFLT
            ENDIF
         ENDIF
         IF((PLAT(1).EQ.PDEFLT).OR.(PLAT(2).EQ.PDEFLT)) THEN
            PLAT(1)=PDEFLT
            PLAT(2)=PDEFLT
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE LNGCHK(PLONG,KDIM,PDEFLT,YPDIAG)
**    Function - to check validity of longitude values
**    Args in -
**               PLONG   - Longitude value(s)
**               KDIM    - Number of longitude values input
**               PDEFLT  - Default values to be used if input
**                         values are incorrect
**               YPDIAG  - Diagnostics for which longitudes are being
**                         checked
**    Args out -
**               PLONG   - Longitude value(s)
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPMOCT
**    Called by - CHKGP,CHKGZ,CHKPH,CHKTP,CHKTZ
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      DIMENSION PLONG(KDIM)
      CHARACTER*(*) YPDIAG

      ZLONMX=360.0/JPMOCT
      ZEPS=1.0E-3

      IF(KDIM.EQ.1) THEN
         IF((PLONG(1).GT.(ZLONMX+ZEPS)).OR.
     -         (PLONG(1).LT.(0.0-ZEPS))) THEN
            IF(PLONG(1).NE.PDEFLT) THEN
               PRINT 6000,YPDIAG
6000           FORMAT(1X,'SOME N-S SLICES OF ',A,
     -               /' FIELDS SWITCHED OFF SINCE LONGITUDES NOT IN ',
     -               'RANGE 0 -> 360.0/JPMOCT')
               PLONG(1)=PDEFLT
            ENDIF
         ENDIF
      ELSE IF(KDIM.EQ.2) THEN
         IF((PLONG(1).LT.(0.0-ZEPS)).OR.(PLONG(1).GT.
     -         (ZLONMX+ZEPS)).OR.
     -         (PLONG(2).LT.(0.0-ZEPS)).OR.(PLONG(2)
     -         .GT.(ZLONMX+ZEPS))) THEN
            IF((PLONG(1).NE.PDEFLT).OR.PLONG(2).NE.PDEFLT) THEN
               PRINT 6000,YPDIAG
               PLONG(1)=PDEFLT
               PLONG(2)=PDEFLT
            ENDIF
         ENDIF
         IF((PLONG(1).EQ.PDEFLT).OR.(PLONG(2).EQ.PDEFLT)) THEN
            PLONG(1)=PDEFLT
            PLONG(2)=PDEFLT
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE PARCHK
**    Function - to check the global parameters
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPJG,JPJGL,JPNN,JPMM,JPNHEM,JPMOCT,
**          JPMG,JPNWJ2,/PARAM2/JPMH,/SPECTR/ISPAD
**    Called by - MAINBF
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
**
**    **************************************************************
**    *      EXAMPLE PARAMETER VALUES REQUIRED BY THE PROGRAM      *
**    *                      (IF JPMOCT = 1)                       *
**    *                                                            *
**    *                 Trunc.   JPMG   JPJG   JPNWJ2              *
**    *                 ------   ----   ----   ------              *
**    *                 T10        32      8       30              *
**    *                 T21        64     16      121              *
**    *                 T31        96     24      256              *
**    *                 T42       128     32      462              *
**    *                 T63       192     48     1024              *
**    *                 T106      320     80     2862              *
**    *                 T213      640    160    11449              *
**    *                                                            *
**    *                           ISPAD                            *
**    *                           -----                            *
**    *                           Model Truncation                 *
**    *              JPNL     : T10->T63   T106   T213             *
**    *              ---------- --------  -----  -----             *
**    *              21->100  :     4800   2200   7200             *
**    *              16->20   :     2600   2800   8600             *
**    *              11->15   :     2600   3200  10000             *
**    *              9->10    :     2600   3400  10600             *
**    *              8        :     2600   3600  10800             *
**    *              7        :     2800   3600  11000             *
**    *              6        :     3600   6000  18800             *
**    *              5        :     5600  11800  42200             *
**    *              4        :     7400  17400  65800             *
**    *              3        :     9200  23200  89400             *
**    *                                                            *
**    * ISPAD values in the above table have been computed from    *
**    * JPIGD*JPJG - 2*(5*JPNL+1)*JPIGA, assuming                  *
**    *      JPNHEM lies in the range 1 -> 2                       *
**    *      that the truncation is one of those listed above      *
**    *      JPMOCT lies in the range 1 -> 20                      *
**    * They are used to pad out /SPECTR/. The values given above  *
**    * are upper limit values. The default value (of 9200) may    *
**    * only need changing if the model data is for a truncation   *
**    * higher than T63 or if the contents of /SPECTR/ are altered.*
********************************************************************
**

      IERR=0

**    Check value of JPJGL
      IF(JPJGL.NE.1.AND.JPJGL.NE.JPJG) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'PARCHK: JPJGL MUST BE EITHER 1 OR JPJG')
         IERR=999
      ENDIF

**    Check value of JPNHEM
      INHEM=JPNHEM
      IF(JPNHEM.NE.1.AND.JPNHEM.NE.2) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'PARCHK: JPNHEM MUST BE EITHER 1 OR 2')
         INHEM=2
         IERR=999
      ENDIF

**    Check value of JPMG
      IMG=(3*JPMM+1)/JPMOCT
10    CONTINUE
      IF(MOD(IMG,2).NE.0) THEN
         IMG=IMG+1
         GO TO 10
      ENDIF
      DO 101 JP=1,8
      DO 201 JQ=0,8
      DO 301 JR=0,8
      I=(2**JP)*(3**JQ)*(5**JR)
      IF(IMG.EQ.I) GO TO 20
301   CONTINUE
201   CONTINUE
101   CONTINUE
      IF(IMG.NE.I) THEN
         IMG=IMG+1
         GO TO 10
      ENDIF
20    CONTINUE
      IF(IMG.NE.JPMG) THEN
         WRITE(6,6020)IMG
6020     FORMAT(1X,'PARCHK: IS JPMG VALID?; TRY USING A VALUE OF',
     -         I6)
C         IERR=999
      ENDIF

**    Check value of JPJG
      IJG=(3*JPNN+1)
410   CONTINUE
      IF(MOD(IJG,2).NE.0) THEN
         IJG=IJG+1
         GO TO 410
      ENDIF
      DO 500 JP=1,8
      DO 600 JQ=0,8
      DO 700 JR=0,8
      I=(2**JP)*(3**JQ)*(5**JR)
      IF(IJG.EQ.I) GO TO 420
700   CONTINUE
600   CONTINUE
500   CONTINUE
      IF(IJG.NE.I) THEN
         IJG=IJG+1
         GO TO 410
      ENDIF
420   CONTINUE
      IJG=IJG/4
      IF(IJG.NE.JPJG) THEN
         WRITE(6,6025)IJG
6025     FORMAT(1X,'PARCHK: IS JPJG VALID?; TRY USING A VALUE OF',
     -         I6)
C         IERR=999
      ENDIF

      INWJC=0
      DO 100 JMP=1,JPMM,JPMOCT
      DO 100 JP=JMP,JPNN,JPMH
      INWJC=INWJC+1
100   CONTINUE
      IF(INWJC.NE.JPNWJ2) THEN
         WRITE(6,6030)JPNWJ2,INWJC
6030     FORMAT(1X,'PARCHK: ERROR - JPNWJ2 IS ',I6,' AND SHOULD BE ',I6)
         IERR=999
      ENDIF

**    If /SPECTR/ is changed, then ISPAD and IPAD may need
**    redefining.
      IPAD=INHEM*(IMG+2)*(JPNL+1)*IJG - 2*(5*JPNL+1)*INHEM*INWJC
      IF(ISPAD.LT.IPAD) THEN
         WRITE(6,6060) ISPAD,IPAD
6060     FORMAT(1X,'PARCHK: ERROR - ISPAD IS ',I7,' AND SHOULD BE ',I6)
         IERR=999
      ENDIF

      IF(IERR.EQ.999) THEN
         WRITE(6,6100)
6100     FORMAT(1X,'PARCHK: ABORT DUE TO ERRORS')
         CALL ABORT
      ENDIF

      RETURN
      END
      SUBROUTINE AVFLGS
**    Function - to define averaging flag(s)
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMAVG/LAVMSK,LAVSIG
**    Com changed - /COMAVG/NAVTYP
**    Params used - none
**    Called by - INIT
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      CHARACTER*25 YONAME

**    Use values of LAVSIG and LAVMSK to define type
**    of averaging performed in ZMEAN3, MERMN3 and TIMAVG.
**    LAVMSK is also used to define interpolation mask used
**    by routine AWIL

**    NAVTYP contains an integer value, used to compute an average
**    of points in an array X as follows:

**          NAVTYP=1, average = SUM(X(i)) / SUM(i data points)

**          NAVTYP=2, average = SUM(M(i).X(i)) / SUM(M(i))
**                where M(i) is the land/air mask (0 or 1) corresponding
**                to X(i)

**          NAVTYP=3, average = SUM(sigma(i).X(i)) / SUM(sigma(i))
**                where sigma(i) is the isentropic mass factor
**                corresponding to X(i)

**    It is assumed that routine AVGCHK has already been called.

      IF((.NOT.LAVMSK).AND.(.NOT.LAVSIG)) THEN
         NAVTYP=1
         YONAME='ARITHMETIC MEANS         '
      ELSE IF(LAVMSK.AND.(.NOT.LAVSIG)) THEN
         NAVTYP=2
         YONAME='LAND/AIR MASK-WEIGHTED   '
      ELSE IF((.NOT.LAVMSK).AND.LAVSIG) THEN
         NAVTYP=3
         YONAME='ISENTROPIC SIGMA-WEIGHTED'
      ELSE
         WRITE(6,6000)
6000     FORMAT(1X,'AVFLGS: ERROR - CANNOT DETERMINE AVERAGING TYPE')
         CALL ABORT
      ENDIF

      WRITE(6,6100)NAVTYP,YONAME
6100  FORMAT(/,1X,'***AVFLGS: AVERAGING SET UP IS TYPE ',I2,2X,A25)

      RETURN
      END
      SUBROUTINE CONST
**    Function - to define physical/model/mathematical constants
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - /INVAR/all elements,/COMMSK/AMSKV,AMSKVC
**    Params used - /PARAM1/JPMG,/PARAM2/JPJGG
**    Called by - MAINBF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD

      GPI=ATAN2(0.0,-1.0)
      PI2=GPI*2.0
      REFP0=100000.0
      GA=9.81
      RD=287.0
      RV=461.51
      AKAP=0.286
      CPD=RD/AKAP
      CPV=1869.46
      CLATNT=2.5E6
      WROTAT=7.292E-5
      RADEA=6371000.0
      CV=RADEA*WROTAT
      CG=CV*CV
      CT=CG/RD
      CTKAP=CT**(-1.0/AKAP)
      CTT=PI2*CT

**    BLVAD is the constant velocity offset applied in the boundary
**    layer scheme (m/s)
      BLVAD=3.0

**    EZ converts relative vorticity to vorticity in spectral space
      EZ=WROTAT/SQRT(0.375)

**    Masking values
C*****hack:limit on exponent for single prec ifc
C     AMSKV=999.0E50
      AMSKV=999.0E35
      AMSKVC=1.0E35

**    Chemical constants
      AMWAIR=28.966
      AVOGAD=6.022E23
**    1 Dobson unit = 1.0E-5 metres at STP; multiplying by DOBFAC
**    converts from molecules/cm**2 to Dobson units.
      DOBFAC=(22400.0*0.01*100000.0)/AVOGAD

      RETURN
      END
      SUBROUTINE DINIT
**    Function - To control the initialisation of code for the
**          individual diagnostic types. This initialisation includes
**          error checking, constant-setting and any other processes
**          to be carried out before the analysis time loop.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,
**          /COMTRV/LTREXS,LGCMTR,/COMTIM/NFREQD,TSPD,/COMDAT/BEGDAY
**    Com changed - /DIAGTP/LDTR,/COMFLG/LGETTR,/TRDIAG/LDTH,LDTM,
**          LDTZ,LDTP,LDT3,/TFDIAG/LDFH,LDFM,LDFZ,LDFP,LDF3,
**          /DIAGTP/LDZF,LDTJ,/COMTIM/NFRACC,
**          /XPDIAG/LDXPTO,LDXPTD,/PHDIAG/LDPHTD
**    Params used - /PARAM1/JPNL,/PARAM3/JPTFMX,JPZFMX
**    Called by - MAINBF
**    Calls - PHINIT,XPINIT,COINIT,SGINIT,ITRACR,TRINIT,
**          SPCFLG,TFINIT,ODINIT,ZFINIT,TJINIT,CHKSTP
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,LQFLG
      COMMON /COMFLG/LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,
     -      LQFLG
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN
      COMMON /TRDIAG/LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN,
     -      NCTR,NVTRHR(JPNL),VTRSFC(JPNL)
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      LOGICAL LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      COMMON /ZFDIAG/NCZF,NZFPR(JPZFMX),NZFPL(JPZFMX),
     -      CINTZF(JPZFMX),NVZFHR(JPNL),
     -      NZF,FACTZF(2,JPZFMX),NFLDZF(4,JPZFMX),VZFSFC(JPNL),
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      LOGICAL LOTFTR,LOZFTR,LOTJTR

**    Note that the LDXX variables may be changed to .FALSE. by
**          error checking code in the routines called below


      IF(LDPH.OR.LDXP) THEN
**       The following value of NFRACC supposes that the
**       accumulated PH and XP fields are never reset to zero.
         NFRACC=1
         CALL CHKSTP
      ENDIF

**    Initialisation of the Uninterpolated lat-long fields
      IF(LDPH) CALL PHINIT(LDPH)

**    Initialisation of the Zonal mean parameterisation tendencies
      IF(LDXP) CALL XPINIT(LDXP)

**    Initialisation of the Spectral coefficicient output diagnostics
      IF(LDCO) CALL COINIT(LDCO)

**    Initialisation of the 3-D gridpoint output diagnostics
      IF(LDSG) CALL SGINIT(LDSG)

**    Determine if spectral coefficients need to be retrieved
      CALL SPCFLG(LOTFTR,LOZFTR,LOTJTR)

**    If tracers are expected, check that they exist, and allocate space
**    so that they can be read into the program (the latter only if they
**    are going to be used)
CC    THE FOLLOWING IS A QUICK FIX FOR SMAP UNTIL TRACERS ARE SORTED OUT
C     CALL ITRACR
         NTRCRS=1
         LTREXS=.FALSE.
C     ENDI OF QUICK FIX

**    Disable tracer diagnostics if no tracers found
      IF(.NOT.LTREXS) THEN
         IF(LDTR) THEN
            WRITE(6,6000)
6000        FORMAT(1X,'***DINIT: NO TRACER DATA EXISTS - TRACER',
     -            ' DIAGNOSTICS SWITCHED OFF')
            LDTR=.FALSE.
            LDTH=.FALSE.
            LDTM=.FALSE.
            LDTZ=.FALSE.
            LDTP=.FALSE.
            LDT3=.FALSE.
         ENDIF
         IF(LDTF.AND.LOTFTR) THEN
            WRITE(6,6010)
6010        FORMAT(1X,'***DINIT: NO DATA EXISTS FOR TRACER TRANSIENT ',
     -            ' FLUXES -  ALL TRANSIENT FLUXES SWITCHED OFF')
            LDTF=.FALSE.
            LDFH=.FALSE.
            LDFM=.FALSE.
            LDFZ=.FALSE.
            LDFP=.FALSE.
            LDF3=.FALSE.
         ENDIF
         IF(LDZF.AND.LOZFTR) THEN
            WRITE(6,6020)
6020        FORMAT(1X,'***DINIT: NO DATA EXISTS FOR TRACER',
     -            ' FLUXES -  ALL ZF FLUXES SWITCHED OFF')
            LDZF=.FALSE.
         ENDIF
         IF(LDTJ) THEN
            IF(LOTJTR) THEN
               WRITE(6,6030)
6030           FORMAT(1X,'***DINIT: NO DATA EXISTS FOR TRAJECTORY',
     -               ' TRACER ATTRIBUTES -  TJ DIAGNOSTICS TURNED OFF')
               LDTJ=.FALSE.
            ENDIF
         ENDIF
         LGETTR=.FALSE.
      ENDIF

**    Initialisation of the transient flux diagnostics
      IF(LDTF) CALL TFINIT(LDTF)


      RETURN
      END
      SUBROUTINE INILAT
**    Function - Sets up Gaussian latitudes and Legendre functions.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCLEG,/BLANK/RSQ,MFP,NFP,INVAR/GPI,RADEA
**    Com changed - /LEGAU/JINC,SI,SISQ,CSSQ,CS,GWT,RLP,RDLP,
**          SECSQ,AW,EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,ALAT,ALATBY,
**          ALONBY
**    Params used - /PARAM1/JPNL,JPJGL,JPJG,JPNHEM,JPMOCT,JPJGGP,
**          /PARAM2/JPJGG,JPJGG2,JPJGGM,JPMJP
**    Called by - INIT
**    Calls - LGNDRE,GWTLT(to calculate Gaussian weights and latitudes)
**    Files read - none
**    Files written - NCLEG(Legendre function file),NCFICH
**    Author - R Brugge, University of Reading (based on the algorithm
**          in UFLUX2F) (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /BLANK/MFMP,MFP,MFPP,NFMP,NFP,NFPP,SQ(JPNNP),
     -      RSQ(JPNNP)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD

**    JPJGL is the number of latitudes at which Legendre functions and
**          their derivatives are stored in memory (either 1 or JPJG)
      IF (JPJGL.EQ.1)  JINC=0.
      IF (JPJGL.EQ.JPJG) JINC=1

      JL=1

**    Loop over latitudes
      DO 200 J=1,JPJG
      JH=J

**    J - current latitude
**    JPJG - number of latitudes in one hemisphere
      CALL GWTLT(SIJ,WEIGHT,J,JPJG)
**    Args returned from GWTLT: SIJ (sine of current latitude),
**          WEIGHT (Gaussian weight corresponding to current latitude)

      SI(J)=SIJ
      SISQ(J)=SI(J)*SI(J)
      CSSQ(J)=1.-SISQ(J)
      CS(J)=SQRT(CSSQ(J))
**    Gaussian weight is normalised according to the number of
**    hemispheres.
      GWT(J)=WEIGHT/FLOAT(JPNHEM)

**    Determine ALP and DALP, (the Associated Legendre functions and
**          their meridional derivatives)
      CALL LGNDRE(JL,JH,SI(JH),CS(JH),ALP,DALP,JPMJP,JPJGL,JPMOCT,
     -      MFP,NFP)
      IP=0

**    Loop over zonal wavenumber
      DO 100 JMP=1,MFP,JPMOCT
      IN=JMP-1
      INMAX=JMP+((NFP-JMP)/2)*2+1

**    Loop over total wavenumber
      DO 100 JJP=JMP,INMAX
      IP=IP+1
      IN=IN+1
      DALP(IP,JL)=DALP(IP,JL)/RADEA
      RLP(IP,JL)=-RSQ(IN)*ALP(IP,JL)*RADEA*RADEA
      RDLP(IP,JL)=-RSQ(IN)*DALP(IP,JL)*RADEA*RADEA
100   CONTINUE
**    Note that the Legendre functions and their meridional
**    derivatives include the factors of a**2
**    and 1/a (where appropriate) to facilitate the computation of
**    x- and y-derivatives.

      IF (JPJGL.EQ.1) WRITE(NCLEG) ALP,DALP,RLP,RDLP
200   JL=JL+JINC

      ALATBY(1)=90.0
      ZSLAT=1.0
      DO 300 J=1,JPJG
      SECSQ(J)=1./CSSQ(J)
      ALAT(J)=ATAN(SI(J)/CS(J))*180./GPI
      AW(J)=GWT(J)*FLOAT(JPNHEM)*2.*SECSQ(J)
      ZSLAT=ZSLAT-FLOAT(JPNHEM)*GWT(J)
      ALATBY(J+1)=ASIN(ZSLAT)*180.0/GPI
300   CONTINUE

**    For double hemispheres, ensure symmetry
      IF (JPNHEM.EQ.2) THEN
CDIR$ IVDEP
         DO 400 J=1,JPJG
         SI(JPJGGP-J)=-SI(J)
         CS(JPJGGP-J)=CS(J)
         SISQ(JPJGGP-J)=SISQ(J)
         CSSQ(JPJGGP-J)=CSSQ(J)
         SECSQ(JPJGGP-J)=SECSQ(J)
         ALAT(JPJGGP-J)=-ALAT(J)
         GWT(JPJGGP-J)=GWT(J)
         AW(JPJGGP-J)=AW(J)
         ALATBY(JPJGGP+1-J)=-ALATBY(J)
400      CONTINUE
      ENDIF

**    Determine Gaussian gridbox longitude boundaries
      ZLONRG=360.0/FLOAT(JPMOCT)
      ZDLON=ZLONRG/FLOAT(JPMG)
      ALONBY(1)=-0.5*ZDLON
      DO 500 J=2,JPMGP
      ALONBY(J)=ALONBY(J-1)+ZDLON
500   CONTINUE

**    Set up factors for extrapolation at poles.
      EXN1=(SI(3)-SI(1))/(SI(3)-SI(2))
      EXN2=(SI(2)-SI(1))/(SI(3)-SI(2))
      EXS1=(SI(JPJGG2)-SI(JPJGG))/(SI(JPJGG2)-SI(JPJGGM))
      EXS2=(SI(JPJGGM)-SI(JPJGG))/(SI(JPJGG2)-SI(JPJGGM))

**    Set up factors for extrapolation/interpolation to equator.
      IF (JPNHEM.EQ.1) THEN
         EXE1=ALAT(JPJG)*ALAT(JPJG)
         EXE2=ALAT(JPJG-1)*ALAT(JPJG-1)
      ELSE
         EXE1=ALAT(JPJG)
         EXE2=ALAT(JPJG-1)
      ENDIF
      EXE3=1./(EXE2-EXE1)

**    Write out the Gaussian latitudes
      WRITE(6,6000)(ALAT(J),J=JPJGG,1,-1)
      WRITE(NCFICH,6000)(ALAT(J),J=JPJGG,1,-1)
6000  FORMAT(/' GAUSSIAN LATITUDES (DEGREES)'/(15F7.2))
      WRITE(6,6010)(ALATBY(J),J=JPJGGP,1,-1)
      WRITE(NCFICH,6010)(ALATBY(J),J=JPJG,1,-1)
6010  FORMAT(/' GAUSSIAN BOX BOUNDARIES (DEGREES)'/(15F7.2))
      WRITE(6,6020)(ALONBY(J),J=1,JPMGP)
      WRITE(NCFICH,6020)(ALONBY(J),J=1,JPMGP)
6020  FORMAT(/' GAUSSIAN LONGITUDE BOUNDARIES (DEGREES)'/(15F7.2))


      RETURN
      END
      SUBROUTINE INILEVS
**    Function - Computes the vertical sigma levels. Levels
**          are assumed equispaced if JPNL<=5.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /INVAR/PI2,/COMIOC/NCFICH
**    Com changed - /VERTCL/all elements/
**    Params used - /PARAM1/JPNL,/PARAM2/JPNLM
**    Called by - INIT
**    Calls -
**    Files read - none
**    Files written - NCFICH
**    Author - R Brugge, University of Reading (based
**          on the algorithm in BGFLUX) (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)

      ZRNL=1.0/FLOAT(JPNL)
*CHACK*** fixed for 10 equispaced sigma levels
      IF (JPNL.LE.10) THEN
         DO 10 JL=1,JPNLM
         SIGMAH(JL)=JL*ZRNL
10       CONTINUE
      ELSE
         ZT1=(0.9375/0.94-1.25)/(0.9375*(SQRT(0.9375)-1.0))
         ZT2=4.0+ZT1
         ZP=0.0
         DO 20 JL=1,JPNLM
         ZP=ZP+ZRNL
         ZVV=ZP/(5.0-ZT2*ZP+ZT1*(ZP**1.5))
         ZVV=ZVV*(2.0-ZP)*(1.0+0.25*SIN(PI2*(ZP**0.6)))
         SIGMAH(JL)=ZVV
20       CONTINUE
      ENDIF

**    Derive remaining arrays used for vertical scheme.
**    Note that the upper and lower sigma values (not stored in SIGMAH)
**          are taken as 0.0 and 1.0 respectively.
      ZS1=0.
      DO 400 JJL=1,JPNLM
      ZS2=SIGMAH(JJL)
      DSIGMA(JJL)=ZS2-ZS1
      SIGMA(JJL)=0.5*(ZS2+ZS1)
      SIGMA3(JJL)=SIGMA(JJL)*1000.0
      ZS1=ZS2
400   CONTINUE
      DSIGMA(JPNL)=1.0-SIGMAH(JPNLM)
      SIGMA(JPNL)=0.5*(1.+SIGMAH(JPNLM))
      SIGMA3(JPNL)=SIGMA(JPNL)*1000.0

      DO 500 JJL=1,JPNL
      SIGMAK(JJL)=SIGMA(JJL)**(-AKAP)
      SIGM1K(JJL)=SIGMAK(JJL)/SIGMA(JJL)
      RDSIG(JJL)=0.5/DSIGMA(JJL)
500   CONTINUE

**    Now write out SIGMAH and SIGMA
      WRITE(6,6120)SIGMAH
      WRITE(NCFICH,6120)SIGMAH
6120  FORMAT(/' SIGMA AT HALF LEVELS'/(12F10.7))
      WRITE(6,6130)SIGMA
      WRITE(NCFICH,6130)SIGMA
6130  FORMAT(/' SIGMA AT FULL LEVELS'/(12F10.7))

      RETURN
      END
      SUBROUTINE INIPLV
**    Function - to initialise the JPNL pressure levels to be used for
**          output. By default, these levels are given by SIGMA*PECMWF,
**          although certain levels will be replaced by user-specified
**          values in array OUTLEV
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /LVDIAG/OUTLEV,/VERTCL/SIGMA,/INVAR/REFP0,/COMIOC/
**          NCFICH
**    Com changed - /LVDIAG/SFCOUT,NLEVEL
**    Params used - /PARAM1/JPNL
**    Called by - INITIS
**    Calls - LMERGE,ISMIN(Cray library routine)
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      DIMENSION ZOUT(JPNL),ZINCR(JPNL),ZTEMP(JPNL)

**    Determine number of user-specified output levels
      ICNT=0
      DO 100 JL=1,JPNL
      IF(OUTLEV(JL).GT.0.0) ICNT=ICNT+1
100   CONTINUE

**    Define default output levels (mb)
      DO 1000 JL=1,JPNL
      ZOUT(JL)=SIGMA(JL)*1000.0
1000  CONTINUE

      DO 1100 JL=1,JPNL
      SFCOUT(JL)=ZOUT(JL)
1100  CONTINUE

**    Use these levels if ICNT=0, else
      IF(ICNT.NE.0) THEN
**       Otherwise, replace certain levels with the user-specified
**       values (OUTLEV). This algorithm will reorder the OUTLEV values
**       in order of increasing pressure (array ZINCR) and then merge
**       these into SFCOUT, each time removing the nearest default
**       level.

**       Firstly, sort OUTLEV into ZINCR; assumes only first ICNT values
**       are to be used. This sorting is to ensure reproducibility of
**       results with a given set on OUTLEV values (which may be
**       provided by the user in amy order).
         IF(ICNT.EQ.1) THEN
            ZINCR(1)=OUTLEV(1)
            ZTEMPX=1.0E10
         ELSE
            DO 1200 J=1,ICNT
            ZTEMP(J)=OUTLEV(J)
1200        CONTINUE
            ZTEMPX=1.0E10
            DO 1300 J=1,ICNT
            INDX=ISMIN(ICNT,ZTEMP,1)
            ZINCR(J)=ZTEMP(INDX)
            ZTEMP(INDX)=ZTEMPX
1300        CONTINUE
         ENDIF
**       Now merge ZINCR into ZOUT - ICNT elements in all - and put the
**       result into SFCOUT
         IDIM1=JPNL
         IDIM2=JPNL
         CALL LMERGE(ZINCR,ICNT,ZOUT,IDIM1,SFCOUT,IDIM2,ZTEMPX)
**       Finally ensure that SFCOUT contains levels in order of
**       increasing pressure
         DO 2200 J=1,JPNL
         ZTEMP(J)=SFCOUT(J)
2200     CONTINUE
         DO 2300 J=1,JPNL
         INDX=ISMIN(JPNL,ZTEMP,1)
         SFCOUT(J)=ZTEMP(INDX)
         ZTEMP(INDX)=ZTEMPX
2300     CONTINUE
      ENDIF

**    Now determine NLEVEL array (this contains the location of the
**    OUTLEV levels in the SFCOUT array). EPSILN is a small quantity
**    that enables two REALs to be compared.
      DO 3050 JL=1,JPNL
      NLEVEL(JL)=0
3050  CONTINUE
      IELEM=0
      EPSILN=1.0E-3
      DO 3000 J=1,JPNL
      IF(IELEM.LT.ICNT) THEN
         SFPLUS=SFCOUT(J)+EPSILN
         SFLESS=SFCOUT(J)-EPSILN
         DO 3100 JU=1,ICNT
         IF((OUTLEV(JU).LT.SFPLUS).AND.(OUTLEV(JU).GT.SFLESS)) THEN
            IELEM=IELEM+1
            NLEVEL(IELEM)=J
            GO TO 3000
         ENDIF
3100     CONTINUE
      ENDIF
3000  CONTINUE

      WRITE(6,6000) SFCOUT
      WRITE(NCFICH,6000) SFCOUT
6000  FORMAT(/' OUTPUT SURFACES (MB)'/(10F10.2))

**    Finally convert SFCOUT (mb) to SFCOUT (Pa)
      DO 4000 JL=1,JPNL
      SFCOUT(JL)=SFCOUT(JL)*100.0
4000  CONTINUE

      RETURN
      END
      SUBROUTINE INIT
**    Function - to initialise constants, arrays etc required by the
**          program
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,BEGDAY,/COMTIM/TSPD,NFREQD,
**          /COMPTH/YCPTHT,YCPTHH,YCPTHC,/COMIOC/NCFICH,NCSURF,
**          /INVAR/RD,GA,RADEA,CT,/IPATHL/NLENTD,NLENHD,
**          NLENCD,/MODELC/LDRY,LBL
**    Com changed - /BLANK/MFMP,MFP,MFPP,NFMP,NFP,NFPP,SQ,RSQ
**          /COMTIM/NSTART,NEND,/COMDAT/ENDDAY,/OUTCON/YNULL,
**          /COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,MFAX,TRIG,/POLYNO/CMPA,
**          /COMPRL/XLAPSE,/PHYSC/TSTAR,QSTAR
**    Params used - /PARAM1/JPMM,JPNN,JPCRAY,JPNHEM,JPNL,JPMG,JPMOCT
**          /PARAM2/JPNNP,JPNLWG,JPIDL,JPIGL
**    Called by - MAINBF
**    Calls - INILAT,INITET,INITIS,INITTH,FAX,FFTRIG,INIVERS,AVFLGS,
**          INILEVS
**    Files read - NCSURF
**    Files written - NCFICH
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /BLANK/MFMP,MFP,MFPP,NFMP,NFP,NFPP,SQ(JPNNP),
     -      RSQ(JPNNP)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      CHARACTER*80 YCPTHT,YCPTHH,YCPTHC
      COMMON /COMPTH/YCPTHT,YCPTHH,YCPTHC
      COMMON /IPATHL/NLENTD,NLENHD,NLENCD
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      COMMON /PHYSC/TSTAR(JPJG,JPNHEM),QSTAR(JPJG,JPNHEM)
      COMPLEX CMPA
      COMMON /POLYNO/POLY(JPNWJ2,JPNHEM),CMPA(JPIGL)
      CHARACTER*25 YONULL

**    Constants for /BLANK/ common
**    Spectral constants
      MFMP=JPMM-1
      MFP=JPMM
      MFPP=JPMM+1
      NFMP=JPNN-1
      NFP=JPNN
      NFPP=JPNN+1

**    Constants for /COMPRL/
      XLAPSE=0.0065*RD/GA

**    Array CMPA used to compute x-derivatives (ie. 1/a times
**          d/d(lamda))
      DO 150 J=1,JPIGL
150   CMPA(J)=0.0
      IROW=0
CDIR$ IVDEP
      DO 160 JMP=1,MFP,JPMOCT
      IROW=IROW+1
      CMPA(IROW)=CMPLX(0.0,FLOAT(JMP-1)/RADEA)
      IF (JPNHEM.EQ.2) CMPA(IROW+JPIDL)=CMPA(IROW)
160   CONTINUE

**    Constants and auxilary values required by FFT991
      INTRWG=JPNLWG*JPNHEM
      NTWG=(INTRWG-1)/JPCRAY
      NRSTWG=INTRWG-JPCRAY*NTWG
      INTRNL=JPNL*JPNHEM
      NTNL=(INTRNL-1)/JPCRAY
      NRSTNL=INTRNL-JPCRAY*NTNL
C     CALL FAX(MFAX,JPMG,3)
C     CALL FFTRIG(TRIG,JPMG,3)
C     WRITE(4,*)'GOT TO SET99 CALL'
      CALL SET99(TRIG,MFAX,JPMG)
C     WRITE(4,*)'MFAX= ',MFAX
C     WRITE(4,*)'TRIG= ',TRIG
C     WRITE(4,*)'JPMG= ',JPMG

**    Write out the file paths
      WRITE(6,6000)
      WRITE(NCFICH,6000)
6000  FORMAT(1X,//'FILE PATHNAMES'/)
      WRITE(6,6010)YCPTHT(1:NLENTD)
      WRITE(NCFICH,6010)YCPTHT(1:NLENTD)
6010  FORMAT(1X,'TEMPORARY DIRECTORY ',A)
      WRITE(6,6020)YCPTHH(1:NLENHD)
      WRITE(NCFICH,6020)YCPTHH(1:NLENHD)
6020  FORMAT(1X,'HOME DIRECTORY ',A)
      WRITE(6,6030)YCPTHC(1:NLENCD)
      WRITE(NCFICH,6030)YCPTHC(1:NLENCD)
6030  FORMAT(1X,'CURRENT DIRECTORY ',A)

**    Spectral arrays for Legendre transforms
      SQ(1)=0.0
      RSQ(1)=0.0
      DO 100 JJNP=2,NFPP
      SQ(JJNP)=JJNP*(JJNP-1)
      RSQ(JJNP)=1.0/SQ(JJNP)
100   CONTINUE

**    Constants for /COMTIM/ common
      NSTART=NINT(BEGDAY*TSPD)
      NEND=NINT(ENDDAY*TSPD)
      IEND=(NEND-NSTART)/NFREQD
      IEND2=NSTART+IEND*NFREQD
      IF(NEND.NE.IEND2) THEN
**       Reduce NEND so that it is a required analysis time
         NEND=IEND2
         ENDDAY=FLOAT(NEND)/TSPD
         WRITE(6,6060)ENDDAY
6060     FORMAT(1X,'INIT: ENDDAY ALTERED TO ',F10.2,' TO MATCH',
     -         ' ANALYSIS TIMES')
      ENDIF

**    Remaining constants in OUTCON
      YONULL='                         '
      YNULL=YONULL//YONULL

**    Compute the Gaussian latitudes
      CALL INILAT

**    Compute the model levels (sigma)
      CALL INILEVS

      IF(YTYPSF.EQ.'ET') THEN
         CALL INITET
      ELSE IF(YTYPSF.EQ.'IS') THEN
         CALL INITIS
      ELSE IF(YTYPSF.EQ.'TH') THEN
         CALL INITTH
      ELSE
         PRINT 6070
6070     FORMAT(1X,'INIT: STOP DUE TO ERROR IN YTYPSF')
         STOP
      ENDIF

**    Compute derived arrays for vertical scheme
      CALL INIVERS

**    Determine averaging flags
      CALL AVFLGS

**    Extract TSTAR and QSTAR from NCSURF, and convert to dimensional
**          form
      IF(LBL) THEN
         IF(LDRY) THEN
            READ(NCSURF) TSTAR
            DO 1000 JH=1,JPNHEM
            DO 1000 J=1,JPJG
            TSTAR(J,JH)=TSTAR(J,JH)*CT
1000        CONTINUE
         ELSE
            READ(NCSURF) TSTAR,QSTAR
            DO 1100 JH=1,JPNHEM
            DO 1100 J=1,JPJG
            TSTAR(J,JH)=TSTAR(J,JH)*CT
            QSTAR(J,JH)=QSTAR(J,JH)*1000.0
1100        CONTINUE
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE INITET
**    Function - to initialise constants, arrays etc required by the
**          program with ET surfaces
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - INIT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      RETURN
      END
      SUBROUTINE INITIS
**    Function - to initialise constants, arrays etc required by the
**          program with IS surfaces
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - /ISDAT/NISL
**    Params used - /PARAM1/JPNL
**    Called by - INIT
**    Calls - INIPLV
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      COMMON /ISDAT/NISL

      NISL=JPNL

      CALL INIPLV

      RETURN
      END
      SUBROUTINE INITTH
**    Function - to initialise constants, arrays etc required by the
**          program with TH surfaces
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - /THDAT/NTHL
**    Params used - /PARAM1/JPNL
**    Called by - INIT
**    Calls - INTHLV
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      COMMON /THDAT/NTHL

      NTHL=JPNL

      CALL INTHLV

      RETURN
      END
      SUBROUTINE INIVERS
**    Function - to set up derived arrays for vertical scheme
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /VERTCL/SIGMA,RDSIG,SIGMAH,DSIGMA,/INVAR/AKAP,
**          /MODELC/TMEAN
**    Com changed - /COMGRM/RGG,G,T01S2,ALPHA,TKP,TAU,C
**    Params used - /PARAM1/JPNL,/PARAM2/JPIGC
**    Called by - INIT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          BGFLUX (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)

**    G and ALPHA matrices, TKP and T01S2 vectors.
**    This value of ZS1, used in setting ALPHA(1), is irrelevant
**    in the angular momentum conserving ECMWF scheme.
      ZS1=ALOG(SIGMA(1)*SIGMA(1)/SIGMAH(1))
      ZT0M=TMEAN(1)
      IG=1
      DO 10 JL=1,JPNLM
      ILP=JL+1
      ZS2=ALOG(SIGMAH(JL))
      ZT0P=TMEAN(ILP)
      IG=IG+JPNL
      G(IG)=0.0
      T01S2(JL)=ZT0P-ZT0M
      ALPHA(JL)=ZS2-ZS1
      TKP(JL)=AKAP*ZT0M
      ZT0M=ZT0P
10    ZS1=ZS2

      ALPHA(JPNL)=-ZS1
      TKP(JPNL)=AKAP*ZT0M
      G(1)=1.0
      DO 40 J=2,JPNL
      ZALJ=ALPHA(J)
      IG=J
      ILIM=J-1
      DO 20 JI=1,ILIM
      G(IG)=ZALJ
20    IG=IG+JPNL
      G(IG)=1.0-ZALJ*SIGMAH(ILIM)/DSIGMA(J)
      IF (J.EQ.JPNL) GOTO 40
      ILIM=ILIM+2
      DO 30 I=ILIM,JPNL
      IG=IG+JPNL
      G(IG)=0.0
30    CONTINUE
40    CONTINUE

**    C matrix.
      IC=-1
      DO 50 I=1,JPNL
      IC=IC+1
      JC=IC*JPNLP
      JCC=JC-JPNLM
      DO 50 J=I,JPNL
      JC=JC+1
      JCC=JCC+JPNL
      C(JCC)=G(JC)*DSIGMA(I)/DSIGMA(J)
50    CONTINUE

**    TAU vector.
      ZT01S2=T01S2(1)
      TAU(1)=0.5*ZT01S2*(SIGMAH(1)-1.0)+TKP(1)*C(1)
      DO 60 JL=2,JPNL
      TAU(JL)=0.5*ZT01S2*DSIGMA(JL)
60    CONTINUE
      ZSIG=SIGMAH(1)
      IT=JPNL
      DO 140 JL=2,JPNL
      ZTTKP=TKP(JL)
      ZTTM=ZT01S2
      ZSIGM=ZSIG
      IF (JL-JPNL) 70,80,80
70    CONTINUE
      ZT01S2=T01S2(JL)
      ZSIG=SIGMAH(JL)
80    CONTINUE
      RDSIGL=RDSIG(JL)
      DO 130 JM=1,JPNL
      IT=IT+1
      IF (JM-JL) 90,100,110
90    CONTINUE
      ZTM=1.
      ZTMM=1.
      GOTO 120
100   CONTINUE
      ZTM=1.
      ZTMM=0.
      GOTO 120
110   CONTINUE
      ZTM=0.
      ZTMM=0.
120   CONTINUE
      ZTTAU=ZTTM*(ZSIGM-ZTMM)
      IF (JL.LT.JPNL) ZTTAU=ZTTAU+ZT01S2*(ZSIG-ZTM)
      ZTTAU=ZTTAU*RDSIGL*DSIGMA(JM)
      IF (JM.LE.JL) ZTTAU=ZTTAU+ZTTKP*C(IT)
      TAU(IT)=ZTTAU
130   CONTINUE
140   CONTINUE

**    RGG matrix for vertical derivatives:
**    d()/dln(sigma) = (sigma)d()/d(sigma).
      IL=0
      DO 150 JL=1,JPNL
      ZRGVAL=SIGMA(JL)*RDSIG(JL)
      DO 150 JM=1,JPNL
      IL=IL+1
      RGG(IL)=0.0
      IF (JM.EQ.JL-1) RGG(IL)=-ZRGVAL
      IF (JM.EQ.JL+1) RGG(IL)=ZRGVAL
150   CONTINUE

      ZDA=SIGMA(1)
      ZDB=SIGMA(2)-ZDA
      ZDC=SIGMA(3)-SIGMA(2)
      ZDD=ZDC+ZDB
      RGG(1)=-ZDA*(ZDD+ZDB)/(ZDB*ZDD)
      RGG(2)=ZDA*ZDD/(ZDB*ZDC)
      RGG(3)=-ZDA*ZDB/(ZDC*ZDD)

      ZDA=SIGMA(JPNL)
      ZDD=SIGMA(JPNL-1)
      ZDB=ZDA-ZDD
      ZDC=ZDD-SIGMA(JPNL-2)
      ZDD=ZDC+ZDB
      RGG(JPNL2)=ZDA*(ZDD+ZDB)/(ZDB*ZDD)
      RGG(JPNL2-1)=-ZDA*ZDD/(ZDB*ZDC)
      RGG(JPNL2-2)=ZDA*ZDB/(ZDC*ZDD)

      RETURN
      END
      SUBROUTINE INTHLV
**    Function - to initialise the JPNL theta levels to be used for
**          output. Certain default levels will be replaced by
**          user-specified values in array OUTLEV
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /LVDIAG/OUTLEV,/COMIOC.NCFICH,/VERTCL/SIGMAK
**    Com changed - /LVDIAG/SFCOUT,NLEVEL
**    Params used - /PARAM1/JPNL
**    Called by - INITTH
**    Calls - LMERGE,ISMIN(Cray library routine)
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      DIMENSION ZOUT(JPNL),ZINCR(JPNL),ZTEMP(JPNL)

**    Determine number of user-specified output levels
      ICNT=0
      DO 100 JL=1,JPNL
      IF(OUTLEV(JL).GT.0.0) ICNT=ICNT+1
100   CONTINUE

**    Define default output levels (degK), ZOUT  runs from top to
**    bottom
      DO 1000 JL=1,JPNL
      IK=JL
      ZOUT(IK)=250.0*SIGMAK(JL)
1000  CONTINUE

      DO 1100 JL=1,JPNL
      SFCOUT(JL)=ZOUT(JL)
1100  CONTINUE

**    Use these levels if ICNT=0, else
      IF(ICNT.NE.0) THEN
**       Otherwise, replace certain levels with the user-specified
**       values (OUTLEV). This algorithm will reorder the OUTLEV values
**       in order of decreasing theta (array ZINCR) and then merge
**       these into SFCOUT, each time removing the nearest default
**       level.

**       Firstly, sort OUTLEV into ZINCR; assumes only first ICNT values
**       are to be used. This sorting is to ensure reproducibility of
**       results with a given set of OUTLEV values (which may be
**       provided by the user in any order).
         IF(ICNT.EQ.1) THEN
            ZINCR(1)=OUTLEV(1)
            ZTEMPX=1.0E10
         ELSE
            DO 1200 J=1,ICNT
            ZTEMP(J)=OUTLEV(J)
1200        CONTINUE
            ZTEMPX=1.0E10
            DO 1300 J=1,ICNT
            INDX=ISMIN(ICNT,ZTEMP,1)
            ZINCR(J)=ZTEMP(INDX)
            ZTEMP(INDX)=ZTEMPX
1300        CONTINUE
         ENDIF
**       Now merge ZINCR into ZOUT - ICNT elements in all - and put the
**       result into SFCOUT
         IDIM1=JPNL
         IDIM2=JPNL
         CALL LMERGE(ZINCR,ICNT,ZOUT,IDIM1,SFCOUT,IDIM2,ZTEMPX)
**       Finally ensure that SFCOUT contains levels in order of
**       decreasing theta
         DO 2200 J=1,JPNL
         ZTEMP(J)=SFCOUT(J)
2200     CONTINUE
         ZTEMPX=-1.0E10
         DO 2300 J=1,JPNL
         INDX=ISMAX(JPNL,ZTEMP,1)
         SFCOUT(J)=ZTEMP(INDX)
         ZTEMP(INDX)=ZTEMPX
2300     CONTINUE
      ENDIF

**    Now determine NLEVEL array (this contains the location of the
**    OUTLEV levels in the SFCOUT array). EPSILN is a small quantity
**    that enables two REALs to be compared.
      IELEM=0
      EPSILN=1.0E-3
      DO 3000 J=1,JPNL
      IF(IELEM.LT.ICNT) THEN
         SFPLUS=SFCOUT(J)+EPSILN
         SFLESS=SFCOUT(J)-EPSILN
         DO 3100 JU=1,ICNT
         IF((OUTLEV(JU).LT.SFPLUS).AND.(OUTLEV(JU).GT.SFLESS)) THEN
            IELEM=IELEM+1
            NLEVEL(IELEM)=J
            GO TO 3000
         ENDIF
3100     CONTINUE
      ENDIF
3000  CONTINUE

      WRITE(6,6000) SFCOUT
      WRITE(NCFICH,6000) SFCOUT
6000  FORMAT(/' OUTPUT SURFACES (KELVIN)'/(10F10.2))

      RETURN
      END
      SUBROUTINE CHCLOS
**    Function - To close files
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCNAME,NCLEG,NCGP,NCGPAC,NCGPAV,NCTR,NCTRAC,
**          NCTRAV,NCPHY3,NCPHY4,NCPHY5,NCDYN1,NCDYN2,NCDYN3
**    Com changed - none
**    Params used - none
**    Called by - MAINBF
**    Calls - RELEAS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)

**    NCFICH must not be released
**    NCROGS must not be released
**    NCHIST must not be released

**    NCNAME
      CALL RELEAS(IRTC,NCNAME)

**    NCLEG
      CALL RELEAS(IRTC,NCLEG)

**    NCGP, NCGPAC, NCGPAV, NCGPTS,NCGHTS, NCGZTS,NCGMTS and NCSGSW
      CALL RELEAS(IRTC,NCGP(1))
      CALL RELEAS(IRTC,NCGP(2))
      CALL RELEAS(IRTC,NCGP(3))
      CALL RELEAS(IRTC,NCGPAC(1))
      CALL RELEAS(IRTC,NCGPAC(2))
      CALL RELEAS(IRTC,NCGPAC(3))
      CALL RELEAS(IRTC,NCGPAV(1))
      CALL RELEAS(IRTC,NCGPAV(2))
      CALL RELEAS(IRTC,NCGPAV(3))
      CALL RELEAS(IRTC,NCGPTS)
      CALL RELEAS(IRTC,NCGHTS)
      CALL RELEAS(IRTC,NCGZTS)
      CALL RELEAS(IRTC,NCGMTS)
      CALL RELEAS(IRTC,NCSGSW)

**    NCTRC, NCTRAC, NCTRAV, NCTPTS,NCTHTS, NCTZTS and NCTMTS
      CALL RELEAS(IRTC,NCTRC)
      CALL RELEAS(IRTC,NCTRAC)
      CALL RELEAS(IRTC,NCTRAV)
      CALL RELEAS(IRTC,NCTPTS)
      CALL RELEAS(IRTC,NCTHTS)
      CALL RELEAS(IRTC,NCTZTS)
      CALL RELEAS(IRTC,NCTMTS)

**    NCPHY1 to NCPHY5
      CALL RELEAS(IRTC,NCPHY3)
      CALL RELEAS(IRTC,NCPHY5)

      CALL RELEAS(IRTC,NCPHY4)

**    NCDYN1 to NCDYN2
      CALL RELEAS(IRTC,NCDYN1)
      CALL RELEAS(IRTC,NCDYN3)
      CALL RELEAS(IRTC,NCDYN2)

**    Other work files
      CALL RELEAS(IRTC,NCETWK)
      CALL RELEAS(IRTC,NCZFWK)

**    NCPH must not be released
**    NCXP must not be released

**    NCUTF must not be released

      RETURN
      END
      SUBROUTINE CHOPEN
**    Function - To open file channels
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCLEG,NCUTF,NCPHY3,NCSGSW,
**          NCROGG,NCGPTS,NCGHTS,NCGZTS,NCGMTS,NCGPAC,
**          NCPHY4,NCPHY5,NCDYN1,NCDYN2,NCGP,NCGPAV,NCTF1,NCTF2,
**          NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
**          NCODC,NCODAC,NCODAV,NCOHTS,NCOZTS,NCOMTS,NCOPTS,
**          NCETWK,NCZFWK,/DIAGTP/LDOD,LDZF,LDPH,LDXP,LDTF
**          /COMNGP/NRSZ3D,NRSZSF,NRSZHL
**          /COMPTH/YCPTHT,YCPTHH,YCPTHC
**    Com changed - /IPATHL/NLENTD,NLENHD,NLENCD
**    Params used - /PARAM1/JPJGL
**    Called by - CHANNL
**    Calls - FTNN,LENSIG
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      CHARACTER*80 YCPTHT,YCPTHH,YCPTHC
      COMMON /COMPTH/YCPTHT,YCPTHH,YCPTHC
      COMMON /IPATHL/NLENTD,NLENHD,NLENCD
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      CHARACTER*8 YOCHAN

**    Determine significant lengths of the path characters
      NLENTD=LENSIG(YCPTHT)
      NLENHD=LENSIG(YCPTHH)
      NLENCD=LENSIG(YCPTHC)

**    Channel for Legendre functions, and other channels used if
**    JPJGL=1
      IF(JPJGL.EQ.1) THEN
         CALL FTNN(NCLEG,YOCHAN)
         OPEN (NCLEG,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCROGG,YOCHAN)
         OPEN (NCROGG,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCAIRM,YOCHAN)
         OPEN (NCAIRM,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
      ENDIF

**    Channel for UTF output
      CALL FTNN(NCUTF,YOCHAN)
      OPEN (NCUTF,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='FORMATTED',ERR=900)

**    NCGP, NCGPAC, NCGPAV, NCSGSW, NCGHTS, NCGZTS,NCGMTS and
**    NCGPTS files
      CALL FTNN(NCGP(1),YOCHAN)
      OPEN (NCGP(1),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3D,ERR=900)
      CALL FTNN(NCGP(2),YOCHAN)
      OPEN (NCGP(2),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZSF,ERR=900)
      CALL FTNN(NCGP(3),YOCHAN)
      OPEN (NCGP(3),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZHL,ERR=900)
      CALL FTNN(NCGPAC(1),YOCHAN)
      OPEN (NCGPAC(1),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3A,
     -      ERR=900)
      CALL FTNN(NCGPAC(2),YOCHAN)
      OPEN (NCGPAC(2),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZSA,
     -      ERR=900)
      CALL FTNN(NCGPAC(3),YOCHAN)
      OPEN (NCGPAC(3),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZHA,
     -      ERR=900)
      CALL FTNN(NCGPAV(1),YOCHAN)
      OPEN (NCGPAV(1),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3D,
     -      ERR=900)
      CALL FTNN(NCGPAV(2),YOCHAN)
      OPEN (NCGPAV(2),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZSF,
     -      ERR=900)
      CALL FTNN(NCGPAV(3),YOCHAN)
      OPEN (NCGPAV(3),FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZHL,
     -      ERR=900)

      CALL FTNN(NCGPTS,YOCHAN)
      OPEN (NCGPTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)
      CALL FTNN(NCGHTS,YOCHAN)
      OPEN (NCGHTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)
      CALL FTNN(NCGZTS,YOCHAN)
      OPEN (NCGZTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)
      CALL FTNN(NCGMTS,YOCHAN)
      OPEN (NCGMTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)

      CALL FTNN(NCSGSW,YOCHAN)
      OPEN (NCSGSW,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)

**    NCTRC, NCTRAC, NCTRAV, NCTHTS, NCTZTS,NCTMTS and NCTPTS files
      CALL FTNN(NCTRC,YOCHAN)
      OPEN (NCTRC,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3D,ERR=900)

      CALL FTNN(NCTRAC,YOCHAN)
      OPEN (NCTRAC,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3A,
     -      ERR=900)
      CALL FTNN(NCTRAV,YOCHAN)
      OPEN (NCTRAV,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3D,
     -      ERR=900)

      CALL FTNN(NCTPTS,YOCHAN)
      OPEN (NCTPTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)
      CALL FTNN(NCTHTS,YOCHAN)
      OPEN (NCTHTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)
      CALL FTNN(NCTZTS,YOCHAN)
      OPEN (NCTZTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)
      CALL FTNN(NCTMTS,YOCHAN)
      OPEN (NCTMTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -      FORM='UNFORMATTED',ERR=900)

      IF(LDOD) THEN
**       NCODC, NCODAC, NCODAV, NCOHTS, NCOZTS,NCOMTS and NCOPTS files
         CALL FTNN(NCODC,YOCHAN)
         OPEN (NCODC,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3D,ERR=900)

         CALL FTNN(NCODAC,YOCHAN)
         OPEN (NCODAC,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3A,ERR=900)

         CALL FTNN(NCODAV,YOCHAN)
         OPEN (NCODAV,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ACCESS='DIRECT',RECL=NRSZ3D,ERR=900)

         CALL FTNN(NCOPTS,YOCHAN)
         OPEN (NCOPTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCOHTS,YOCHAN)
         OPEN (NCOHTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCOZTS,YOCHAN)
         OPEN (NCOZTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCOMTS,YOCHAN)
         OPEN (NCOMTS,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)

         CALL FTNN(NCETWK,YOCHAN)
         OPEN (NCETWK,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
      ENDIF

      IF(LDZF) THEN
         CALL FTNN(NCZFWK,YOCHAN)
         OPEN (NCZFWK,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -        FORM='UNFORMATTED',ERR=900)
      ENDIF

      IF(LDPH) THEN
**       PH work files
         CALL  FTNN(NCPHY3,YOCHAN)
         OPEN (NCPHY3,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCPHY5,YOCHAN)
         OPEN (NCPHY5,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCPHY4,YOCHAN)
         OPEN (NCPHY4,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
      ENDIF

      IF(LDXP) THEN
**       XP work files
         CALL FTNN(NCDYN1,YOCHAN)
         OPEN (NCDYN1,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCDYN3,YOCHAN)
         OPEN (NCDYN3,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCDYN2,YOCHAN)
         OPEN (NCDYN2,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
      ENDIF

      IF(LDTF) THEN
**       TF work files
         CALL FTNN(NCTF1,YOCHAN)
         OPEN (NCTF1,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
         CALL FTNN(NCTF2,YOCHAN)
         OPEN (NCTF2,FILE=YCPTHT(1:NLENTD)//'/'//YOCHAN,
     -         FORM='UNFORMATTED',ERR=900)
      ENDIF

      RETURN

900   CONTINUE
**    Error trapping
      WRITE(6,6000) YCPTHT(1:NLENTD)//'/'//YOCHAN
6000  FORMAT(1X,'ERROR OPENING UNIT WITH PATH ',A)

      RETURN
      END
      SUBROUTINE RCHECK(KCHAN,PNTAPE,KOUNT,PTSPD)
**    Function - Check label on next history record.  Skip forward to
**          required analysis time if necessary, or abort if already
**          passed.
**    Args in -
**               KCHAN   - Channel number of the history file
**               PNTAPE  - Expected model run identifier (real)
**               KOUNT   - Timestep number to be searched for
**               PTSPD   - Number of timesteps per day
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - PHINIT
**    Calls - ABORT
**    Files read - KCHAN
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code
**          by M Blackburn in BGFLUX (SMAP version)

      ZZDAY=FLOAT(KOUNT)/PTSPD

10    CONTINUE
      READ(KCHAN,END=90) ZKOUNT,ZMTAPE,ZDAY
      WRITE(6,6000)ZKOUNT,ZMTAPE,ZDAY
6000  FORMAT(1X,'RCHECK: ZKOUNT,ZMTAPE,ZDAY READ AS ',3F12.3)

      IF(ABS(ZMTAPE-PNTAPE).GT.1.0E-3) THEN
         WRITE(6,6900)
6900     FORMAT(/' ***ABORT IN RCHECK: PNTAPE CONFLICT ON READ')
         WRITE(6,6990) KOUNT,PNTAPE,ZZDAY,ZKOUNT,ZMTAPE,ZDAY
6990     FORMAT(/' PROGRAM VALUES:      KOUNT  PNTAPE DAY  =',I12,2F12.3
     -      /' HISTORY FILE VALUES: ZKOUNT ZMTAPE ZDAY =',3F12.3)
         CALL ABORT
      ENDIF

      IMOUNT=NINT(ZDAY*PTSPD)

      IF(IMOUNT.LT.KOUNT) GOTO 10

      IF(IMOUNT.GT.KOUNT) THEN
         WRITE(6,6910)
6910     FORMAT(/' ***ABORT IN RCHECK: ZKOUNT MISSED ON READ')
         WRITE(6,6990) KOUNT,PNTAPE,ZZDAY,ZKOUNT,ZMTAPE,ZDAY
         CALL ABORT
      ENDIF

      BACKSPACE KCHAN
      RETURN

**    End of file reached
90    WRITE(6,6920)
6920  FORMAT(/' ***ABORT IN RCHECK: EOF ENCOUNTERED')
      WRITE(6,6990) KOUNT,PNTAPE,ZZDAY,ZKOUNT,ZMTAPE,ZDAY
      CALL ABORT

      RETURN
      END
      SUBROUTINE SKPHIS(KREC)
**    Function - to skip a specified number of history records
**    Args in -
**               KREC    - Number of records to skip
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCHIST
**    Com changed - none
**    Params used - none
**    Called by - ANALYS
**    Calls - none
**    Files read - NCHIST
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)

      DO 100 JREC=1,KREC
      READ(NCHIST)
100   CONTINUE

      RETURN
      END
      SUBROUTINE GLLOUT(KDIMX,KDIMY,PX,PMINMG,KSIGFG,KPREV1,KPREV2,
     -         KCHAN,K1N,K1X,K2N,K2X,YPNAME,PDAY1,PDAY2)
**    Function - To print out horizontal latitude-longitude fields
**    Args in -
**               KDIMX   - First dimension of the 2D array
**               KDIMY   - Second dimension of the 2D array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREV1  - Arrays are printed every KPREV1 elements
**                         in the first dimension. If
**                         the value is negative, a suitable value will
**                         be selected by this routine.
**               KPREV2  - Arrays are printed every KPREV2 elements
**                         in the second dimension. If
**                         the value is negative, a suitable value will
**                         be selected by this routine.
**               KCHAN   - Channel to receive the output
**               K1N,K1X - Array will be printed between elements K1N
**                         and K1X in the first dimension
**               K2N,K2X - Array will be printed between elements K2N
**                         and K2X in the second dimension
**               YPNAME  - Character title
**               PDAY1   - Day number, or first of a range of days
**               PDAY2   - End of a range of days if PDAY2>PDAY1
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - HROUT,INIROG,OPPHTD,PHINST,THOUT
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      COMMON /COUNTER/IRECCOUNT
      DIMENSION PX(KDIMX,KDIMY)
      CHARACTER*(*) YPNAME

CHACK
C******************************************************************************

C*****OUTPUT LAT LONG FIELDS TO BINARY FILE CHANNEL 7
C*****OUTPUT HEADER SEPARATELY TO CHANEL 8

      write(4,*)'WE ARE IN GLLOUT !!!!'
      WRITE(7)PX
      WRITE(8,*)'XY ',YPNAME
      IRECCOUNT=IRECCOUNT+1
      REWIND 30
      WRITE(30,*)IRECCOUNT

C******************************************************************************

**    Determine value of KPREV1/2 if a negative value has been supplied
      IF(KPREV1.LE.0) THEN
**       Allow two line of printout for each latitude (approx
**       220 characters)
         ICHARX=KDIMX*(KSIGFG+1)
         IPREV1=ICHARX/220+1
      ELSE
         IPREV1=KPREV1
      ENDIF
      IF(KPREV2.LE.0) THEN
         IPREV2=IPREV1
      ELSE
         IPREV2=KPREV2
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME
6000     FORMAT(1X,/' DAY ',F10.3,2X,A)
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A)
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,KDIMY,PX,PMINMG,KSIGFG,IPREV1,IPREV2,KCHAN,
     -      K1N,K1X,K2N,K2X)
      RETURN
      END
      SUBROUTINE GLMOUT(KNL,PX,PMINMG,KSIGFG,KPREVY,KCHAN,
     -         KMIN,KMAX,YPNAME,PDAY1,PDAY2,YPLEVT)
**    Function - to print out a vertical profile of values, stored in a
**          one-dimensional array
**    Args in -
**               KNL     - Vertical dimension of array PX
**               PX      - Array to be printed out
**               PMINMG  - Array will not be printed unless at least one
**                         value in the array exceeds PMINMG in
**                         magnitude
**               KSIGFG  - Number of significant figures in the output
**               KPREVY  - Array will be printed every KPREVY elements,
**               KCHAN   - Channel that the output will be written to
**               KMIN    - Array will be printed beginning with this
**                         element
**               KMAX    - Last element of the array to be printed
**               YPNAME  - Array title
**               PDAY1   - Day number, or first of a range of days
**               PDAY2   - Second of a range of days if PDAY2>PDAY1
**               YPLEVT  - Defines type of level/surface
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - OPXPTD,XPINST
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R.Brugge, University of Reading (SMAP version)

      DIMENSION PX(KNL)
      CHARACTER*(*) YPNAME,YPLEVT

**    Determine value of KPREVY if a negative value has been supplied
      IF(KPREVY.LE.0) THEN
**       Allow up to 2 lines of output, approx 220 characters
         ICHARX=KNL*(KSIGFG+1)
         IPREVY=ICHARX/220+1
      ELSE
         IPREVY=KPREVY
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME,YPLEVT
6000     FORMAT(1X,/' DAY ',F10.3,2X,A,12X,A,
     -         /'   TOP(L)....BOTTOM(R)')
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME,YPLEVT
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A,12X,A,
     -         /'   TOP(L)...BOTTOM(R)')
      ENDIF

**    Print out the array
      CALL OUTARR(KNL,1,PX,PMINMG,KSIGFG,IPREVY,1,KCHAN,
     -      KMIN,KMAX,1,1)

      RETURN
      END
      SUBROUTINE GMMOUT(KDIMX,KDIMY,PX,PMINMG,KSIGFG,KPREV1,KPREV2,
     -         KCHAN,K1N,K1X,K2N,K2X,YPNAME,PDAY1,PDAY2)
**    Function - To print out vertical meridional-mean and meridional
**          cross-sections
**    Args in -
**               KDIMX   - First dimension of the 2D array
**               KDIMY   - Second (vertical) dimension of the 2D array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREV1  - Arrays are printed every KPREV1 elements
**                         in the first dimension. If
**                         the value is negative, a suitable value will
**                         be selected by this routine.
**               KPREV2  - Arrays are printed every KPREV2 elements
**                         in the second dimension. If
**                         the value is negative, a suitable value will
**                         be selected by this routine.
**               KCHAN   - Channel to receive the output
**               K1N,K1X - Array will be printed between elements K1N
**                         and K1X in the first dimension
**               K2N,K2X - Array will be printed between elements K2N
**                         and K2X in the second dimension
**               YPNAME  - Character title
**               PDAY1   - Day number, or first of a range of days
**               PDAY2   - Second of a range of days if PDAY2>PDAY1
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GMOUT,OPPHTD,PHINST,ZSECTN
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      COMMON /COUNTER/IRECCOUNT
      DIMENSION PX(KDIMX,KDIMY)
      CHARACTER*(*) YPNAME

CHACK
C******************************************************************************

C*****OUTPUT LONG HEIGHT FIELDS TO BINARY FILE CHANNEL 7
C*****OUTPUT HEADER SEPARATELY TO CHANEL 8

      WRITE(7)PX
      WRITE(8,*)'XZ ',YPNAME
      IRECCOUNT=IRECCOUNT+1
      REWIND 30
      WRITE(30,*)IRECCOUNT

C*****************************************************************************

**    Determine value of KPREV1/2 if a negative value has been supplied
      IF(KPREV1.LE.0) THEN
**       Allow two line of printout for each longitude (approx
**       220 characters)
         ICHARX=KDIMX*(KSIGFG+1)
         IPREV1=ICHARX/220+1
      ELSE
         IPREV1=KPREV1
      ENDIF
      IF(KPREV2.LE.0) THEN
         IPREV2=IPREV1
      ELSE
         IPREV2=KPREV2
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME
6000     FORMAT(1X,/' DAY ',F10.3,2X,A)
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A)
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,KDIMY,PX,PMINMG,KSIGFG,IPREV1,IPREV2,KCHAN,
     -      K1N,K1X,K2N,K2X)
      RETURN
      END
      SUBROUTINE GMTOUT(KDIMX,KDIMY,PX,PMINMG,KSIGFG,KPREVS,KPREVT,
     -         KCHAN,K1N,K1X,K2N,K2X,YPNAME,PDAY1,PDAY2)
**    Function - To print out 2D meridional against time sections
**    Args in -
**               KDIMX   - First dimension of the 2D array
**               KDIMY   - Second (time) dimension of the 2D array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREVS  - Arrays are printed every KPREVS elements in
**                         the space dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KPREVT  - Arrays are printed every KPREVT elements in
**                         the space dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KCHAN   - Channel to receive the output
**               K1N,K1X - Array will be printed between elements K1N
**                         and K1X in the space dimension
**               K2N,K2X - Array will be printed between elements K2N
**                         and K2X in the time dimension
**               YPNAME  - Character title
**               PDAY1   - First of a range of days
**               PDAY2   - Last of a range of days
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - OPPHTS,OPSGTS,OPTRTS
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION PX(KDIMX,KDIMY)
      CHARACTER*(*) YPNAME

**    Determine value of KPREVS if a negative value has been supplied
      IF(KPREVS.LE.0) THEN
**       Allow two line of printout for each longitude (approx
**       220 characters)
         ICHARX=KDIMX*(KSIGFG+1)
         IPREVS=ICHARX/220+1
      ELSE
         IPREVS=KPREVS
      ENDIF
**    Determine value of KPREVT if a negative value has been supplied
      IF(KPREVT.LE.0) THEN
         IPREVT=IPREVS
      ELSE
         IPREVT=KPREVT
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME
6000     FORMAT(1X,/' DAY ',F10.3,2X,A)
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A)
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,KDIMY,PX,PMINMG,KSIGFG,IPREVS,IPREVT,KCHAN,
     -      K1N,K1X,K2N,K2X)
      RETURN
      END
      SUBROUTINE GPREP(PG,KDIM,PCINT,PGINC,PGMAX,PGMIN,KFAIL)
**    Function - To prepare an array for UTF output - determine data
**          extremes and set up the contour interval to be passed to
**          UTF. Note that the contour intervals are converted to the
**          same dimensionas as the field.
**    Args in -
**               PG      - Array containing data
**               KDIM    - Dimension of PG
**               PCINT   - User-supplied contour interval. Options are:
**                            a) PCINT.GT.0 :  Use input value of PCINT
**                            as contour interval for plotting.
**                            b) PCINT.LT.-1 : For plotting normalise
**                            range of field to 1000. Contour interval
**                            is -PCINT in normalised units.
**                            c) -1.LE.PCINT.LT.0 : For plotting
**                            normalise range of field to lie between
**                            0.1 and 1 by removing powers of 10 only.
**                            Contour interval is -PCINT in normalised
**                            units.
**               KFAIL   - Error return code
**    Args out -
**               PGINC   - Contour interval to be used for UTFs
**               PGMAX   - Maximum data value
**               PGMIN   - Minimum data value
**               KFAIL   - error return code
**                           -3 : input contour interval zero.
**                            0 : successful completion.
**                            1 : field has zero range
**    Args for work - none
**    Com used - /COMMSK/AMSKVC
**    Com changed - none
**    Params used - /PARAM1/JPMG,/PARAM2/JPJGG
**    Called by - S13OUT,U14OUT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      DIMENSION PG(KDIM)

      KFAIL=0

**    Find minimum and maximum values.
      IM=ISMAX(KDIM,PG,1)
      PGMAX=PG(IM)
      IM=ISMIN(KDIM,PG,1)
      PGMIN=PG(IM)

**    If the maximum value found corresponds to a mask value, find
**    the second highest value
      IF(PGMAX.GT.AMSKVC) THEN
         PGMAX=PGMIN
         DO 100 J=1,KDIM
         IF(PG(J).LT.AMSKVC) PGMAX=AMAX1(PGMAX,PG(J))
100      CONTINUE
      ENDIF

**    If the minimum value found corresponds to a mask value, find
**    the second lowest value
      ZNMASK=-AMSKVC
      IF(PGMIN.LT.ZNMASK) THEN
         PGMIN=PGMAX
         DO 101 J=1,KDIM
         IF(PG(J).GT.ZNMASK) PGMIN=AMIN1(PGMIN,PG(J))
101      CONTINUE
      ENDIF

**    Check input arguments.
      IF (PCINT.EQ.0.0) THEN
         PGINC=0.0
         IFAIL=-3
         RETURN
      ENDIF

**    Check for zero range.
      ZAMAX=AMAX1(ABS(PGMAX),ABS(PGMIN))
      ZRANGE=PGMAX-PGMIN
      IF (ZRANGE.LE.ZAMAX*1.E-3) THEN
         PGINC=0.
         IFAIL=1
         RETURN
      ENDIF

**    Set up contour levels for plotting.
      IF (PCINT.GT.0.0) THEN
         PGINC=PCINT
      ELSE IF (PCINT.LT.-1.) THEN
         PGINC=-ZRANGE*PCINT/1000.
      ELSE IF (PCINT.LT.0.) THEN
         IEXP=ALOG10(ZRANGE)*.99999
         IF (ZRANGE.GT.1.) IEXP=IEXP+1
         ZA10=10.**IEXP
         ZFRACT=ZRANGE/ZA10
         IF (ZFRACT.GT.0.5) THEN
            PGINC=-ZA10*PCINT
         ELSE IF (ZFRACT.GT.0.2) THEN
            PGINC=-ZA10*PCINT*0.5
         ELSE
            PGINC=-ZA10*PCINT*0.2
         ENDIF
      ELSE
         PGINC=0.
         IFAIL=-3
         RETURN
      ENDIF

      RETURN
      END
      SUBROUTINE GTPOUT(KDIMX,KDIMY,PX,PMINMG,KSIGFG,KPREVT,KPREVS,
     -         KCHAN,K1N,K1X,K2N,K2X,YPNAME,PDAY1,PDAY2)
**    Function - To print out 2D zonal against time sections
**    Args in -
**               KDIMX   - First (time) dimension of the 2D array
**               KDIMY   - Second dimension of the 2D array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREVT  - Arrays are printed every KPREVT elements in
**                         the time dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KPREVS  - Arrays are printed every KPREVS elements in
**                         the space dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KCHAN   - Channel to receive the output
**               K1N,K1X - Array will be printed between elements K1N
**                         and K1X in the time dimension
**               K2N,K2X - Array will be printed between elements K2N
**                         and K2X in the space dimension
**               YPNAME  - Character title
**               PDAY1   - First of a range of days
**               PDAY2   - Last of a range of days
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - OPSGTS,OPTRTS
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION PX(KDIMX,KDIMY)
      CHARACTER*(*) YPNAME

**    Determine value of KPREVS if a negative value has been supplied
      IF(KPREVS.LE.0) THEN
**       Allow one page of printout for each latitude column (approx
**       60 characters)
         IPREVS=KDIMY/60+1
      ELSE
         IPREVS=KPREVS
      ENDIF
**    Determine value of KPREVT if a negative value has been supplied
      IF(KPREVT.LE.0) THEN
         IPREVT=IPREVS
      ELSE
         IPREVT=KPREVT
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME
6000     FORMAT(1X,/' DAY ',F10.3,2X,A,
     -         /'  INCREASING HEIGHT (UPWARDS)')
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A,
     -         /'  INCREASING HEIGHT (UPWARDS)')
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,KDIMY,PX,PMINMG,KSIGFG,IPREVT,IPREVS,KCHAN,
     -      K1N,K1X,K2N,K2X)
      RETURN
      END
      SUBROUTINE GTSOUT(KDIMX,PX,PMINMG,KSIGFG,KPREVT,
     -         KCHAN,YPNAME,PDAY1,PDAY2)
**    Function - To print out a 1D time-series of data
**    Args in -
**               KDIMX   - Dimension of the array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREVT  - Arrays are printed every KPREVT elements in
**                         the space dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KCHAN   - Channel to receive the output
**               YPNAME  - Character title
**               PDAY1   - First day number
**               PDAY2   - Last day number
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - OPPHTS.OPSGTS,OPTRTS
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION PX(KDIMX)
      CHARACTER*(*) YPNAME

**    Determine value of KPREVT if a negative value has been supplied
      IF(KPREVT.LE.0) THEN
         IPREVT=1
      ELSE
         IPREVT=KPREVT
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME
6000     FORMAT(1X,/' DAY ',F10.3,2X,A)
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A)
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,1,PX,PMINMG,KSIGFG,IPREVT,1,KCHAN,1,KDIMX,1,1)
      RETURN
      END
      SUBROUTINE GTZOUT(KDIMX,KDIMY,PX,PMINMG,KSIGFG,KPREVT,KPREVS,
     -         KCHAN,K1N,K1X,K2N,K2X,YPNAME,PDAY1,PDAY2)
**    Function - To print out 2D zonal against time sections
**    Args in -
**               KDIMX   - First dimension (time) of the 2D array
**               KDIMY   - Second dimension of the 2D array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREVT  - Arrays are printed every KPREVT elements in
**                         the time dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KPREVS  - Arrays are printed every KPREVS elements in
**                         the space dimension. If the value is
**                         negative, a suitable value will be selected
**                         by this routine.
**               KCHAN   - Channel to receive the output
**               K1N,K1X - Array will be printed between elements K1N
**                         and K1X in the time dimension
**               K2N,K2X - Array will be printed between elements K2N
**                         and K2X in the space dimension
**               YPNAME  - Character title
**               PDAY1   - First of a range of days
**               PDAY2   - Last of a range of days
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - OPPHTS,OPSGTS,OPTRTS,OPXPTS
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION PX(KDIMX,KDIMY)
      CHARACTER*(*) YPNAME

**    Determine value of KPREVS if a negative value has been supplied
      IF(KPREVS.LE.0) THEN
**       Allow one page of printout for each latitude column (approx
**       60 characters)
         IPREVS=KDIMY/60+1
      ELSE
         IPREVS=KPREVS
      ENDIF
**    Determine value of KPREVT if a negative value has been supplied
      IF(KPREVT.LE.0) THEN
         IPREVT=IPREVS
      ELSE
         IPREVT=KPREVT
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME
6000     FORMAT(1X,/' DAY ',F10.3,2X,A)
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A)
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,KDIMY,PX,PMINMG,KSIGFG,IPREVT,IPREVS,KCHAN,
     -      K1N,K1X,K2N,K2X)
      RETURN
      END
      SUBROUTINE GZMOUT(KDIMX,KDIMY,PX,PMINMG,KSIGFG,KPREV1,KPREV2,
     -         KCHAN,K1N,K1X,K2N,K2X,YPNAME,PDAY1,PDAY2,YPLEVT)
**    Function - To print out vertical zonal-mean and zonal
**          cross-sections
**    Args in -
**               KDIMX   - First dimension of the 2D array
**               KDIMY   - Second (vertical) dimension of the 2D array
**               PX      - Array to be plotted
**               PMINMG  - Arrays will not be printed out unless at
**                         least one element contains data larger in
**                         magnitude than PMINMG
**               KSIGFG  - Number of significant figures in the output
**               KPREV1  - Arrays are printed every KPREVY elements
**                         in the first dimension. If
**                         the value is negative, a suitable value will
**                         be selected by this routine.
**               KPREV2  - Arrays are printed every KPREVY elements
**                         in the second dimension. If
**                         the value is negative, a suitable value will
**                         be selected by this routine.
**               KCHAN   - Channel to receive the output
**               K1N,K1X - Array will be printed between elements K1N
**                         and K1X in the first dimension
**               K2N,K2X - Array will be printed between elements K2N
**                         and K2X in the second dimension
**               YPNAME  - Character title
**               PDAY1   - Day number, or first of a range of days
**               PDAY2   - Second of a range of days if PDAY2>PDAY1
**               YPLEVT  - Description of level type
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GZOUT,OPPHTD,PHINST,ZSECTE
**    Calls - OUTARR
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      COMMON /COUNTER/IRECCOUNT
      DIMENSION PX(KDIMX,KDIMY)
      CHARACTER*(*) YPNAME,YPLEVT

CHACK
C******************************************************************************

C*****OUTPUT LAT HEIGHT FIELDS TO BINARY FILE CHANNEL 7
C*****OUTPUT HEADER SEPARATELY TO CHANEL 8

      WRITE(7)PX
      WRITE(8,*)'YZ ',YPNAME
      IRECCOUNT=IRECCOUNT+1
      REWIND 30
      WRITE(30,*)IRECCOUNT

C*****************************************************************************


**    Determine value of KPREV1/2 if a negative value has been supplied
      IF(KPREV1.LE.0) THEN
**       Allow two line of printout for each latitude (approx
**       220 characters)
         ICHARX=KDIMX*(KSIGFG+1)
         IPREV1=ICHARX/220+1
      ELSE
         IPREV1=KPREV1
      ENDIF
      IF(KPREV2.LE.0) THEN
         IPREV2=IPREV1
      ELSE
         IPREV2=KPREV2
      ENDIF

**    Print out array title and header
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(KCHAN,6000)PDAY1,YPNAME,YPLEVT
6000     FORMAT(1X,/' DAY ',F10.3,2X,A,12X,A)
      ELSE
         WRITE(KCHAN,6010)PDAY1,PDAY2,YPNAME,YPLEVT
6010     FORMAT(1X,/' DAY ',F10.3,' - ',F10.3,2X,A,12X,A)
      ENDIF

**    Print out the array
      CALL OUTARR(KDIMX,KDIMY,PX,PMINMG,KSIGFG,IPREV1,IPREV2,KCHAN,
     -      K1N,K1X,K2N,K2X)
      RETURN
      END
      SUBROUTINE HEADER
**    Function - to print out header information, describing the job
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPNN,JPMM,JPNHEM,JPMOCT,JPJG,JPMG
**    Called by - MAINBF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)

      WRITE(6,6000)
6000  FORMAT(1X,55X,25('*')/56X,'**',21X,'**'/56X,
     -      '**     SMAP  V1.1      **'/56X,'**',21X,'**'/56X,25('*'))
      WRITE(6,6001)
6001  FORMAT('   ')
      WRITE(6,6003)
6003  FORMAT(1X,24X,'PROGRAM RUNNING IN I/O-INTENSIVE MODE')
      WRITE(6,6001)
      WRITE(6,6010)
6010  FORMAT(1X,24X,'MODEL PARAMETERS')
      WRITE(6,6020)JPNL,JPNN,JPMM
6020  FORMAT(1X,40X,'NUMBER OF MODEL LEVELS     =',I6/
     -      41X,'HIGHEST TOTAL WAVENUMBER   =',I6/
     -      41X,'HIGHEST ZONAL WAVENUMBER   =',I6)
      IF(JPNHEM.EQ.2) THEN
         WRITE(6,6030)JPNHEM
6030  FORMAT(1X,40X,'NUMBER OF HEMISPHERES      =',I6/
     -      51X,'BOTH EVEN AND ODD COEFFICIENTS INCLUDED')
      ELSE IF(JPNHEM.EQ.1) THEN
         WRITE(6,6040)JPNHEM
6040  FORMAT(1X,40X,'NUMBER OF HEMISPHERES      =',I6/
     -      51X,'ONLY EVEN DIVERGENCE, TEMPERATURE AND SURFACE ',
     -      'PRESSURE,'/51X,'AND ODD VORTICITY COEFFICIENTS, INCLUDED')
      ENDIF
      WRITE(6,6060)JPMOCT
6060  FORMAT(1X,40X,'LONGITUDINAL SYMMETRY: MOCT=',I6)
      WRITE(6,6050)JPJG,JPMG
6050  FORMAT(1X,40X,'NUMBER OF GAUSSIAN LATITUDES,'/
     -      51X,'POLE TO EQUATOR  =',I6/
     -      41X,'NUMBER OF LONGITUDES       =',I6)

      RETURN
      END
      SUBROUTINE OUTARR(KDIM1,KDIM2,PX,PMINMG,KSIGFG,KPREV1,KPREV2,
     -      KCHAN,K1N,K1X,K2N,K2X)
**    Function - Prints out values in a array
**    Args in -
**               KDIM1   - first dimension of the array
**               KDIM2   - second dimension of the array
**               PX      - array to be printed. It is assumed that
**                         element (1,1) is at the top left hand
**                         corner of the array
**               PMINMG  - arrays will not be printed out which only
**                         contain numbers smaller in magnitude than
**                         PMINMG
**               KSIGFG  - number of significant figures in the output.
**                         Only values of 2 to 5 are allowed.
**               KPREV1  - the array is printed out every KPREV1
**                         elements in the first dimension, starting
**                         at (K1N,K2N)
**               KPREV2  - the array is printed out every KPREV2
**                         elements in the second dimension, starting
**                         at (K1N,K2N)
**               KCHAN   - channel to receive the output
**               K1N,K1X - array will be printed between elements K1N
**                         and K1X in the first dimension
**               K2N,K2X - array will be printed between elements K2N
**                         and K2X in the second dimension
**    Args out - none
**    Args for work - none
**    Com used - /COMMSK/AMSKV,AMSKVC
**    Com changed - none
**    Params used - /PARAM1/JPMG,/PARAM2/JPJGG
**    Called by - GLLOUT,GLMOUT,GMMOUT,GMTOUT,GTPOUT,GTSOUT,GTZOUT,
**          GZMOUT
**    Calls - none
**    Files read - none
**    Filles written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      DIMENSION PX(KDIM1,KDIM2)

      ISIGFG=KSIGFG
      AMAXMG=0.0
      DO 2000 JJ=K2N,K2X
      DO 2000 JI=K1N,K1X
2000  AMAXMG=AMAX1(AMAXMG,ABS(PX(JI,JJ)))

**    Assume that values with magnitudes in excess of 10**30
**    represent fictitious values -- for example, under orography.
**    In this case, recompute AMAXMAG.
      IF(AMAXMG.GE.AMSKVC) THEN
         AMAXMG=0.0
         DO 2100 JJ=K2N,K2X
         DO 2100 JI=K1N,K1X
         IF(ABS(PX(JI,JJ)).LT.AMSKVC)
     -         AMAXMG=AMAX1(AMAXMG,ABS(PX(JI,JJ)))
2100     CONTINUE
      ENDIF

      IF(AMAXMG.EQ.0.0)THEN
         WRITE(KCHAN,6030)
6030     FORMAT(75X,'ALL NOUGHT')
      ELSE IF(AMAXMG.LE.PMINMG)THEN
         WRITE(KCHAN,6040)PMINMG
6040     FORMAT(75X,'ALL VALUES LESS IN MAGNITUDE THAN',2PG8.1)
      ELSE

**       Constant below is ALOG10(9.95)+0.5
         IN=NINT(ALOG10(AMAXMG)-1.49782308074573)
         IF(ISIGFG.LT.2) THEN
            WRITE(KCHAN,6000)
6000        FORMAT(1X,'OUTARR: NUMBER OF SIG. FIGS. INCREASED TO 2')
            ISIGFG=2
            INM=IN
         ELSE IF(ISIGFG.GT.5) THEN
            WRITE(KCHAN,6010)
6010        FORMAT(1X,'OUTARR: NUMBER OF SIG. FIGS. REDUCED TO 5')
            ISIGFG=5
            INM=IN+2-ISIGFG
         ELSE
            INM=IN+2-ISIGFG
         ENDIF
         SCFAC=10.0**(-INM)
         WRITE(KCHAN,6050)INM
6050     FORMAT(110X,'MULTIPLY BY 10**',I3)
**       ICOLS - no. of columns to be printed out across the page
         ICOLS=126/(ISIGFG+1)
         DO 5100 IB=1,(K1X-K1N)/(ICOLS*KPREV1)+1
         I2=IB*ICOLS*KPREV1+K1N-KPREV1
         I1=I2-(ICOLS-1)*KPREV1
         I2=MIN0(I2,K1X)
         IF(ISIGFG.EQ.2) THEN
            WRITE(KCHAN,6051)(I,I=I1,I2,KPREV1)
6051        FORMAT(/6X,42I3)
            DO 5200 J=K2N,K2X,KPREV2
5200        WRITE(KCHAN,6052)J,(NINT(PX(I,J)*SCFAC),I=I1,I2,KPREV1)
6052        FORMAT(1X,I3,2X,42I3)
         ELSE IF(ISIGFG.EQ.3) THEN
            WRITE(KCHAN,6053)(I,I=I1,I2,KPREV1)
6053        FORMAT(/6X,31I4)
            DO 5300 J=K2N,K2X,KPREV2
5300        WRITE(KCHAN,6054)J,(NINT(PX(I,J)*SCFAC),I=I1,I2,KPREV1)
6054        FORMAT(1X,I3,2X,31I4)
         ELSE IF(ISIGFG.EQ.4) THEN
            WRITE(KCHAN,6055)(I,I=I1,I2,KPREV1)
6055        FORMAT(/6X,25I5)
            DO 5400 J=K2N,K2X,KPREV2
5400        WRITE(KCHAN,6056)J,(NINT(PX(I,J)*SCFAC),I=I1,I2,KPREV1)
6056        FORMAT(1X,I3,2X,25I5)
         ELSE IF(ISIGFG.EQ.5) THEN
            WRITE(KCHAN,6057)(I,I=I1,I2,KPREV1)
6057        FORMAT(/6X,21I6)
            DO 5500 J=K2N,K2X,KPREV2
5500        WRITE(KCHAN,6058)J,(NINT(PX(I,J)*SCFAC),I=I1,I2,KPREV1)
6058        FORMAT(1X,I3,2X,21I6)
         ENDIF
5100     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE PCOLOP(PF,KLEV,KPROF,PDAY1,PDAY2,YPNAME,KTFLAG,
     -      LPPR,LPUTF,KCHAN,PXLL,POUTLV,KLVTYP,YPX,YPY)
**    Function - to output a set of vertical column profiles
**    Args in -
**               PF      - Array containing profiles
**               KLEV    - Number of levels of data in each profile
**               KPROF   - Number of profiles
**               PDAY1   - Day number of the diagnostics, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**               YPNAME  - Character*50 profile title
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time average
**               LPPR    - .TRUE. if profiles to be printed
**               LPUTF   - .TRUE if profiles to be written to UTF
**               KCHAN   - Channel to which printed output will be sent
**               PXLL    - Profile latitude and longitude coordinates
**               POUTLV  - Output levels (of dimension KLEV)
**               KLVTYP  - Output level type: 1-eta/sigma, 2-pressure,
**                         3-theta, 4-hybrid sigma/theta
**               YPX     - X-axis label
**               YPY     - Y-axis label
**    Args out - none
**    Args for work - none
**    Com used - /VARTIM/LTPRNT,LTASCI,/COMDAT/LWRITE,LASCII
**    Com changed - none
**    Params used - /PARAM1/JPNL
**    Called by - GPOUT,TPOUT
**    Calls - ABORT,G14OUT
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION PF(KLEV,KPROF),PXLL(2,KPROF),POUTLV(KLEV)
      CHARACTER*50 YPNAME
      CHARACTER*(*) YPX,YPY
      LOGICAL LPPR,LPUTF

**    UTF may be incorrect if profile does not contain JPNL levels
      IF(KLEV.NE.JPNL) THEN
         WRITE(6,6900)KLEV,JPNL
6900     FORMAT(1X,'***PCOLOP: ERROR, KLEV.NE.JPNL')
         CALL ABORT
      ENDIF

      IF(LPPR) THEN
**       Printout array title and header
         WRITE(KCHAN,6000)
6000        FORMAT(1X,/' PROFILES AT SELECTED LATITUDE-LONGITUDE',
     -           ' LOCATIONS')
         IF(PDAY2.LT.PDAY1) THEN
            WRITE(KCHAN,6010)PDAY1,YPNAME
6010        FORMAT(1X,' DAY ',F10.3,2X,A)
         ELSE
            WRITE(KCHAN,6020)PDAY1,PDAY2,YPNAME
6020        FORMAT(1X,' DAY ',F10.3,' - ',F10.3,2X,A)
         ENDIF
**       Printout the values in blocks of 5
         DO 100 JF=1,KPROF,5
         IPFMAX=MIN0(JF+4,KPROF)
         WRITE(KCHAN,6100)(PXLL(1,J),J=JF,IPFMAX)
6100     FORMAT(1X,'LATITUDE    ',5(5X,F7.2))
         WRITE(KCHAN,6110)(PXLL(2,J),J=JF,IPFMAX)
6110     FORMAT(1X,'LONGITUDE   ',5(5X,F7.2))
         WRITE(KCHAN,6115)
6115     FORMAT(1X,'O/P LEVELS')
         DO 200 JL=1,KLEV
         WRITE(KCHAN,6120)POUTLV(JL),(PF(JL,J),J=JF,IPFMAX)
6120     FORMAT(1X,F12.5,5E14.5)
200      CONTINUE
100      CONTINUE
      ENDIF

      IF(LPUTF) THEN
**       UTF version 1.4
         DO 300 J=1,KPROF
         WRITE(YPNAME(26:40),'(''LA'',F5.1,''LO'',F6.1)')
     -         PXLL(1,J),PXLL(2,J)
         CALL G14OUT(POUTLV,PF(1,J),KLEV,1,31,1,KLVTYP,1,3,
     -         POUTLV(1),POUTLV(KLEV),YPNAME,YPX,YPY,' ',PDAY1,
     -         PDAY2,IFAIL,KTFLAG)
300      CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE ZSECTE(PX,KYDIM,KZDIM,YPNAME,PMINMG,KSIGFG,KCHAR,
     -      KPREVY,KPREVZ,KCHAN,KYMIN,KYMAX,KZMIN,KZMAX,PDAY1,PDAY2,
     -      PCINT,LPPR,LPUTF,KFRAME,KCSTYL,POFFST,KOFFOP,KTFLAG,
     -      KPTYP,KMSK,KFDTYP,KLVTYP,PYVALS,PZVALS,YPXLAB,YPYLAB,
     -      KCX,KCY)
**    Function - to print, and convert to UTF format, a 2-D
**          latitude-height array.
**    Args in -
**               PX      - Array to be output
**               KYDIM   - First dimension of PX in latitude
**               KZDIM   - Second dimension of PX in the vertical
**               YPNAME  - Array name/title
**               PMINMG  - Array will only be printed if at least one
**                         element value exceeds PMINMG in magnitude
**               KSIGFG  - Number of significant figures in the output
**               KCHAR   - Number of characters in YPNAME
**               KPREVY  - Array will be printed every KPREVY elements
**                         in the latitudinal direction
**               KPREVZ  - Array will be printed every KPREVZ elements
**                         in the vertical direction
**               KCHAN   - Channel to receive the printed output
**               KYMIN   - )Array will be printed between elements
**               KYMAX   - )KYMIN and KYMAX in latitude
**               KZMIN   - )Array will be printed between elements
**               KZMAX   - )KZMIN and KZMAX in the vertical
**               PDAY1   - Day number, or the first of a range of days
**               PDAY2   - End of a range of days if PDAY2>PDAY1
**               PCINT   - User-specified contour interval
**               LPPR    - .TRUE. if the array is to be printed
**               LPUTF   - .TRUE. if the array is to be dumped to a UTF
**               KFRAME  - Integer flag to control production of a new
**                         frame - for the UTF only
**               KCSTYL  - Line style integer flag - for the UTF only
**               POFFST  - Offset to be applied to field before
**                         processing
**               KOFFOP  - Integer flag defining how offset is to
**                         operate:
**                            0 : not applied
**                            1 : subtracted
**                            9 : multiplied
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time-average
**                            2 : time-series
**               KPTYP   - Plot type code
**               KMSK    - Orographic mask code
**               KFDTYP  - Field type code
**               KLVTYP  - Level type code
**               PYVALS  - y-axis values
**               PZVALS  - z-axis values
**               YPXLAB  - X-axis label - used if KPTYP=0
**               YPYLAB  - Y-axis label - used if KPTYP=0
**               KCX     - Number of characters in x-axis label
**               KCY     - Number of characters in y-axis label
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCUTF
**    Com changed - /COMDAT/NASCII
**    Params used - /PARAM1/JPNHEM
**    Called by - GZOUT,MSKPL,OPXPTD,TZOUT,XPINST
**    Calls - GZMOUT,S13OUT,U14OUT
**    Files read - none
**    Files written - none
**    Author - R.Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      DIMENSION PX(KYDIM,KZDIM)
      CHARACTER*(*) YPNAME,YPXLAB,YPYLAB
      LOGICAL LPPR,LPUTF
      DIMENSION PYVALS(KYDIM),PZVALS(KZDIM)
      CHARACTER*14 YONAME

**    Temporarily remove offset
      IF(KOFFOP.EQ.1) THEN
         DO 100 JL=1,KZDIM
         DO 100 J=1,KYDIM
100      PX(J,JL)=PX(J,JL)-POFFST
      ELSE IF(KOFFOP.EQ.9) THEN
         DO 200 JL=1,KZDIM
         DO 200 J=1,KYDIM
200      PX(J,JL)=PX(J,JL)*POFFST
      ENDIF

**    Print out the array
      IF(LPPR) THEN
         IF(KLVTYP.EQ.0) THEN
            YONAME='SIGMA SURFACES'
         ELSE IF(KLVTYP.EQ.1) THEN
            YONAME='SIGMA SURFACES'
         ELSE IF(KLVTYP.EQ.2) THEN
            YONAME='PRESS SURFACES'
         ELSE IF(KLVTYP.EQ.3) THEN
            YONAME='THETA SURFACES'
         ELSE IF(KLVTYP.EQ.4) THEN
            YONAME='ET/TH SURFACES'
         ENDIF
         CALL GZMOUT(KYDIM,KZDIM,PX,PMINMG,KSIGFG,KPREVY,
     -         KPREVZ,KCHAN,KYMIN,KYMAX,KZMIN,KZMAX,YPNAME,PDAY1,PDAY2,
     -         YONAME)
      ENDIF

**    Dump the array to a UTF
      IF(LPUTF) THEN
**       Set switches
         IPTYP=KPTYP
         IMSK=KMSK
         IFDTYP=KFDTYP
         ILVTYP=KLVTYP
         IHEM=JPNHEM
         ICHAN=NCUTF
         IASCII=NASCII
**       UTF1.4
         CALL U14OUT(PX,KYDIM,KZDIM,KYDIM,IPTYP,KCSTYL,IFDTYP,
     -      ILVTYP,KFRAME,IMSK,PCINT,IHEM,YPNAME,KCHAR,ICHAN,IASCII,
     -      IFAIL,PDAY1,PDAY2,PYVALS,PZVALS,YPXLAB,YPYLAB,KCX,KCY,
     -      KTFLAG,PX)
      ENDIF

**    Add offset back on to field
      IF(KOFFOP.EQ.1) THEN
         DO 1100 JL=1,KZDIM
         DO 1100 J=1,KYDIM
1100     PX(J,JL)=PX(J,JL)+POFFST
      ELSE IF(KOFFOP.EQ.9) THEN
         ZOFFST=1.0/POFFST
         DO 1200 JL=1,KZDIM
         DO 1200 J=1,KYDIM
1200     PX(J,JL)=PX(J,JL)*ZOFFST
      ENDIF

      RETURN
      END
      SUBROUTINE ZSECTN(PX,KXDIM,KZDIM,YPNAME,PMINMG,KSIGFG,KCHAR,
     -      KPREVX,KPREVZ,KCHAN,KXMIN,KXMAX,KZMIN,KZMAX,PDAY1,PDAY2,
     -      PCINT,LPPR,LPUTF,KFRAME,KCSTYL,POFFST,KOFFOP,KTFLAG,
     -      KPTYP,KMSK,KFDTYP,KLVTYP,PYVALS,PZVALS,YPXLAB,YPYLAB,
     -      KCX,KCY)
**    Function - to print, and convert to UTF format, a 2-D
**          meridional-height array.
**    Args in -
**               PX      - Array to be output
**               KXDIM   - First dimension of PX in longitude
**               KZDIM   - Second dimension of PX in the vertical
**               YPNAME  - Array name/title
**               PMINMG  - Array will only be printed if at least one
**                         element value exceeds PMINMG in magnitude
**               KSIGFG  - Number of significant figures in the output
**               KCHAR   - Number of characters in YPNAME
**               KPREVX  - Array will be printed every KPREVX elements
**                         in the longitudinal direction
**               KPREVZ  - Array will be printed every KPREVZ elements
**                         in the vertical direction
**               KCHAN   - Channel to receive the printed output
**               KXMIN   - )Array will be printed between elements
**               KXMAX   - )KXMIN and KXMAX in longitude
**               KZMIN   - )Array will be printed between elements
**               KZMAX   - )KZMIN and KZMAX in the vertical
**               PDAY1   - Day number, or the first of a range of days
**               PDAY2   - End of a range of days if PDAY2>PDAY1
**               PCINT   - User-specified contour interval
**               LPPR    - .TRUE. if the array is to be printed
**               LPUTF   - .TRUE. if the array is to be dumped to a UTF
**               KFRAME  - Integer flag to control production of a new
**                         frame - for the UTF only
**               KCSTYL  - Line style integer flag - for the UTF only
**               POFFST  - Offset to be applied to field before
**                         processing
**               KOFFOP  - Integer flag defining how offset is to
**                         operate:
**                            0 : not applied
**                            1 : subtracted
**                            9 : multiplied
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time-average
**                            2 : time-series
**               KPTYP   - Plot type code
**               KMSK    - Orographic mask code
**               KFDTYP  - Field type code
**               KLVTYP  - Level type code
**               PXVALS  - x-axis values
**               PZVALS  - z-axis values
**               YPXLAB  - X-axis label - used if KPTYP=0
**               YPYLAB  - Y-axis label - used if KPTYP=0
**               KCX     - Number of characters in x-axis label
**               KCY     - Number of characters in y-axis label
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCUTF
**    Com changed - /COMDAT/NASCII
**    Params used - /PARAM1/JPNHEM
**    Called by - GMOUT,MSKPL,TMOUT
**    Calls - GMMOUT,S13OUT,U14OUT
**    Files read - none
**    Files written - none
**    Author - R.Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      DIMENSION PX(KXDIM,KZDIM)
      CHARACTER*(*) YPNAME,YPXLAB,YPYLAB
      LOGICAL LPPR,LPUTF
      DIMENSION PYVALS(KXDIM),PZVALS(KZDIM)

**    Temporarily remove offset
      IF(KOFFOP.EQ.1) THEN
         DO 100 JL=1,KZDIM
         DO 100 J=1,KXDIM
100      PX(J,JL)=PX(J,JL)-POFFST
      ELSE IF(KOFFOP.EQ.9) THEN
         DO 200 JL=1,KZDIM
         DO 200 J=1,KXDIM
200      PX(J,JL)=PX(J,JL)*POFFST
      ENDIF

**    Print out the array
      IF(LPPR) THEN
         CALL GMMOUT(KXDIM,KZDIM,PX,PMINMG,KSIGFG,KPREVX,
     -         KPREVZ,KCHAN,KXMIN,KXMAX,KZMIN,KZMAX,YPNAME,PDAY1,PDAY2)
      ENDIF

**    Dump the array to a UTF
      IF(LPUTF) THEN
**       Set switches
         IPTYP=KPTYP
         IMSK=KMSK
         IFDTYP=KFDTYP
         ILVTYP=KLVTYP
         IHEM=JPNHEM
         ICHAN=NCUTF
         IASCII=NASCII
**       UTF1.4
         CALL U14OUT(PX,KXDIM,KZDIM,KXDIM,IPTYP,KCSTYL,IFDTYP,
     -      ILVTYP,KFRAME,IMSK,PCINT,IHEM,YPNAME,KCHAR,ICHAN,IASCII,
     -      IFAIL,PDAY1,PDAY2,PXVALS,PZVALS,YPXLAB,YPYLAB,KCX,KCY,
     -      KTFLAG,PX)
      ENDIF

**    Add offset back on to field
      IF(KOFFOP.EQ.1) THEN
         DO 1100 JL=1,KZDIM
         DO 1100 J=1,KXDIM
1100     PX(J,JL)=PX(J,JL)+POFFST
      ELSE IF(KOFFOP.EQ.9) THEN
         ZOFFST=1.0/POFFST
         DO 1200 JL=1,KZDIM
         DO 1200 J=1,KXDIM
1200     PX(J,JL)=PX(J,JL)*ZOFFST
      ENDIF

      RETURN
      END
      SUBROUTINE AWIL(PDATAI,KLONI,KLATI,PLATI,PLONI,KTYPE,PDATAO,
     -      KELEMO,LPSUM,PMASK,PFILL,PLONOW,PLONOE,PLATOS,PLATON)
**    Function - This subroutine does an area weighted average from one
**          grid, on a spherical earth, to another. A masking array is
**          used to specify those input data points that are to be used
**          in the averaging process. The input grid can be a limited area
**          one
**          Restrictions:  Longitude must be the first dimension and it
**                         be monotonically increasing (West to East).
**                         Latitude must be the second dimension and it
**                         must be monotonically decreasing.
**                         Values for longitude and latitude must be in
**                         degrees.
**    Args in -
**               PDATAI  - Input data
**               KLONI   - Number of input longitudes of data
**               KLATI   - Number of input latitudes of data
**               PLATI   - Input array boundary latitudes
**               PLONI   - Input array boundary longitudes
**               KTYPE   - 1 Output data for a single band of latitudes,
**                           for all longitudes
**                         2 Output data for a single band of longitudes,
**                           for all latitudes
**                         3 Limited area output data
**               LPSUM   - Set to .TRUE. if output data contains value of
**                         average times area, else output data contains
**                         area average
**               PMASK   - Masking/weighting function; can be used to
**                         define a subset of data elements to be averaged
**               PFILL   - Value assigned to output array elements for
**                         which no input data elements are appropriate
**                         (as determined by PMASK, for example)
**               PLONOW  - Western limit of the output grid (not used if
**                         KTYPE=1)
**               PLONOE  - Eastern limit of the output grid (not used if
**                         KTYPE=1)
**               PLATON  - Northern limit of the output grid (not used if
**                         KTYPE=2)
**               PLATOS - Southern limit of the output grid (not used if
**                         KTYPE=2)
**    Args out -
**               PDATAO  - Output data
**               KELEMO  - Number of output data elements
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by -
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION PDATAI(KLONI,KLATI),PLATI(KLATI+1),PLONI(KLONI+1),
     -      PDATAO(KELEMO),PMASK(KLONI,KLATI)
      LOGICAL LPSUM

**    Average value detemined according to the sum of
**          PDATA(i,j)*d(sin(latitude)*d(longitude))
**    ZERAD = earth radius
      ZERAD=6371000.0
      ZPI=ATAN2(0.0,-1.0)

**    Data assumed to be stored monotonically west-east and north-south
      DO 1000 J=1,KLATI
      IF(PLATI(J).LE.PLATI(J+1)) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'AWIL ERROR: INPUT LATITUDES DO NOT DECREASE WITH ',
     -         'INCREASING INDEX VALUE')
         CALL ABORT
      ENDIF
1000  CONTINUE
      DO 1010 J=1,KLONI
      IF(PLONI(J).GE.PLONI(J+1)) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'AWIL ERROR: INPUT LONGITUDES DO NOT DECREASE WITH ',
     -         'INCREASING INDEX VALUE')
         CALL ABORT
      ENDIF
1010  CONTINUE
      IF(KTYPE.NE.2) THEN
         IF(PLATOS.GT.PLATON) THEN
            WRITE(6,6015)
6015        FORMAT(1X,'AWIL ERROR: PLATOS > PLATON')
            CALL ABORT
         ENDIF
      ENDIF

      IF(KTYPE.EQ.2.OR.KTYPE.EQ.3) THEN
         IF(KTYPE.EQ.3) THEN
            ZEPS=1.0E-3
**          Limiting latitudes must lie within range of data
            IF(PLATON.GT.(PLATI(1)+ZEPS).OR.
     -            PLATOS.LT.(PLATI(KLATI+1)-ZEPS)) THEN
               WRITE(6,6150)PLATON,PLATOS,PLATI(1),PLATI(KLATI+1)
6150           FORMAT(1X,'AWIL ERROR: OUTPUT LATITUDES ',2F10.2,
     -               ' DO NOT MATCH DATA LATITUDE EXTREMES ',2F10.2)
               CALL ABORT
            ENDIF
         ENDIF
         ZLONOW=-999.9
         ZLONOE=-999.9
         IF(PLONOW.GE.PLONI(1).AND.PLONOW.LE.PLONI(KLONI+1))
     -      ZLONOW=PLONOW
         IF(PLONOE.GE.PLONI(1).AND.PLONOE.LE.PLONI(KLONI+1))
     -     ZLONOE=PLONOE
         IF(PLONOW.LT.PLONI(1).AND.((PLONOW+360.0).LE.PLONI(KLONI+1))
     -         .AND.((PLONOW+360.0).GE.PLONI(1))) ZLONOW=PLONOW+360.0
         IF(PLONOW.GT.PLONI(KLONI+1)
     -         .AND.((PLONOW-360.0).LE.PLONI(KLONI+1))
     -         .AND.((PLONOW-360.0).GE.PLONI(1))) ZLONOW=PLONOW-360.0
         IF(PLONOE.LT.PLONI(1).AND.((PLONOE+360.0).LE.PLONI(KLONI+1))
     -         .AND.((PLONOE+360.0).GE.PLONI(1))) ZLONOE=PLONOE+360.0
         IF(PLONOE.GT.PLONI(KLONI+1)
     -         .AND.((PLONOE-360.0).LE.PLONI(KLONI+1))
     -         .AND.((PLONOE-360.0).GE.PLONI(1))) ZLONOE=PLONOE-360.0

**       Special case - zonal mean
         ZDRANG=PLONI(KLONI+1)-PLONI(1)
         ZIRANG=ABS(PLONOE-PLONOW)
         IF(ABS(ZDRANG-ZIRANG).LT.1.0E-3) THEN
            ZLONOW=PLONI(1)
            ZLONOE=PLONI(KLONI+1)
         ENDIF
**       Limiting longitudes must lie within range of data
         IF(ZLONOW.GE.PLONI(1).AND.ZLONOW.LE.PLONI(KLONI+1).AND.
     -         ZLONOE.GE.PLONI(1).AND.ZLONOE.LE.PLONI(KLONI+1)) THEN
**          Integration type
**          Averages from ZLONOW to ZLONOE - type 20
            IF(ZLONOW.LE.ZLONOE) ITYPE=20
**          Averages from PLONI(1) to ZLONOE, and from ZLONOW to
**          PLONI(KLONI+1) - type 21
            IF(ZLONOW.GT.ZLONOE) ITYPE=21
         ELSE
            WRITE(6,6060)PLONOW,PLONOE,PLONI(1),PLONI(KLONI+1)
6060        FORMAT(1X,'AWIL ERROR: OUTPUT LONGITUDES ',2F10.2,
     -            ' DO NOT MATCH DATA LONGITUDE EXTREMES ',2F10.2)
            CALL ABORT
         ENDIF

         IF(KTYPE.EQ.2) THEN
**          Output of a north-south band of values
            IF(KELEMO.NE.KLATI) THEN
               WRITE(6,6110) KELEMO,KLATI
6110           FORMAT(1X,'AWIL ERROR: KELEMO.NE.KLATI, AND KTYPE=2  : ',
     -         2I5)
               CALL ABORT
            ENDIF
            ZLATNN=PLATI(1)
            ZLATSS=PLATI(KLATI+1)
         ELSE IF(KTYPE.EQ.3) THEN
**          Output a area average (single value)
            IF(KELEMO.NE.1) THEN
               WRITE(6,6120) KELEMO
6120           FORMAT(1X,'AWIL ERROR: KELEMO.NE.1, AND KTYPE=3  : ',
     -         I5)
               CALL ABORT
            ENDIF
            ZLATNN=PLATON
            ZLATSS=PLATOS
            ZAREA3=0.0
            ZSUM3=0.0
            ZWT3=0.0
         ENDIF

         IF(ITYPE.EQ.20.OR.ITYPE.EQ.21) THEN
            ZZLW=AMIN1(ZLONOW,ZLONOE)
            ZZLE=AMAX1(ZLONOW,ZLONOE)
            DO 300 JY=1,KLATI
            ZLATN=PLATI(JY)
            ZLATS=PLATI(JY+1)
            IF(ZLATN.LT.ZLATSS.OR.ZLATS.GT.ZLATNN) GO TO 300
            ZAREA=0.0
            ZWT=0.0
            ZSUM=0.0
            DO 400 JX=1,KLONI
            ZLONW=PLONI(JX)
            ZLONE=PLONI(JX+1)
            IF(ZLONE.GE.ZZLW.AND.ZLONW.LE.ZZLE) THEN
               ZZW=AMAX1(ZZLW,ZLONW)
               ZZE=AMIN1(ZZLE,ZLONE)
               ZDLAT=SIN(PLATI(JY)*ZPI/180.0)-SIN(PLATI(JY+1)*ZPI/180.0)
               ZDLON=(ZZE-ZZW)*ZPI/180.0
               ZAREA=ZAREA+(ZERAD**2)*ZDLAT*ZDLON*PMASK(JX,JY)
               ZWT=ZWT+ZDLAT*ZDLON*PMASK(JX,JY)
               ZSUM=ZSUM+PDATAI(JX,JY)*ZDLAT*ZDLON*PMASK(JX,JY)
            ENDIF
400         CONTINUE
            IF(ITYPE.EQ.21) THEN
**             Search algorithm needs to cross the western and
**             eastern boundarys - compute the zonal mean and substract
**             the values detemined above
               ZAREA1=ZAREA
               ZWT1=ZWT
               ZSUM1=ZSUM
               ZAREA=0.0
               ZWT=0.0
               ZSUM=0.0
               DO 600 JX=1,KLONI
               ZLONW=PLONI(JX)
               ZLONE=PLONI(JX+1)
               IF(ZLONE.GE.PLONI(1).AND.ZLONW.LE.PLONI(KLONI+1)) THEN
                  ZZW=AMAX1(PLONI(1),ZLONW)
                  ZZE=AMIN1(PLONI(KLONI+1),ZLONE)
                  ZDLAT=SIN(PLATI(JY)*ZPI/180.0)-SIN(PLATI(JY+1)*
     -               ZPI/180.0)
                  ZDLON=(ZZE-ZZW)*ZPI/180.0
                  ZAREA=ZAREA+(ZERAD**2)*ZDLAT*ZDLON*PMASK(JX,JY)
                  ZWT=ZWT+ZDLAT*ZDLON*PMASK(JX,JY)
                  ZSUM=ZSUM+PDATAI(JX,JY)*ZDLAT*ZDLON*PMASK(JX,JY)
               ENDIF
600            CONTINUE
               ZWT=ZWT-ZWT1
               ZSUM=ZSUM-ZSUM1
               ZAREA=ZAREA-ZAREA1
            ENDIF
            IF(KTYPE.EQ.2) THEN
               IF(ZWT.GT.0.0) THEN
                  IF(LPSUM) THEN
                     PDATAO(JY)=(ZSUM/ZWT)*ZAREA
                  ELSE
                     PDATAO(JY)=ZSUM/ZWT
                  ENDIF
               ELSE
                  PDATAO(JY)=PFILL
               ENDIF
            ELSE IF(KTYPE.EQ.3) THEN
               ZZN=AMIN1(PLATON,PLATI(JY))
               ZZS=AMAX1(PLATOS,PLATI(JY+1))
               ZDLAT3=SIN(ZZN*ZPI/180.0)-SIN(ZZS*ZPI/180.0)
               ZDLAT2=SIN(PLATI(JY)*ZPI/180.0)-SIN(PLATI(JY+1)*
     -               ZPI/180.0)
               ZAREA3=ZAREA3+ZAREA*ZDLAT3/ZDLAT2
               ZWT3=ZWT3+ZWT*ZDLAT3/ZDLAT2
               ZSUM3=ZSUM3+ZSUM*ZDLAT3/ZDLAT2
            ENDIF
300         CONTINUE
         ENDIF
         IF(KTYPE.EQ.3) THEN
            IF(ZWT3.GT.0.0) THEN
               IF(LPSUM) THEN
                  PDATAO(1)=(ZSUM3/ZWT3)*ZAREA3
               ELSE
                  PDATAO(1)=ZSUM3/ZWT3
               ENDIF
            ELSE
               PDATAO(1)=PFILL
            ENDIF
         ENDIF
         RETURN
      ENDIF

      IF(KTYPE.EQ.1) THEN
**       Limiting latitudes must lie within range of data
         ZEPS=1.0E-3
         IF(PLATON.GT.(PLATI(1)+ZEPS).OR.PLATOS.LT.
     -      (PLATI(KLATI+1)-ZEPS)) THEN
            WRITE(6,6050)PLATON,PLATOS,PLATI(1),PLATI(KLATI+1)
6050        FORMAT(1X,'AWIL ERROR: OUTPUT LATITUDES ',2F10.2,
     -            ' DO NOT MATCH DATA LATITUDE EXTREMES ',2F10.2)
            CALL ABORT
         ENDIF

**       Output of a west-east band of values
**       Assume that PLATOS < PLATON
         IF(KELEMO.NE.KLONI) THEN
            WRITE(6,6100) KELEMO,KLONI
6100        FORMAT(1X,'AWIL ERROR: KELEMO.NE.KLONI, AND KTYPE=1  : ',
     -      2I5)
            CALL ABORT
         ENDIF
         DO 100 JX=1,KLONI
         ZAREA=0.0
         ZWT=0.0
         ZSUM=0.0
         DO 200 JY=1,KLATI
         ZLATN=PLATI(JY)
         ZLATS=PLATI(JY+1)
         IF(ZLATN.GE.PLATOS.AND.ZLATS.LE.PLATON) THEN
            ZZN=AMIN1(PLATON,ZLATN)
            ZZS=AMAX1(PLATOS,ZLATS)
            ZDLAT=SIN(ZZN*ZPI/180.0)-SIN(ZZS*ZPI/180.0)
            ZDLON=(PLONI(JX+1)-PLONI(JX))*ZPI/180.0
            ZAREA=ZAREA+(ZERAD**2)*ZDLAT*ZDLON*PMASK(JX,JY)
            ZWT=ZWT+ZDLAT*ZDLON*PMASK(JX,JY)
            ZSUM=ZSUM+PDATAI(JX,JY)*ZDLAT*ZDLON*PMASK(JX,JY)
         ENDIF
200      CONTINUE
         IF(ZWT.GT.0.0) THEN
            IF(LPSUM) THEN
               PDATAO(JX)=(ZSUM/ZWT)*ZAREA
            ELSE
               PDATAO(JX)=ZSUM/ZWT
            ENDIF
         ELSE
            PDATAO(JX)=PFILL
         ENDIF
100      CONTINUE
         RETURN
      ENDIF

      IF(KTYPE.EQ.3) THEN
          jjj=3
      ENDIF

      RETURN
      END
      SUBROUTINE COLSUM(PX,PSUM,KI1,KI2,PHALF,LPNOW,KETAUP,KETADN)
**    Function - to compute mass-weighted column totals/averages over
**          a specified area from a 3D array of input values. The
**          algorithm assumes that the input array is held at sigma
**          levels, since there is no masking of 'underground' values.
**          The algorithm may return incorrect values unless
**          the entire model columns are processed.
**    Args in -
**               PX      - Array containing 3D input data
**               KI1     - First dimension of PX
**               KI2     - Number of 'real' data values used from first
**                         dimension of PX, and the first dimension of
**                         PSUM
**               LPNOW   - .TRUE. if current half-level pressures to be
**                         used, else time-averaged values
**               KETAUP  - Uppermost sigma level used in column
**                         summations
**               KETADN  - Lowermost sigma level used in column
**                         summations
**    Args out -
**               PSUM    - Column-summed array values
**    Args for work -
**               PHALF   - Used to hold the half level pressures, read
**                         in one latitude slice at a time
**    Com used - /COMIOC/NCGP,NCGPAV,/INVAR/GA,/COMNGP/NR1PHL,
**          /CURSGH/all elements
**    Com changed - none
**    Params used - /PARAM1/JPJG,JPNL,JPNHEM,/PARAM2/JPJGG,JPMGPP,
**          /PARAM3/JPTRMX
**    Called by - HROUT,THOUT
**    Calls - ABORT
**    Files read - NCGP(3),NCGPAV(3)
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      DIMENSION PX(KI1,JPJGG,JPNL),PSUM(KI2,JPJGG),ZWT(JPNL)
      DIMENSION PHALF(JPMGPP,JPNHEM,JPNLP)
      LOGICAL LPNOW,LOCALL
      SAVE LOCALL
      DATA LOCALL/.TRUE./

**    Check array dimensions
      IF((KI1.LT.KI2).OR.(KI2.LT.1)) THEN
         WRITE(6,6000)KI1,KI2
6000     FORMAT(1X,'***COLSUM: ERROR IN DIMENSIONS VALUES',
     -         /'DIMENSIONS ARE ',2I6)
         CALL ABORT
      ENDIF
**    Check user-supplied level limits
      IF((KETAUP.LT.1).OR.(KETADN.GT.JPNL).OR.
     -         (KETAUP.GT.KETADN)) THEN
         WRITE(6,6005)KETAUP,KETADN
6005     FORMAT(1X,'***COLSUM: ERROR IN COLUMN LIMITS ',
     -         /'UPPER AND LOWER LIMITS ARE ',2I6)
         CALL ABORT
      ENDIF

**    Determine weighting function (ZWT), taking the value 1.0 for the
**    specified range of levels
      DO 2100 JL=1,JPNL
      ZWT(JL)=0.0
2100  CONTINUE
      DO 2200 JL=KETAUP,KETADN
      ZWT(JL)=1.0
2200  CONTINUE

**    PSUM = integral(PX.density.dz) = integral(PX.dp/g).
**    Setting IMEAN to 1 will return the above integral divided by the
**    total pressure range
**    (= integral(PF.density.dz)/integral(density.dz) ).
**    Note that PHALF has MKS units (Pa).
      IMEAN=0
      DO 110 JJ=1,JPJGG
      DO 110 JI=1,KI2
      PSUM(JI,JJ)=0.0
110   CONTINUE

      IF(LPNOW) THEN
         ICHAN=NCGP(3)
      ELSE
         ICHAN=NCGPAV(3)
      ENDIF
      INIREC=NR1PHL
      ILEVDP=KETADN+1

      DO 1100 J=1,JPJG
      READ(ICHAN,REC=INIREC-1+J)PHALF
      ILATN=J
      IF(JPNHEM.EQ.2) THEN
         ILATS=JPJGG+1-J
         DO 200 JL=1,JPNL
         DO 300 JI=1,KI2
         PSUM(JI,ILATN)=PSUM(JI,ILATN)+ZWT(JL)*
     -         (PHALF(JI,1,JL+1)-PHALF(JI,1,JL))*PX(JI,ILATN,JL)
         PSUM(JI,ILATS)=PSUM(JI,ILATS)+ZWT(JL)*
     -         (PHALF(JI,2,JL+1)-PHALF(JI,2,JL))*PX(JI,ILATS,JL)
300      CONTINUE
200      CONTINUE
      ELSE
         DO 205 JL=1,JPNL
         DO 305 JI=1,KI2
         PSUM(JI,ILATN)=PSUM(JI,ILATN)+ZWT(JL)*
     -         (PHALF(JI,1,JL+1)-PHALF(JI,1,JL))*PX(JI,ILATN,JL)
305      CONTINUE
205      CONTINUE
      ENDIF

      IF(IMEAN.EQ.0) THEN
**       These values are correct, even if only 'short' columns are
**       processed
         IF(JPNHEM.EQ.2) THEN
            DO 410 JI=1,KI2
            PSUM(JI,ILATN)=PSUM(JI,ILATN)/GA
            PSUM(JI,ILATS)=PSUM(JI,ILATS)/GA
410         CONTINUE
         ELSE
            DO 415 JI=1,KI2
            PSUM(JI,ILATN)=PSUM(JI,ILATN)/GA
415         CONTINUE
         ENDIF
         IF(LOCALL) WRITE(6,6100)
6100     FORMAT(1X,/'***COLSUM: PROFILE TOTALS CONTAIN MASS-WEIGHTED',
     -         ' TOTALS')
      ELSE
CC       The following code assumes that the summation was performed
CC       over the entire model depth.
         IF(JPNHEM.EQ.2) THEN
            DO 420 JI=1,KI2
            PSUM(JI,ILATN)=PSUM(JI,ILATN)/(PHALF(JI,1,ILEVDP)-
     -            PHALF(JI,1,KETAUP))
            PSUM(JI,ILATS)=PSUM(JI,ILATS)/(PHALF(JI,2,ILEVDP)-
     -            PHALF(JI,2,KETAUP))
420         CONTINUE
         ELSE
            DO 425 JI=1,KI2
            PSUM(JI,ILATN)=PSUM(JI,ILATN)/(PHALF(JI,1,ILEVDP)-
     -            PHALF(JI,1,KETAUP))
425         CONTINUE
         ENDIF
         IF(LOCALL) WRITE(6,6110)
6110     FORMAT(1X,/'***COLSUM: PROFILE TOTALS CONTAIN MASS-WEIGHTED',
     -         ' VERTICAL AVERAGES; VALUES KNOWN TO BE TOO SMALL')
      ENDIF
      LOCALL=.FALSE.

1100  CONTINUE

      RETURN
      END
      SUBROUTINE COLTOT(PF,KPROF,PFTOT,PXLL,LPNOW,PHPF)
**    Function - to compute mass-weighted column totals/averages at
**          specified locations, given that the input data consists of a
**          series of vertical profiles. It is assumed that input data
**          is held on model levels; no masking is employed.
**    Args in -
**               PF      - Vertical profiles of the field to be
**                         summed/averaged (over JPNL levels)
**               KPROF   - Number of profiles to be processed
**               PXLL    - Latitude-longitude coordinate pairs of the
**                         profile locations
**               LPNOW   - .TRUE. if instantaneous calculations being
**                         computed, else .FALSE for time-averaged ones
**    Args out -
**               PFTOT   - Column totals
**    Args for work -
**               PHPF    - Will contain half level pressures in the
**                         profiles
**    Com used - /INVAR/GA,/COMNGP/NR1PHL,/COMIOC/NCGP,NCGPAV,NCSGSW,
**          /CURSGH/all elements
**    Com changed - /SPECTR/VO...SPAD
**    Params used - /PARAM1/JPJG,JPNHEM,JPNL,/PARAM2/JPMGPP,JPNLP,
**          /PARAM3/JPTRMX
**    Called by - GPOUT,TPOUT
**    Calls - PROFIL,LLCNVS
**    Files read - NCGP(3),NCGPAV(3)
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      DIMENSION PF(JPNL,KPROF),PXLL(2,KPROF),PFTOT(KPROF)
      LOGICAL LPNOW
      DIMENSION ZPHALF(JPMGPP,JPJGG,JPNLP),PHPF(JPNLP,KPROF)
      DIMENSION ZR(JPMGPP*JPNHEM*JPNLP,JPJG)
      EQUIVALENCE (ZPHALF(1,1,1),VO(1)),(ZR(1,1),VO(1))
      LOGICAL LOCALL
      SAVE LOCALL
      DATA LOCALL/.TRUE./

**    Read the half-level pressures from scratch/common  and
**    interpolate to the required locations
      IF(LPNOW) THEN
         ICHAN=NCGP(3)
      ELSE
         ICHAN=NCGPAV(3)
      ENDIF
      INIREC=NR1PHL
      DO 1100 J=1,JPJG
      READ(ICHAN,REC=INIREC-1+J)(ZR(JI,J),JI=1,JPMGPP*JPNHEM*JPNLP)
1100  CONTINUE
      ILEV=JPNLP
      CALL LLCNVS(ZR,JPMGPP,JPNHEM,JPNLP,JPJG,ZPHALF,JPMGPP,
     -      JPJGG,JPNLP,ILEV,.FALSE.,ZDUMMY,1,1,1,1,.TRUE.,NCSGSW)
      CALL PROFIL(ZPHALF,JPMGPP,PHPF,KPROF,PXLL,ILEV)

**    Now compute the mass-weighted total of the quantity in profile PF,
**    using the corresponding half-level pressure profile. Thus
**    PFTOT = integral(PF.density.dz) = integral(PF.dp/g).
**    Setting IMEAN to 1 will return the above integral divided by the
**    total pressure range
**    (= integral(PF.density.dz)/integral(density.dz) ).
      IMEAN=0
      DO 100 JP=1,KPROF
      PFTOT(JP)=0.0
      DO 110 JL=1,JPNL
      PFTOT(JP)=PFTOT(JP)+(PHPF(JL+1,JP)-PHPF(JL,JP))*PF(JL,JP)
110   CONTINUE
      IF(IMEAN.NE.1) THEN
         PFTOT(JP)=PFTOT(JP)/GA
         IF(LOCALL) WRITE(6,6000)
6000     FORMAT(1X,/'***COLTOT: PROFILE TOTALS CONTAIN MASS-WEIGHTED',
     -         ' TOTALS')
      ELSE
         PFTOT(JP)=PFTOT(JP)/(PHPF(JPNLP,JP)-PHPF(1,JP))
         IF(LOCALL) WRITE(6,6010)
6010     FORMAT(1X,/'***COLTOT: PROFILE TOTALS CONTAIN MASS-WEIGHTED',
     -         ' VERTICAL AVERAGES')
      ENDIF
100   CONTINUE
      LOCALL=.FALSE.

      RETURN
      END
      SUBROUTINE EXTREM(PMAX,PMIN,PMSKV,PMSKVC,PX,KDIM1,KDIM2,KDAT1,
     -      KDAT2,KINC,LPMISS)
**    Function - to compute maximum and minimum values of a gridpoint
**          array, excluding any masked points, for a single level
**    Args in -
**               PMSKV    - Gridpoint mask value
**               PMSKVC   - Equivalent to AMSKVC
**               PX       - Input array whose extrema are to found
**               KDIM1    - First dimension of PX
**               KDIM2    - Second dimension of PX
**               KDAT1    - Number of data points used in first
**                          dimension per latitude
**               KINC     - Spacing between data points of a latitude pair
**               KDAT2    - Number of data points used in second
**                          dimension
**    Args out -
**               PMAX     - Maximum array value
**               PMIN     - Minimum array value
**               LPMISS   - Set to .TRUE. if missing data detected, else
**                          .FALSE.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - ODFLXG
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LPMISS
      DIMENSION PX(KDIM1,KDIM2)

      LPMISS=.FALSE.
      PMAX=-PMSKV
      PMIN=PMSKV

      DO 1310 JLAT=1,KDAT2
      DO 1310 JI=1,KDAT1
      JIP=JI+KINC
      PMAX=AMAX1(PMAX,PX(JI,JLAT))
      PMIN=AMIN1(PMIN,PX(JI,JLAT))
      PMAX=AMAX1(PMAX,PX(JIP,JLAT))
      PMIN=AMIN1(PMIN,PX(JIP,JLAT))
1310  CONTINUE

      IF(PMAX.GT.PMSKVC) THEN
         LPMISS=.TRUE.
         PMAX=-PMSKV
         DO 1315 JLAT=1,KDAT2
         DO 1315 JI=1,KDAT1
         JIP=JI+KINC
         IF(PX(JI,JLAT).LT.PMSKVC) PMAX=AMAX1(PMAX,PX(JI,JLAT))
         IF(PX(JIP,JLAT).LT.PMSKVC) PMAX=AMAX1(PMAX,PX(JIP,JLAT))
1315     CONTINUE
      ENDIF
      ZNMASK=-PMSKVC
      IF(PMIN.LT.ZNMASK) THEN
         LPMISS=.TRUE.
         PMIN=PMSKV
         DO 1317 JLAT=1,KDAT2
         DO 1317 JI=1,KDAT1
         JIP=JI+KINC
         IF(PX(JI,JLAT).GT.ZNMASK) PMIN=AMIN1(PMIN,PX(JI,JLAT))
         IF(PX(JIP,JLAT).GT.ZNMASK) PMIN=AMIN1(PMIN,PX(JIP,JLAT))
1317     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE GETGVL(PV,KLEV,KCHAN,KREC1)
**    Function - to create a single level velocity-component field
**    Args in -
**               KLEV    - Level number of the required field
**               KCHAN   - Channel on which the data is located; assumed
**                         to be stored with JPNL levels, ordered in
**                         north-south latitude pairs. A value
**                         of -999 indicates that data will be copied
**                         from common block storage.
**               KREC1   - First record number containing velocity
**                         -component data, if stored in work file
**    Args out -
**               PV      - Velocity field at level KLEV
**    Args for work - none
**    Com used - /LEGAU/CS,/CURSGF/all elements
**    Com changed - /CWORK/WORKM
**    Params used - /PARAM1/JPMG,JPJG,/PARAM2/JPJGG,JPIGC
**    Called by - SGVEC
**    Calls - none
**    Files read - KCHAN
**    Files written - none
**    Author - R Brugge, University of Reading, based on code written by
**          M Blackburn for UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      DIMENSION PV(JPMG,JPJGG)
      DIMENSION ZDUM(2),ZDUML(JPIGC)
      EQUIVALENCE (ZDUML(1),WORKM(1,1))

      INIREC=KREC1
      DO 1000 J=1,JPJG
**    ZFAC is used to remove the cos(latitude) factor from the data
      ZFAC=1.0/CS(J)

      IF(KLEV.EQ.1) THEN
         IF(JPNHEM.EQ.1) THEN
            READ(KCHAN,REC=INIREC-1+J) (PV(I,J),I=1,JPMG)
            DO 100 JI=1,JPMG
            PV(JI,J)=PV(JI,J)*ZFAC
100         CONTINUE
         ELSE
            ILATS=JPJGG+1-J
            READ(KCHAN,REC=INIREC-1+J)
     -            (PV(I,J),I=1,JPMG),ZDUM,(PV(I,ILATS),I=1,JPMG)
            DO 200 JI=1,JPMG
            PV(JI,J)=PV(JI,J)*ZFAC
            PV(JI,ILATS)=PV(JI,ILATS)*ZFAC
200         CONTINUE
         ENDIF
      ELSE
**       Skip initial data for unwanted levels
         IF(JPNHEM.EQ.1) THEN
            READ(KCHAN,REC=INIREC-1+J) (ZDUML,I=1,KLEV-1),
     -            (PV(I,J),I=1,JPMG)
            DO 300 JI=1,JPMG
            PV(JI,J)=PV(JI,J)*ZFAC
300         CONTINUE
         ELSE
            ILATS=JPJGG+1-J
            READ(KCHAN,REC=INIREC-1+J) (ZDUML,I=1,KLEV-1),
     -           (PV(I,J),I=1,JPMG),ZDUM,(PV(I,ILATS),I=1,JPMG)
            DO 400 JI=1,JPMG
            PV(JI,J)=PV(JI,J)*ZFAC
            PV(JI,ILATS)=PV(JI,ILATS)*ZFAC
400        CONTINUE
        ENDIF
      ENDIF
1000  CONTINUE

      RETURN
      END
      SUBROUTINE GMEAN3(PX,K1,K2,K3,PWORK,PG,PLVWT)
**    Function - To compute the global mean of a three-dimensional array
**          using a weighting factor in the vertical. Note that this
**          routine assumes that valid data is available at all
**          gridpoints; no masks are employed.
**    Args in -
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**    Args out -
**               PG      - Global mean of PX
**    Args for work -
**               PWORK   - Work array - used to store zonal mean
**                         temporarily
**    Com used - none
**    Com changed - /LEGAU/GWT
**    Params used - none
**    Called by - PHINST,OPPHTD
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      DIMENSION PX(K1,K2,K3),PWORK(K2),PLVWT(K3)

**    The Gaussian weight employed below (GWT) is assumed to be
**    normalised according to the number of hemispheres.
      PG=0.0
      ZK1=1.0/FLOAT(K1)
      DO 100 JK=1,K3
      DO 200 J=1,K2
      PWORK(J)=SSUM(K1,PX(1,J,JK),1)*ZK1
200   CONTINUE
      PG=PG+SDOT(K2,GWT,1,PWORK,1)*PLVWT(JK)
100   CONTINUE

      RETURN
      END
      SUBROUTINE GSTRAN(PGP,PSP,KLEV,KLAT,KTYPE,KCHAN)
**    Function - Direct transform to obtain spectral from grid point
**          field
**    Args in -
**               PGP    - Real array of grid point data, or workspace
**                        array.
**               KLEV   - Number of levels in field.
**               KLAT   - If grid point data on a file (KCHAN>0), must
**                        be 1. If global gridpoint data passed in PGP
**                        array, must be JG.
**               KTYPE  - Type of direct transform.  Options are
**                          1 or 2 : normal transform
**                          3 or 4 : y-derivative
**                        An odd/even value denotes odd/even symmetry in
**                        the spectral field.
**               KCHAN  - Channel for grid point data.  If all JPJG
**                        latitudes passed in PGP array, use KCHAN<=0.
**    Args out - none
**               PSP     - Complex array containing spectral data.
**    Args for work -
**               PGP     - Only used for work if KCHAN>1
**    Com used - /COMIOC/NCLEG,/COMFFT/WORK,TRIG,MFAX,/LEGAU/JINC
**    Com changed - /LEGAU/ALP,DALP,RLP,RDLP
**    Params used - /PARAM1/JPJG,JPNHEM,JPCRAY,JPJGL,JPMG,/PARAM2/
**          JPMGPP,JPIGC,JPIGA
**    Called by - none
**    Calls - ABORT,HANAL,FFT991(Library routine)
**    Files read - NCLEG,KCHAN
**    Files written -
**    Author - R Brugge, University of Reading, based on code by
**          M Blackburn (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      DIMENSION PGP(JPIGC*KLEV,KLAT)
      COMPLEX PSP(JPIGA*KLEV)

**    Check value of KLAT
      IF((KCHAN.LE.0.AND.KLAT.NE.JPJG).OR.
     -      (KCHAN.GT.0.AND.KLAT.NE.1)) THEN
         WRITE(6,6000)KCHAN,KLAT,JPJG
6000     FORMAT(1X,'GSTRAN: INCOMPATIBLE VALUES FOR KCHAN, KLAT AND ',
     -         'JPJG: ',3I6)
         CALL ABORT
      ENDIF

**    Set up number of single level Fourier transforms for batching.
      ITRGS=KLEV*JPNHEM
      ITGS=(ITRGS-1)/JPCRAY
      IRSTGS=ITRGS-JPCRAY*ITGS

**    Preset spectral array to zero.
      DO 10 JI=1,JPIGA*KLEV
10    PSP(JI)=CMPLX(0.,0.)

**    Perform transform in latitude loop, reading Legendre functions
**    and grid-point data if required.
      IL=1
      IF (JPJGL.EQ.1) REWIND NCLEG
      ILGP=1
      IGPINC=1
      IF (KCHAN.GT.0) THEN
         IGPINC=0
         REWIND KCHAN
      ENDIF

      DO 40 JIH=1,JPJG
      IF (JPJGL.EQ.1) READ(NCLEG) ALP,DALP,RLP,RDLP
      IF (KCHAN.GT.0) READ(KCHAN) (PGP(I,ILGP),I=1,JPIGC*KLEV)

      IF(ITGS.NE.0) THEN
         DO 20 JI=1,ITGS
20       CALL FFT991(PGP(1+(JI-1)*JPCRAY*JPMGPP,ILGP),WORK,TRIG,MFAX
     -         ,1,JPMGPP,JPMG,JPCRAY,-1)
      ENDIF
      CALL FFT991(PGP(1+ITGS*JPCRAY*JPMGPP,ILGP),WORK,TRIG,MFAX
     -           ,1,JPMGPP,JPMG,IRSTGS,-1)

      IJH=JIH
      CALL HANAL(PGP(1,ILGP),PSP,KLEV,KTYPE,IJH,IL)
      IL=IL+JINC
      ILGP=ILGP+IGPINC
40    CONTINUE

      RETURN
      END
      SUBROUTINE HANAL(PGV,PSV,KL,KTYPE,KJH,KJL)
**    Function - Performs direct Legendre transform for a (set of)
**          field(s) having a total of KL levels, from Fourier to
**          spectral space.
**    Args in -
**               PGV    - Fourier space field
**               PSV    - Spectral space field, preset to zero
**               KL     - Number of levels in field
**               KTYPE  - Type of direct transform.  Options are
**                          1 or 2 : normal transform
**                          3 or 4 : y-derivative; -(1/a)d/d(mu) found
**                        An odd/even value denotes odd/even symmetry in
**                        the spectral field.
**               KJH    - Current latitude counter (in range 1 - JPJG)
**               KJL    - Second dimension of the Legendre functions to
**                        be used
**    Args out -
**               PSV    - Spectral space field
**               PGV    - Values are altered
**    Args for work - none
**    Com used - /LEGAU/ALP,DALP,RLP,RDLP,AW,CSSQ,/BLANK/MFP,NFP,
**    Com changed - /POLYNO/POLY
**    Params used - /PARAM1/JPNHEM,JPMOCT,JPNWJ2,/PARAM2/JPIGA,
**          JPIGL,JPMJP,JPJGL,JPNWW,JPIDL,JPMH
**    Called by - GSTRAN,SFCHDV,SFCHG
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /BLANK/MFMP,MFP,MFPP,NFMP,NFP,NFPP,SQ(JPNNP),
     -      RSQ(JPNNP)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMPLEX CMPA
      COMMON /POLYNO/POLY(JPNWJ2,JPNHEM),CMPA(JPIGL)
      COMPLEX PSV(JPIGA*KL),PGV(JPIGL*KL),ZTEMP
      DIMENSION ZALPN(JPMJP,JPJGL,4)
      EQUIVALENCE (ZALPN(1,1,1),ALP(1,1))

**    Use KTYPE to define transform type and symmetry labels.
**    ISPAR is symmetry of spectral field    = 0 for D,T,SP etc.
**                                           = 1 for Z.
**    IGPAR is symmetry of Fourier field: same as ISPAR unless transform
**          involves a d/dy.

      IF(KTYPE.LE.0.OR.KTYPE.GE.5) THEN
         WRITE(6,6000) KTYPE
6000     FORMAT(/' ***ABORT : HANAL CALLED WITH KTYPE =',I5)
         CALL ABORT
      ENDIF

      IALP=(KTYPE+1)/2
      ISPAR=MOD(KTYPE,2)
      IGPAR=ISPAR
      IF(IALP.EQ.2) IGPAR=1-ISPAR

**    For a global run, sum and difference the complete Fourier
**    transforms at the northern and southern latitude rows to give
**    the even and odd contributions.
**    Separate code for each symmetry:
**          IGPAR=0 : even (IA) to precede odd (IB).
**          IGPAR=0 : odd (IA) to precede even (IB).

      IF(JPNHEM.EQ.2) THEN
         IF(IGPAR.EQ.0) THEN
            DO 10 JM=1,JPNWW
            IA=JM-JPIGL
CDIR$ IVDEP
            DO 10 JIV=1,KL
            IA=IA+JPIGL
            IB=IA+JPIDL
            ZTEMP=PGV(IA)
            PGV(IA)=0.5*(ZTEMP+PGV(IB))
            PGV(IB)=0.5*(ZTEMP-PGV(IB))
10          CONTINUE
         ELSE
            DO 20 JM=1,JPNWW
            IA=JM-JPIGL
CDIR$ IVDEP
            DO 20 JIV=1,KL
            IA=IA+JPIGL
            IB=IA+JPIDL
            ZTEMP=PGV(IA)
            PGV(IA)=0.5*(ZTEMP-PGV(IB))
            PGV(IB)=0.5*(ZTEMP+PGV(IB))
20          CONTINUE
         ENDIF
      ENDIF

**    Set up appropriate Gaussian weight for current latitude.
**    This depends on transform type.
      IF(IALP.EQ.1) ZWT=AW(KJH)*CSSQ(KJH)
      IF(IALP.EQ.2) ZWT=-AW(KJH)

**    Calculate POLY array in vector loop before main transform.
      DO 30 JHEM=1,JPNHEM
      INC=(JHEM-1)*(1-ISPAR)+(2-JHEM)*ISPAR
      IA=INC-1
      DO 30 JIP=1,JPNWJ2
      IA=IA+2
30    POLY(JIP,JHEM)=ZWT*ZALPN(IA,KJL,IALP)

**    Perform direct Legendre transform from the even and odd
**    parts of the Fourier transforms to spectral space.
**    Separate code for JPNHEM=1,2 to increase efficiency.
      IF (JPNHEM.EQ.1) THEN
         IM=-JPIDL
         IP=-JPNWJ2
         DO 40 JMP=1,MFP,JPMOCT
         IM=IM+1
         DO 40 JIN=JMP,NFP,JPMH
         IP=IP+1
         DO 40 JIV=1,KL
40       PSV(IP+JIV*JPNWJ2)=PSV(IP+JIV*JPNWJ2)+
     -          POLY(IP+JPNWJ2,1)*PGV(IM+JIV*JPIDL)
      ELSE
         IM=-JPIDL
         IP=-JPNWJ2
         DO 50 JMP=1,MFP,JPMOCT
         IM=IM+1
         DO 50 JIN=JMP,NFP,JPMH
         IP=IP+1
CDIR$ IVDEP
         DO 50 JIV=1,KL*JPNHEM,2
         IW=JIV+1
         PSV(IP+JIV*JPNWJ2)=PSV(IP+JIV*JPNWJ2)+
     -         POLY(IP+JPNWJ2,1)*PGV(IM+JIV*JPIDL)
50       PSV(IP+IW*JPNWJ2)=PSV(IP+IW*JPNWJ2)+
     -         POLY(IP+JPNWJ2,2)*PGV(IM+IW*JPIDL)
      ENDIF

      RETURN
      END
      SUBROUTINE HEXP(PSV,PGV,KL,KTYPE,KJL)
**    Function - Performs indirect Legendre transform for a (set of)
**          field(s) having a total of KL levels, from spectral to
**          Fourier space.
**    Args in -
**               PSV    - Spectral space field
**               KL     - Number of levels in field
**               KTYPE  - Type of transform. Permissible values are
**                           1 or 2 : normal transform
**                           3 or 4 : y-derivative
**                           5 or 6 : del**(-2) transform
**                           7 or 8 : y-derivative of del**(-2)
**                         Odd/even value implies odd/even symmetry in
**                         the spectral field.
**               KJL    - Second dimension of the Legendre functions to
**                        be used
**    Args out -
**               PGV    - Fourier space field
**    Args for work - none
**    Com used - /LEGAU/ALP,DALP,RLP,RDLP,/BLANK/MFP,NFP
**    Com changed - /POLYNO/POLY
**    Params used - /PARAM1/JPMOCT,JPNHEM,JPNWJ2,/PARAM2/JPIGA,JPIGL,
**          JPMFP,JPJGL,JPIDL,JPMH,JPNWW
**    Called by - SGTRAN,LTI,SFCHDV,SFCHG
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /BLANK/MFMP,MFP,MFPP,NFMP,NFP,NFPP,SQ(JPNNP),
     -      RSQ(JPNNP)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMPLEX CMPA
      COMMON /POLYNO/POLY(JPNWJ2,JPNHEM),CMPA(JPIGL)
      COMPLEX PSV(JPIGA*KL),PGV(JPIGL*KL),ZTEMP
      DIMENSION ZALPN(JPMJP,JPJGL,4)
      EQUIVALENCE (ZALPN(1,1,1),ALP(1,1))

**    Preset Fourier array to zero.
      DO 10 JI=1,JPIGL*KL
10    PGV(JI)=0.

**    Use KTYPE to define transform type and symmetry labels.
**    ISPAR is symmetry of spectral field    = 0 for D,T,SP etc.
**                                           = 1 for Z.
**    IGPAR is symmetry of Fourier field: same as ISPAR unless transform
**          involves a d/dy.

      IF(KTYPE.LE.0.OR.KTYPE.GE.9) THEN
         WRITE(6,6000) KTYPE
6000     FORMAT(/' ***ABORT : HEXP CALLED WITH TYPE =',I5)
         CALL ABORT
      ENDIF

      IALP=(KTYPE+1)/2
      ISPAR=MOD(KTYPE,2)
      IGPAR=ISPAR
      IF(IALP.EQ.2.OR.IALP.EQ.4) IGPAR=1-ISPAR

**    Calculate POLY array in vector loop before main transform.
      DO 30 JHEM=1,JPNHEM
      INC=(JHEM-1)*(1-ISPAR)+(2-JHEM)*ISPAR
      IA=INC-1
      DO 20 JIP=1,JPNWJ2
      IA=IA+2
20    POLY(JIP,JHEM)=ZALPN(IA,KJL,IALP)
30    CONTINUE

**    Perform inverse Legendre transform from spectral space to form
**    the even and odd contributions to the Fourier transforms.
**    Separate code for JPNHEM=1,2 to increase efficiency.
      IF(JPNHEM.EQ.1) THEN
         IM=-JPIDL
         IP=-JPNWJ2
         DO 40 JMP=1,MFP,JPMOCT
         IM=IM+1
         DO 40 JIN=JMP,NFP,JPMH
         IP=IP+1
         DO 40 JIV=1,KL
40       PGV(IM+JIV*JPIDL)=PGV(IM+JIV*JPIDL)+
     -         POLY(IP+JPNWJ2,1)*PSV(IP+JIV*JPNWJ2)
      ELSE
         IM=-JPIDL
         IP=-JPNWJ2
         DO 50 JMP=1,MFP,JPMOCT
         IM=IM+1
         DO 50 JIN=JMP,NFP,JPMH
         IP=IP+1
CDIR$ IVDEP
         DO 50 JIV=1,KL*JPNHEM,2
         IW=JIV+1
         PGV(IM+JIV*JPIDL)=PGV(IM+JIV*JPIDL)+
     -         POLY(IP+JPNWJ2,1)*PSV(IP+JIV*JPNWJ2)
50       PGV(IM+IW*JPIDL)=PGV(IM+IW*JPIDL)+
     -         POLY(IP+JPNWJ2,2)*PSV(IP+IW*JPNWJ2)
      ENDIF

**    For a global run, sum and difference even and odd contributions
**    to give the complete Fourier transforms at the northern and
**    southern latitude rows.  Separate code for each symmetry:
**       IGPAR=0 : even (IA) precedes odd (IB).
**       IGPAR=1 : odd (IA) precedes even (IB).
      IF(JPNHEM.EQ.2) THEN
         IF(IGPAR.EQ.0) THEN
            DO 60 JM=1,JPNWW
            IA=JM-JPIGL
CDIR$ IVDEP
            DO 60 JIV=1,KL
            IA=IA+JPIGL
            IB=IA+JPIDL
            ZTEMP=PGV(IA)
            PGV(IA)=ZTEMP+PGV(IB)
            PGV(IB)=ZTEMP-PGV(IB)
60          CONTINUE
         ELSE
            DO 70 JM=1,JPNWW
            IA=JM-JPIGL
CDIR$ IVDEP
            DO 70 JIV=1,KL
            IA=IA+JPIGL
            IB=IA+JPIDL
            ZTEMP=PGV(IA)
            PGV(IA)=PGV(IB)+ZTEMP
            PGV(IB)=PGV(IB)-ZTEMP
70          CONTINUE
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE HFILT(PGRID1,KDIM1,KDIM2,ZAFIL,KMFIL,KIPAR,PGRID2)
**    Function - Filters a 2-D gridpoint field using the Hoskins filter
**    Args in -
**               PGRID1  - 2-D array prior to filtering
**               KDIM1   - First dimension of PGRID1; should be equal
**                         to JPMG
**               KDIM2   - Second dimension of PGRID2; should be equal
**                         to JPJGG
**               ZAFIL   - Cutoff constant, typically 0.1
**               KMFIL   - Cutoff wavelength, typically 24
**               KIPAR   - Parity of field, odd(1) or even(2)
**    Args out -
**               PGRID2  - 2-D array after filtering
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNN,JPMM,JPJG,JPMOCT,JPNWJ2,JPNHEM,JPMG,
**          /PARAM2/JPJGG,JPMGP,JPMGPP,JPIGC
**    Called by -
**    Calls - ABORT,GSTRAN,SGTRAN
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code from
**          P Valdes (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      DIMENSION PGRID1(KDIM1,KDIM2),ZGRID(JPIGC,JPJG),
     -      PGRID2(KDIM1,KDIM2)
      COMPLEX ZSPECT(JPIGA)
      DIMENSION ZFILTR(0:JPNN)

**    Check that KDIM1=JPMG and that KDIM2=JPJGG
      IF(KDIM1.NE.JPMG) THEN
         WRITE(6,6000)KDIM1,JPMG
6000     FORMAT(1X,'HFILT - ERROR DETECTED IN FIRST ARRAY DIMENSION'/
     -         'FOUND ',I5,' EXPECTED ',I5,' ; ABORT CALLED')
         CALL ABORT
      ENDIF
      IF(KDIM2.NE.JPJGG) THEN
         WRITE(6,6010)KDIM2,JPJGG
6010     FORMAT(1X,'HFILT - ERROR DETECTED IN SECOND ARRAY DIMENSION'/
     -         'FOUND ',I5,' EXPECTED ',I5,' ; ABORT CALLED')
         CALL ABORT
      ENDIF

**    Convert grid-layout
      IF(JPNHEM.EQ.1) THEN
         DO 1000 J=1,JPJG
         DO 1100 JI=1,JPMG
         ZGRID(JI,J)=PGRID1(JI,J)
1100     CONTINUE
         ZGRID(JPMGP,J)=0.0
         ZGRID(JPMGPP,J)=0.0
1000     CONTINUE
      ELSE
         DO 2000 J=1,JPJG
         JS=JPJGG+1-J
         DO 2100 JI=1,JPMG
         JIP=JPMGPP+JI
         ZGRID(JI,J)=PGRID1(JI,J)
         ZGRID(JIP,J)=PGRID1(JI,JS)
2100     CONTINUE
         ZGRID(JPMGP,J)=0.0
         ZGRID(JPMGPP,J)=0.0
         ZGRID(JPIGC,J)=0.0
         ZGRID(JPIGC-1,J)=0.0
2000     CONTINUE
      ENDIF

**    Setup the filter array

      IF(ZAFIL.NE.0.0)THEN
         DO 10 JN=0,JPNN
10       ZFILTR(JN)=0.
         ZFK=-ALOG(ZAFIL)/((KMFIL*(KMFIL+1))**2)
         DO 20 JN=0,MIN(JPNN,KMFIL)
20       ZFILTR(JN)=EXP(-ZFK*JN*JN*(JN+1)*(JN+1))
      ELSE
         WRITE(6,6020)
6020     FORMAT(1X,'HFILT: AFIL = 0.0, NO FILTERING PERFORMED')
         RETURN
      ENDIF

**    Now convert array to spectral form

      CALL GSTRAN(ZGRID,ZSPECT,1,JPJG,KIPAR,-1)

**    Now apply filter

      DO 200 JHEM=1,JPNHEM
      IPH=(KIPAR-2)*(JHEM-1)+(1-KIPAR)*(2-JHEM)
      I=(JHEM-1)*JPNWJ2
      DO 200 JMP=1,JPMM,JPMOCT
      DO 200 JIN=JMP,JPNN,2
      I=I+1
      ZSPECT(I)=ZSPECT(I)*ZFILTR(JIN+IPH)
200   CONTINUE

**    Now transform back to gridpoint space

      CALL SGTRAN(ZSPECT,ZGRID,1,JPJG,KIPAR,-1)

**    Finally reorder the output array
      IF(JPNHEM.EQ.1) THEN
         DO 3000 J=1,JPJG
         DO 3100 JI=1,JPMG
         PGRID2(JI,J)=ZGRID(JI,J)
3100     CONTINUE
3000     CONTINUE
      ELSE
         DO 4000 J=1,JPJG
         JS=JPJGG+1-J
         DO 4100 JI=1,JPMG
         JIP=JPMGPP+JI
         PGRID2(JI,J)=ZGRID(JI,J)
         PGRID2(JI,JS)=ZGRID(JIP,J)
4100     CONTINUE
4000     CONTINUE
      ENDIF

      RETURN
      END
      INTEGER FUNCTION INTLOC(KVAL,KARRAY,KDIM,KDIR)
**    Function - To return the location of an integer value in an
**          array of integers. A value of -1 is returned if the
**          element is not found.
**    Args in -
**               KVAL    - integer value to search for
**               KARRAY  - integer array in which to search
**               KDIM    - size of arrat KARRAY
**               KDIR    - 0 indicates a search from element 1 to element
**                         KDIM, 1 indicates the reverse of this
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - TJINIT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION KARRAY(KDIM)

      INTLOC=-1

      IF(KDIR.EQ.0) THEN
         DO 100 J=1,KDIM
         IF(KVAL.EQ.KARRAY(J)) THEN
            INTLOC=J
            RETURN
         ENDIF
100      CONTINUE
      ELSE IF (KDIR.EQ.1) THEN
         DO 200 J=KDIM,1,-1
         IF(KVAL.EQ.KARRAY(J)) THEN
            INTLOC=J
            RETURN
         ENDIF
200      CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE LLCNVS(PXI,KI1,KI2,KI3,KI4,PXO,KO1,KO2,KO3,KLEV,
     -      LPWORK,PTEMP,KT1,KT2,KT3,KT4,LPEQV,KCHAN)
**    Function - to switch the indices of an SG-type array to an
**          easier-to-use longitude-by-latitude-by-height format
**    Args in -
**               PXI     - Input array
**               KI1     - First index of input array (eg JPMGPP)
**               KI2     - Second index of input array (eg JPNHEM)
**               KI3     - Third index of input array (eg JPNL)
**               KI4     - Fourth index of input array (eg JPJG)
**               KO1     - First index of output array (eg JPMGPP or
**                         JPMG)
**               KO2     - Second index of output array (eg JPJGG)
**               KO3     - Third index of output array (eg JPNL)
**               KLEV    - Number of levels containing 'real' data
**               LPWORK  - .TRUE. if the work array PTEMP can be used
**               KT1     - First index of work array
**               KT2     - Second index of work array
**               KT3     - Third index of work array
**               KT4     - Fourth index of work array
**               LPEQV   - .TRUE. if PXI and PXO are equivalenced to
**                         each other by the CALL statement
**               KCHAN   - Scratch channel that can be used for
**                         temporary storage
**    Args out -
**               PXO     - Output (re-arranged) array
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - COLTOT,SGINST,OPSG,OPTR,TRINST
**    Calls - ABORT
**    Files read - KCHAN
**    Files written - KCHAN
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LPWORK,LPEQV,LOWORK
      DIMENSION PXI(KI1,KI2,KI3,KI4),PXO(KO1,KO2,KO3),
     -      PTEMP(KT1,KT2,KT3,KT4)

      LOWORK=LPWORK

**    Check that the index dimensions agree
      IF((KI1.LT.KO1).OR.(KI3.NE.KO3).OR.(KI2*KI4.NE.KO2).OR.
     -         (KI2.GT.2).OR.(KI2.LT.1).OR.(KO2.NE.KI4*KI2)) THEN
         WRITE(6,6000)KI1,KI2,KI3,KI4,KO1,KO2,KO3
6000     FORMAT(1X,'***LLCONV: ERROR IN ARRAY DIMENSIONS',/10X,7I6)
         CALL ABORT
      ENDIF

      IF(.NOT.LPEQV) THEN
**    Since input and output arrays are not equivalenced, simply copy
**          from the input array to the output array
         IF(KI2.EQ.2) THEN
            DO 400 JLV=1,KLEV
            DO 410 JLAT=1,KI4
            ILAT=2*KI4+1-JLAT
            DO 420 JLNG=1,KO1
            PXO(JLNG,JLAT,JLV)=PXI(JLNG,1,JLV,JLAT)
            PXO(JLNG,ILAT,JLV)=PXI(JLNG,2,JLV,JLAT)
420         CONTINUE
410         CONTINUE
400         CONTINUE
         ELSE
            DO 401 JLV=1,KLEV
            DO 411 JLAT=1,KI4
            DO 421 JLNG=1,KO1
            PXO(JLNG,JLAT,JLV)=PXI(JLNG,1,JLV,JLAT)
421         CONTINUE
411         CONTINUE
401         CONTINUE
         ENDIF
         RETURN
      ENDIF

      IF(LOWORK) THEN
**    Cannot use work array unless its dimensions are correct
         IF((KT1.LT.KI1).OR.(KT2.LT.KI2).OR.(KT3.LT.KI3).OR.
     -         (KT4.LT.KI4)) LOWORK=.FALSE.
      ENDIF

      IF(LOWORK.AND.LPEQV) THEN
**    Copy input array to work array, and then copy elements of work
**          array to output array
         DO 1000 J4=1,KI4
         DO 1000 J3=1,KI3
         DO 1000 J2=1,KI2
         DO 1000 J1=1,KI1
         PTEMP(J1,J2,J3,J4)=PXI(J1,J2,J3,J4)
1000     CONTINUE
         IF(KI2.EQ.2) THEN
            DO 1100 JLV=1,KLEV
            DO 1110 JLAT=1,KI4
            ILAT=2*KI4+1-JLAT
            DO 1120 JLNG=1,KO1
            PXO(JLNG,JLAT,JLV)=PTEMP(JLNG,1,JLV,JLAT)
            PXO(JLNG,ILAT,JLV)=PTEMP(JLNG,2,JLV,JLAT)
1120        CONTINUE
1110        CONTINUE
1100        CONTINUE
         ELSE
            DO 1101 JLV=1,KLEV
            DO 1111 JLAT=1,KI4
            DO 1121 JLNG=1,KO1
            PXO(JLNG,JLAT,JLV)=PTEMP(JLNG,1,JLV,JLAT)
1121        CONTINUE
1111        CONTINUE
1101        CONTINUE
         ENDIF
         RETURN
      ENDIF

      IF((.NOT.LOWORK).AND.(LPEQV)) THEN
**    Input and output arrays are equivalenced, and no work space is
**          available - use KCHAN to store input array
         REWIND KCHAN
         DO 100 JLV=1,KLEV
         DO 110 JLAT=1,KI4
         WRITE(KCHAN)(PXI(JLNG,1,JLV,JLAT),JLNG=1,KI1)
110      CONTINUE
         IF(KI2.EQ.2) THEN
            DO 120 JLAT=KI4,1,-1
            WRITE(KCHAN)(PXI(JLNG,2,JLV,JLAT),JLNG=1,KI1)
120         CONTINUE
         ENDIF
100      CONTINUE

         REWIND KCHAN
         DO 200 JLV=1,KLEV
         DO 210 JLAT=1,KO2
         READ(KCHAN)(PXO(JLNG,JLAT,JLV),JLNG=1,KO1)
210      CONTINUE
200      CONTINUE
         RETURN
      ENDIF

      END
      SUBROUTINE LTI(KIL,LPTR)
**    Function - Controls the Inverse Legendre transforms, from spectral
**          to Fourier space.
**    Args in -
**               KIL     - Second dimension index of Legendre functions
**               LPTR    - .TRUE. if tracers to be processed
**    Args out - none
**    Args for work - none
**    Com used - /SPECTR/VO,D,Q,H,T,SP,/POLYNO/CMPA,/INVAR/EZ,
**          /COMTRV/NTRCRS,/TRPTR/TRCR
**    Com changed - /GRIDP/VOG,UG,SFG,CHIG,VG,DG,QG,HQ,TG,APSFCG,
**          TYG,APJG,TXG,APMG,/TRPTR/TRCRG
**    Params used - /PARAM1/JPNL,/PARAM2/JPIGK,JPIGL,JPNLP,JPIGB,
**          JPIGA,JPIGD
**    Called by - SGFLUX
**    Calls - HEXP
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMPLEX CMPA
      COMMON /POLYNO/POLY(JPNWJ2,JPNHEM),CMPA(JPIGL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LPTR
      COMPLEX ZUG(JPIGK),ZVG(JPIGK),ZSFG(JPIGK),
     -      ZTG(JPIGL*JPNLP),ZTXG(JPIGL*JPNLP),ZCHIG(JPIGK)
      EQUIVALENCE (ZUG(1),UG(1)),(ZVG(1),VG(1)),(ZSFG(1),SFG(1)),
     -      (ZTG(1),TG(1)),(ZTXG(1),TXG(1)),(ZCHIG(1),CHIG(1))

**    HEXP transforms fields having the same symmetry and type of
**    polynomial (ALP, DALP, RLP, RDLP etc).
      CALL HEXP(VO,VOG,JPNL,1,KIL)

**    Absolute vorticity. Remove planetary vorticity for subsequent
**    transforms requiring relative vorticity.
      DO 10 J=1,JPIGB,JPIGA
10    VO(J)=VO(J)-EZ

**    Wind components.  Calls to HEXP give following Fourier fields:
**       UG   :   -u.cos(lat) (rotatational part)
**       VG   :   v.cos(lat) (divergent part)
**       SFG  :   streamfunction
**       CHIG :   velocity potential
**    Then sum to give total winds.  CMPA takes x-derivative.

      CALL HEXP(VO,UG,JPNL,7,KIL)
      CALL HEXP(VO,SFG,JPNL,5,KIL)
      CALL HEXP(D,CHIG,JPNL,6,KIL)
      CALL HEXP(D,VG,JPNL,8,KIL)
      II=0
**    ZUG and ZVG filled with u.cos(latitude) and v.cos(latitude)
      DO 20 JL=1,JPNL
      DO 20 J=1,JPIGL
      II=II+1
      ZUG(II)=ZCHIG(II)*CMPA(J)-ZUG(II)
      ZVG(II)=ZSFG(II)*CMPA(J)+ZVG(II)
20    CONTINUE

**    Symmetric spectral fields (D-divergence, Q-specific humidity,
**    H-diabatic heating, T-temperature, SP-log(surface pressure)).
      CALL HEXP(D,DG,4*JPNL+1,2,KIL)

**    y-derivatives of T and SP calculated; (1/a).(1-mu**2).d/d(mu)
      CALL HEXP(T,TYG,JPNLP,4,KIL)

**    x-derivatives of T and SP calculated; (i.m/a, equivalent to
**    (1/a)d/d(lamda) in gridpoint space)
      II=0
      DO 30 JL=1,JPNLP
      DO 30 J=1,JPIGL
      II=II+1
30    ZTXG(II)=ZTG(II)*CMPA(J)

**    Relative vorticity. Add planetary vorticity for subsequent
**    calculations requiring absolute vorticity.
      DO 40 J=1,JPIGB,JPIGA
40    VO(J)=VO(J)+EZ

**    Transform tracers if necessary
C      IF(LPTR) CALL HEXP(TRCR,TRCRG,JPNL*NTRCRS,2,KIL)

      RETURN
      END
      SUBROUTINE MERMN3(PX,K1,K2,K3,PM,KXDAT,YPT,LPINST)
**    Function - To compute the meridional mean of a three-dimensional
**          array.
**    Args in -
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**               KXDAT   - Number of 'real' data values in first
**                         dimension
**               YPT     - CHARACTER*1, type of field
**                            'S' - surface field
**                            'F' - full level field
**                            'H' - half-level field
**                            'M' - mask field, use arithmetic mean
**               LPINST  - .TRUE. if averages are for instantaneous
**                         fields, else time-averaged
**    Args out -
**               PM      - Meridional mean of PX
**    Args for work - none
**    Com used - /LEGAU/GWT,/COMAVG/NAVTYP,/COMIOC/NCGP,NCGPAV,
**          /COMNGP/NR1ALM,NR1TH,/COMMSK/AMSKV,/CURSGF/all elements
**    Com changed - /CWORK/WORK3D
**    Params used - /PARAM1/JPJG,JPMG,JPNL,JPNHEM,/PARAM2/JPJGG,JPMGPP,
**          JPJGGP,/PARAM3/JPTRMX
**    Called by - GMOUT,INIMSK,PHINST,OPPHTD,TMOUT
**    Calls - ABORT
**    Files read - NCGP,NCGPAV
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      DIMENSION PX(K1,K2,K3),PM(K1,K3)
      DIMENSION ZMASK(JPMGPP,JPJGG,JPNL),ZLATSL(JPMGPP,JPNHEM,JPNL),
     -      ZMM(JPMG,JPNL)
      EQUIVALENCE(ZMASK(1,1,1),WORK3D(1))
      LOGICAL LPINST
      CHARACTER*1 YPT
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)

      IF(NAVTYP.EQ.1.OR.(YPT.EQ.'S').OR.(YPT.EQ.'H')
     -      .OR.(YPT.EQ.'M')) THEN
**    Simple, arithmetic mean average
         DO 100 JK=1,K3
         DO 200 JI=1,KXDAT
         PM(JI,JK)=0.0
         DO 300 J=1,K2
         PM(JI,JK)=PM(JI,JK)+GWT(J)*PX(JI,J,JK)
300      CONTINUE
200      CONTINUE
100      CONTINUE
         RETURN
      ENDIF

**    Land/air mask-weighted average, NAVTYP=2
**    Sigma-weighted average, NAVTYP=3
      IF(NAVTYP.EQ.2.OR.NAVTYP.EQ.3) THEN
         IF((KXDAT.NE.JPMG).OR.(K2.NE.JPJGG).OR.(K3.NE.JPNL).OR.
     -         (JPNHEM.NE.2)) THEN
            WRITE(6,6000)
6000        FORMAT(1X,'***MERMN3 - INVALID DIMENSIONS FOR NAVTYP.NE.1,'
     -            ' ABORT CALLED')
            CALL ABORT
         ENDIF
         IF(LPINST) THEN
            ICHAN=NCGP(1)
         ELSE
            ICHAN=NCGPAV(1)
         ENDIF

         DO 1000 J=1,JPJG
         IF(NAVTYP.EQ.2) THEN
            READ(ICHAN,REC=NR1ALM+J-1) ZLATSL
         ELSE
            READ(ICHAN,REC=NR1TH+J-1) ZLATSL
         ENDIF

         DO 1108 JK=1,JPNL
         JN=J
         JS=JPJGGP-J
         IF(JPNHEM.EQ.2) THEN
            DO 1100 JI=1,JPMG
            ZMASK(JI,JN,JK)=ZLATSL(JI,1,JK)
            ZMASK(JI,JS,JK)=ZLATSL(JI,2,JK)
1100        CONTINUE
         ELSE
            DO 1107 JI=1,JPMG
            ZMASK(JI,JN,JK)=ZLATSL(JI,1,JK)
1107        CONTINUE
         ENDIF
1108     CONTINUE
1000     CONTINUE

**       ZMM will contain the sum of GWT*mask along each line of
**             longitude
         DO 1200 JK=1,JPNL
         DO 1210 JI=1,JPMG
         ZMM(JI,JK)=0.0
         DO 1220 J=1,JPJGG
         ZMM(JI,JK)=ZMM(JI,JK)+GWT(J)*ZMASK(JI,J,JK)
1220     CONTINUE
1210     CONTINUE
1200     CONTINUE

**       Now fill ZMASK with PX times mask value
         DO 1300 JK=1,JPNL
         DO 1300 J=1,JPJGG
         DO 1300 JI=1,JPMG
         ZMASK(JI,J,JK)=ZMASK(JI,J,JK)*PX(JI,J,JK)
1300     CONTINUE
         DO 1400 JK=1,JPNL
         DO 1410 JI=1,JPMG
         PM(JI,JK)=0.0
         DO 1420 J=1,JPJGG
         PM(JI,JK)=PM(JI,JK)+GWT(J)*ZMASK(JI,J,JK)
1420     CONTINUE
         IF(ZMM(JI,JK).EQ.0.0) THEN
            PM(JI,JK)=AMSKV
         ELSE
            PM(JI,JK)=PM(JI,JK)/ZMM(JI,JK)
         ENDIF
1410     CONTINUE
1400     CONTINUE
         RETURN
      ENDIF

      RETURN
      END
      SUBROUTINE MLABEL(ALONG,KMG)
**    Function - To generate meridional axis coordinates (labels)
**    Args in -
**               KMG     - number of gridpoints around a latitude circle
**    Args out -
**               ALONG   - longitudes (equally-spaced)
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPMOCT
**    Called by - OPPHTS,OPSGTS,OPTRTS
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      DIMENSION ALONG(KMG),ZLONG(JPMG)
      LOGICAL LOCALL
      DATA LOCALL/.TRUE./
      SAVE LOCALL,ZLONG

      IF(LOCALL) THEN
         ZLONG(1)=0.0
         ZDLON=360.0/FLOAT(KMG*JPMOCT)
         DO 100 J=2,KMG
         ZLONG(J)=ZLONG(J-1)+ZDLON
100      CONTINUE
         LOCALL=.FALSE.
      ENDIF
      DO 200 J=1,KMG
      ALONG(J)=ZLONG(J)
200   CONTINUE

      RETURN
      END
      SUBROUTINE NSLONR(PLON,KMG,PX,K1,K2,K3,PZ)
**    Function - To extract a 2D north-south slice at a specified
**          longitude from a 3D array of data. land/air masks are not
**          employed, and the routine does not distinguish
**          'underground' data.
**    Args in -
**               PLON    - Longitude where data required
**               KMG     - Number of equally-spaced longitudes where
**                         gridpoint data is known
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**    Args out -
**               PZ      - Zonal slice at required longitude
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPMOCT
**    Called by - PHINST,OPPHTD,GZOUT,TZOUT
**    Calls - INTREW
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      DIMENSION PX(K1,K2,K3),PZ(K2,K3)

      ZLON=PLON
      ZLONX=360.0/FLOAT(JPMOCT)
100   CONTINUE
      IF(ZLON.LT.0.0) ZLON=ZLON+ZLONX
      IF(ZLON.GT.ZLONX) ZLON=ZLON-ZLONX
      IF(ZLON.GT.ZLONX.OR.(ZLON.LT.0.0)) GO TO 100

      ZDLON=ZLONX/FLOAT(KMG)
      IF(ZLON.GT.ZLONX-ZDLON) THEN
         IWEST=KMG
         IEAST=1
         ZDIST=(ZLON-ZLONX+ZDLON)/ZDLON
      ELSE
**       Determine west (IWEST) and east (IEAST) model longitudes
**       bordering ZLON
         ICNT=0
         ZLONW=-ZDLON
         ZLONE=0.0
500      ICNT=ICNT+1
         ZLONW=ZLONW+ZDLON
         ZLONE=ZLONE+ZDLON
         IF((ZLON.GE.ZLONW).AND.(ZLON.LE.ZLONE)) THEN
            IWEST=ICNT
            IEAST=ICNT+1
            ZDIST=(ZLON-ZLONW)/(ZLONE-ZLONW)
            GO TO 520
         ENDIF
         GO TO 500
      ENDIF
520   CONTINUE
      CALL INTREW(PX,K1,K2,K3,IWEST,IEAST,PZ,ZDIST)

      RETURN
      END
      SUBROUTINE POS(PXX,KN,PX,KJ)
**    Function - given an array PXX of length KN, and given a value PX,
**          POS returns a value KJ such that PX lies between PXX(J) and
**          PXX(J+1). PXX must be monotonic, either increasing or decreasing.
**          KJ=0 or KJ=KN is returned to indicate that PX is out of range.
**    Args in -
**               PXX      - Monotonically ordered array
**               KN       - Dimension of PXX
**               PX       - Value whose position in PXX is required
**    Args out -
**               KJ       - Position of PX in PXX
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - ODFLXG
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading; taken from Numerical
**          Recipes, The art of scientific computing, section 3.4, by
**          Press, Flannery, Teukolsky & Vetterling, Cambridge University
**          Press, 1987, (where it is called LOCATE). Includes
**          modifications made by David Lary. (SMAP version)

      DIMENSION PXX(KN)

**    Initialize upper & lower limits.
      IJL=0
      IJU=KN+1
      DO WHILE(.TRUE.)
         IF(IJU-IJL.GT.1) THEN
            IJM=(IJU+IJL)/2
            IF(PXX(KN).GT.PXX(1).EQV.PX.GT.PXX(IJM)) THEN
               IJL=IJM
            ELSE
              IJU=IJM
            ENDIF
**          Repeat until the test condition is satisfied.
            GO TO 100
         ENDIF
**       Set the output.
         KJ=IJL
         RETURN
100      CONTINUE
      END DO

      END
      SUBROUTINE PROFIL(PX,K1DIM,PXPF,KPROF,PXLL,KLEV)
**    Function - to compute column profiles at specified horizontal
**          coordinates.
**    Args in -
**               PX      - 3D array from which the profiles will be
**                         extracted
**               K1DIM   - First dimension of PX
**               KPROF   - Number of profiles to be found
**               PXLL    - Latitude-longitude coordinate pairs
**               KLEV    - Number of levels in the data and in the
**                         profile
**    Args out -
**               PXPF    - Profiles at the specified coordinates
**    Args for work - none
**    Com used - /LEGAU/ALAT
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNHEM,JPJG,/PARAM2/JPMJP,JPJGL,
**          JPJGG,JPJGGP
**    Called by - GPOUT,COLTOT,TPOUT
**    Calls - ABORT,INTCOL
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      DIMENSION PX(K1DIM,JPJGG,KLEV),PXPF(KLEV,KPROF),
     -      PXLL(2,KPROF)
      LOGICAL LOEXTR

      IF(K1DIM.LT.JPMG) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***PROFIL: ERROR, K1DIM.LT.JPMG')
         CALL ABORT
      ENDIF

**    Precompute constants
      ZDLON=360.0/FLOAT(JPMG*JPMOCT)
      ZRANGE=360.0/FLOAT(JPMOCT)
      ZEPS=-0.00001

**    Loop over all the profiles
      DO 1000 JP=1,KPROF
      ZLAT=PXLL(1,JP)
      ZLONG=PXLL(2,JP)
      IF(JPMOCT.EQ.1.OR.JPMOCT.EQ.2) THEN
         ZLONG=AMOD(ZLONG+ZRANGE,ZRANGE)
      ENDIF
C      IF(ZLONG.GT.ZRANGE.OR.ZLONG.LT.0.0) THEN
C         WRITE(6,6020)ZLONG
C6020     FORMAT(1X,'***PROFIL: ERROR IN LONGITUDE VALUE : ',F10.2)
C         CALL ABORT
C      ENDIF
      IF(JPNHEM.EQ.1.AND.ZLAT.LT.ZEPS) THEN
         WRITE(6,6030)ZLAT
6030     FORMAT(1X,'***PROFIL: INVALID LATITUDE :',F10.2)
         CALL ABORT
      ENDIF

**    IWEST - gridline of PX data immediately to the west
**    IEAST - gridline of PX data immediately to the east
**    ZDIST - Profile is located a fraction ZDIST from the western
**    edge of the gridbox edge towards the eastern edge of the gridbox,
**    where 0<ZDIST<1
      IF(ZLONG.GT.ZRANGE-0.5*ZDLON) THEN
         IWEST=JPMG
         IEAST=1
         ZDIST=(ZLONG-ZRANGE+ZDLON)/ZDLON
      ELSE
         ICNT=0
         ZLONW=-ZDLON
         ZLONE=0.0
100      ICNT=ICNT+1
         ZLONW=ZLONW+ZDLON
         ZLONE=ZLONE+ZDLON
         IF((ZLONG.GE.ZLONW).AND.(ZLONG.LE.ZLONE)) THEN
            IWEST=ICNT
            IEAST=ICNT+1
            ZDIST=(ZLONG-ZLONW)/ZDLON
            GO TO 120
         ENDIF
         GO TO 100
      ENDIF
120   CONTINUE

**    LOEXTR - .TRUE. if north-south extrapolation will be required to
**    locate profile, else use interpolation. For extrapolation, ZLAT1
**    and ZLAT2 are the nearest (and next nearest) Gaussian latitudes to
**    ZLAT; for interpolation ZLAT1 and ZLAT2 are the Gaussian latitudes
**    to the north and the south of ZLAT. ISIGNn takes the value of
**    the Gaussian latitude counter (in the range 1 to JPJGG).

      ZLATN=90.0
      ZLATS=ALAT(1)
      IF(ZLAT.GE.ZLATS.AND.ZLAT.LE.ZLATN) THEN
         LOEXTR=.TRUE.
         ZLAT1=ALAT(1)
         ZLAT2=ALAT(2)
         ISIGN1=1
         ISIGN2=2
         GO TO 220
      ENDIF
      ZLATN=ZLATS
      DO 200 J=2,JPJGG
      ZLATS=ALAT(J)
      IF(ZLAT.GE.ZLATS.AND.ZLAT.LE.ZLATN) THEN
         LOEXTR=.FALSE.
         ZLAT1=ZLATN
         ZLAT2=ZLATS
         ISIGN1=J-1
         ISIGN2=J
         GO TO 220
      ENDIF
      ZLATN=ZLATS
200   CONTINUE
      IF(JPNHEM.EQ.2) THEN
         ZLATS=-90.0
      ELSE
         ZLATS=0.0
      ENDIF
      IF(ZLAT.GE.ZLATS.AND.ZLAT.LE.ZLATN) THEN
         LOEXTR=.TRUE.
         ZLAT1=ALAT(JPJGG)
         ZLAT2=ALAT(JPJGG-1)
         ISIGN1=JPJGG
         ISIGN2=JPJGG-1
         GO TO 220
      ENDIF
220   CONTINUE

**    Interpolate/extrapolate to find the column profile
      CALL INTCOL(PX,K1DIM,JPJGG,KLEV,PXPF(1,JP),LOEXTR,
     -      ZDIST,IWEST,IEAST,ISIGN1,ISIGN2,ZLAT1,ZLAT,ZLAT2)

1000  CONTINUE

      RETURN
      END
      SUBROUTINE RDGPTS(YPCP,YPCT,KCODE,PPFPR,K1DIM1,K1DIM2,K1DIM3,
     -         PPFUTF,K2DIM1,K2DIM2,K2DIM3,PCTPR,K3DIM1,K3DIM2,
     -         PCTUTF,K4DIM1,K4DIM2,KPPR,KPUTF,KCPR,KCUTF,KINDXT,
     -         K1PPR,K1PUTF,K1CPR,K1CUTF,KCHAN,KPDIM,PZDATA,PZDATAP)
**    Function - To read the contents of NCGPTS, NCTPTS or NCOPTS for a
**          particular field, and to construct
**          arrays containing the data that will be printed and used to
**          convert to time-series UTFs.
**    Args in -
**               YPCP    - character*7 flag to be matched if a record
**                         contains profile data
**               YPCT    - character*7 flag to be matched if a record
**                         contains column total data
**               KCODE   - Field number of required field
**               K1DIM1  - Dimension of PPFPR
**               K1DIM2  - Dimension of PPFPR
**               K1DIM3  - Dimension of PPFPR (profile counter)
**               K2DIM1  - Dimension of PPFUTF
**               K2DIM2  - Dimension of PPFUTF
**               K2DIM3  - Dimension of PPFUTF (profile counter)
**               K3DIM1  - Dimension of PCTPR
**               K3DIM2  - Dimension of PCTPR (profile counter)
**               K4DIM1  - Dimension of PCTUTF
**               K4DIM2  - Dimension of PCTUTF (profile counter)
**               KINDXT  - 1 or 2, indicating if output data arrays have
**                         time as the first or second dimension of 3D
**                         output arrays
**               KCHAN   - Channel containing required data to be read
**               KPDIM   - Number of profiles on each record
**    Args out -
**               PPFPR   - Array of profile data to be printed
**               PPFUTF  - Array of profile data to be passed to UTF
**               PCTPR   - Array of column total data to be printed
**               PCTUTF  - Array of column total data to be passed to
**                         UTF
**               KPPR    - Number of timesteps of data in PPFPR
**               KPUTF   - Number of timesteps of data in PPFUTF
**               KCPR    - Number of timesteps of data in PCTPR
**               KCUTF   - Number of timesteps of data in PCTUTF
**               K1PPR   - Timestep of first PPFPR data
**               K1PUTF  - Timestep of first PPFUTF data
**               K1CPR   - Timestep of first PCTPR data
**               K1CUTF  - Timestep of first PCTUTF data
**    Args for work - 
**               PZDATA  - Used to hold data
**               PZDATAP - used to hold data
**    Com used - /COMTIM/NSTART,NFREQP,NFREQA,/COMDAT/LWRITE,LASCII
**    Com changed - none
**    Params used - /PARAM1/JPNL,/PARAM3/JPGPPF,JPTPPF
**    Called by - OPSGTS,OPTRTS,OPODTS
**    Calls - none
**    Files read - KCHAN
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      DIMENSION PPFPR(K1DIM1,K1DIM2,K1DIM3),
     -      PPFUTF(K2DIM1,K2DIM2,K2DIM3),PCTPR(K3DIM1,K3DIM2),
     -      PCTUTF(K4DIM1,K4DIM2)
      CHARACTER*7 YPCP,YPCT,YOCHAR
      DIMENSION PZDATA(JPNL,KPDIM),PZDATAP(JPNL*KPDIM)
C      EQUIVALENCE (ZDATA(1,1),ZDATAP(1))
      LOGICAL LOPR,LOUTF

      REWIND KCHAN
**    The following counters keep track of the number of timesteps at
**    which information is copied to the output arrays
      IPFPR=0
      ICTPR=0
      IPFUTF=0
      ICTUTF=0

**    Preset initial time counters to zero
      K1PPR=0
      KICPR=0
      K1PUTF=0
      K1CUTF=0

**    INTnXX - stores previous time-interval between fields (n=1,2:
**    profile, column totals), (XX=PR,UTF: print array, UTF array)
      INT1PF=0
      INT1CT=0
      INT2PF=0
      INT2CT=0

10    CONTINUE
      READ(KCHAN,END=100)YOCHAR,ICODE,ISTEPT,PZDATA

      ICNT=0
      DO 500 JJ=1,KPDIM
      DO 500 JI=1,JPNL
      ICNT=ICNT+1
      PZDATAP(ICNT)=PZDATA(JI,JJ)
500   CONTINUE

      INCR=ISTEPT-NSTART
      IF(NFREQP.GT.0) THEN
         LOPR=LWRITE.AND.(INCR.EQ.NFREQP*(INCR/NFREQP))
      ELSE
         LOPR=.FALSE.
      ENDIF
      IF(NFREQA.GT.0) THEN
         LOUTF=LASCII.AND.(INCR.EQ.NFREQA*(INCR/NFREQA))
      ELSE
         LOUTF=.FALSE.
      ENDIF

**    Profiles
      IF((YOCHAR.EQ.YPCP).AND.(ICODE.EQ.KCODE)) THEN
**    Diagnostic type and field type match
         IF(LOPR) THEN
            IF((KINDXT.EQ.2.AND.IPFPR.EQ.K1DIM2).OR.
     -            (KINDXT.EQ.1.AND.IPFPR.EQ.K1DIM1)) THEN
               WRITE(6,6010)ISTEPT,KCODE
6010           FORMAT(1X,'***RDGPTS - PPFPR FULL, DATA NOT USED FOR ',
     -               'TIMESTEP, FIELD ',I12,I5)
               GO TO 110
            ENDIF
**          Copy data to print array
            IPFPR=IPFPR+1
            IF(IPFPR.EQ.1) K1PPR=ISTEPT
            IF(KINDXT.EQ.1) THEN
               DO 1010 JJ=1,K1DIM3
               DO 1010 JI=1,K1DIM2
               PPFPR(IPFPR,JI,JJ)=PZDATA(JI,JJ)
1010           CONTINUE
            ELSE
               DO 1000 JJ=1,K1DIM3
               DO 1000 JI=1,K1DIM2
               PPFPR(JI,IPFPR,JJ)=PZDATA(JI,JJ)
1000           CONTINUE
            ENDIF
**          Check time interval of data in PPFPR array
            IF(IPFPR.GT.1) THEN
               INTERV=ISTEPT-IST1PF
               IF(IPFPR.GT.2.AND.(INTERV.NE.INT1PF)) THEN
                  WRITE(6,6000)YOCHAR,ICODE,ISTEPT,ISTEPT-INTERV,
     -                  ISTEPT-INTERV-INT1PF
6000              FORMAT(1X,'***RDGPTS WARNING:',/10X,A7,
     -                  ' PROFILE PRINT FILE FOR ',
     -                  'FIELD ',I3,' HAS VARYING TIME INTERVAL;',
     -                  ' STEPS -',3I12)
               ENDIF
               INT1PF=INTERV
            ENDIF
            IST1PF=ISTEPT
         ENDIF

110      CONTINUE

         IF(LOUTF) THEN
            IF((KINDXT.EQ.2.AND.IPFUTF.EQ.K2DIM2).OR.
     -            (KINDXT.EQ.1.AND.IPFUTF.EQ.K2DIM1)) THEN
               WRITE(6,6020)ISTEPT,KCODE
6020           FORMAT(1X,'***RDGPTS - PPFUTF FULL, DATA NOT USED FOR ',
     -               'TIMESTEP, FIELD ',I12,I5)
               GO TO 120
            ENDIF
**          Copy data to UTF array
            IPFUTF=IPFUTF+1
            IF(IPFUTF.EQ.1) K1PUTF=ISTEPT
            IF(KINDXT.EQ.1) THEN
               DO 1110 JJ=1,K2DIM3
               DO 1110 JI=1,K2DIM2
               PPFUTF(IPFUTF,JI,JJ)=PZDATA(JI,JJ)
1110           CONTINUE
            ELSE
               DO 1100 JJ=1,K2DIM3
               DO 1100 JI=1,K2DIM2
               PPFUTF(JI,IPFUTF,JJ)=PZDATA(JI,JJ)
1100           CONTINUE
            ENDIF
**          Check time interval of data in PPFUTF array
            IF(IPFUTF.GT.1) THEN
               INTERA=ISTEPT-IST2PF
               IF(IPFUTF.GT.2.AND.(INTERA.NE.INT2PF)) THEN
                  WRITE(6,6030)YOCHAR,ICODE,ISTEPT,ISTEPT-INTERA,
     -                  ISTEPT-INTERA-INT2PF
6030              FORMAT(1X,'**RDGPTS WARNING:',/10X,A7,
     -                 ' PROFILE UTF FILE FOR FIELD ',I3,
     -                 ' HAS VARYING TIME INTERVAL; STEPS - ',3I12)
               ENDIF
               INT2PF=INTERA
            ENDIF
            IST2PF=ISTEPT
         ENDIF
      ENDIF
120   CONTINUE

**    Column totals
      IF((YOCHAR.EQ.YPCT).AND.(ICODE.EQ.KCODE)) THEN
**       Diagnostic type and field type match
         IF(LOPR) THEN
            IF(ICTPR.EQ.K3DIM1) THEN
               WRITE(6,6015)ISTEPT,KCODE
6015           FORMAT(1X,'***RDGPTS - PCTPR FULL, DATA NOT USED FOR ',
     -               'TIMESTEP, FIELD ',I12,I5)
               GO TO 115
            ENDIF
**          Copy data to print array
            ICTPR=ICTPR+1
            IF(ICTPR.EQ.1) K1CPR=ISTEPT
            DO 1015 JI=1,K3DIM2
            PCTPR(ICTPR,JI)=PZDATAP(JI)
1015        CONTINUE
**          Check time interval of data in PCTPR array
            IF(ICTPR.GT.1) THEN
               INTERV=ISTEPT-IST3CT
               IF(ICTPR.GT.2.AND.(INTERV.NE.INT3CT)) THEN
                  WRITE(6,6005)YOCHAR,ICODE,ISTEPT,ISTEPT-INTERV,
     -                  ISTEPT-INTERV-INT3CT
6005              FORMAT(1X,'***RDGPTS WARNING:',/10X,A7,
     -                  ' PROFILE TOTAL PRINT FILE FOR ',
     -                  'FIELD ',I3,' HAS VARYING TIME INTERVAL;',
     -                  ' STEPS -',3I12)
               ENDIF
               INT3CT=INTERV
            ENDIF
            IST3CT=ISTEPT
         ENDIF

115      CONTINUE

         IF(LOUTF) THEN
            IF(ICTUTF.EQ.K4DIM1) THEN
               WRITE(6,6025)ISTEPT,KCODE
6025           FORMAT(1X,'***RDGPTS - PCTUTF FULL, DATA NOT USED FOR ',
     -               'TIMESTEP, FIELD ',I12,I5)
               GO TO 125
            ENDIF
**          Copy data to UTF array
            ICTUTF=ICTUTF+1
            IF(ICTUTF.EQ.1) K1CUTF=ISTEPT
            DO 1115 JI=1,K4DIM2
            PCTUTF(ICTUTF,JI)=PZDATAP(JI)
1115        CONTINUE
**          Check time interval of data in PCTUTF array
            IF(ICTUTF.GT.1) THEN
               INTERA=ISTEPT-IST4CT
               IF(ICTUTF.GT.2.AND.(INTERA.NE.INT4CT)) THEN
                  WRITE(6,6035)YOCHAR,ICODE,ISTEPT,ISTEPT-INTERA,
     -                  ISTEPT-INTERA-INT4CT
6035              FORMAT(1X,'**RDGPTS WARNING:',/10X,A7,
     -                 ' PROFILE TOTAL UTF FILE FOR FIELD ',I3,
     -                 ' HAS VARYING TIME INTERVAL; STEPS - ',3I12)
               ENDIF
               INT4CT=INTERA
            ENDIF
            IST4CT=ISTEPT
         ENDIF
      ENDIF
125   CONTINUE

      GO TO 10

100   CONTINUE

**    End of file reached
      KCPR=ICTPR
      KCUTF=ICTUTF
      KPPR=IPFPR
      KPUTF=IPFUTF

**    Check data field size
      IF((KINDXT.EQ.2.AND.IPFPR.NE.K1DIM2).OR.
     -      (KINDXT.EQ.1.AND.IPFPR.NE.K1DIM1)) THEN
         WRITE(6,6310)KCODE,YPCP
6310     FORMAT(1X,'***RDGPTS: WARNING IPFPR<MAXIMUM TIME DIMENSION',
     -         ' FOR PROFILE FIELD ',I5,1X,A)
      ENDIF
      IF((KINDXT.EQ.2.AND.IPFUTF.NE.K2DIM2).OR.
     -      (KINDXT.EQ.1.AND.IPFUTF.NE.K2DIM1)) THEN
         WRITE(6,6300)KCODE,YPCP
6300     FORMAT(1X,'***RDGPTS: WARNING IPFUTF<MAXIMUM TIME DIMENSION',
     -         ' FOR PROFILE FIELD ',I5,1X,A)
      ENDIF
      IF(ICTPR.NE.K3DIM1) THEN
         WRITE(6,6315)KCODE,YPCT
6315     FORMAT(1X,'***RDGPTS: WARNING ICTPR<MAXIMUM TIME DIMENSION',
     -         ' FOR PROFILE TOTAL FIELD ',I5,1X,A)
      ENDIF
      IF(ICTUTF.NE.K4DIM1) THEN
         WRITE(6,6305)KCODE,YPCT
6305     FORMAT(1X,'***RDGPTS: WARNING ICTUTF<MAXIMUM TIME DIMENSION',
     -         ' FOR PROFILE TOTAL FIELD ',I5,1X,A)
      ENDIF

      RETURN
      END
      SUBROUTINE RDSGTS(YPCHAR,KCODE,KLEV,PPR,KIDIM1,KJDIM1,PPA,KIDIM2,
     -      KJDIM2,KTIMPR,KTIMPL,KINDXT,K1PR,K1UTF,KCHAN,KSIZE)
**    Function - To read the contents of NCGHTS, NCGZTS, NCGMTS,
**          NCTHTS, NCTZTS, NCTMTS, NCOHTS, NCOZTS, NCOMTS for a
**          particular field and diagnostic type, and to construct
**          arrays containing the data that will be printed and used to
**          convert to a UTF.
**    Args in -
**               YPCHAR  - character*4 flag indicating which diagnostic
**                         type is required
**               KCODE   - Field number of required field
**               KLEV    - Level number of the required field slice (1
**                         for surface fields)
**               KIDIM1  - Dimension of PPR
**               KJDIM1  - Dimension of PPR
**               KIDIM2  - Dimension of PPA
**               KJDIM2  - Dimension of PPA
**               KINDXT  - 1 or 2, indicating if PPR and PPA have time
**                         as the first or second dimension
**               KCHAN   - Channel containing required data to be read
**               KSIZE   - Either takes the value JPMG or the value
**                         JPJGG, the number of data elements to be read
**                         for the current type of slice (west-east or
**                         north-south)
**    Args out -
**               PPR     - Array of data values to be printed
**               PPA     - Array of data values to be passed to UTF
**               KTIMPR  - Number of timesteps of data in PPR
**               KTIMPL  - Number of timesteps of data in PPA
**               K1PR    - Timestep of first PPR data
**               K1UTF   - Timestep of first PPA data
**    Args for work - none
**    Com used - none
**    Com changed - /COMDAT/LWRITE,LASCII,/COMTIM/NFREQA,NFREQP,NSTART
**    Params used - /PARAM1/JPMG,/PARAM2/JPJGG
**    Called by - OPSGTS,OPTRTS,OPODTS
**    Calls - ABORT
**    Files read - KCHAN
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      DIMENSION PPR(KIDIM1,KJDIM1),PPA(KIDIM2,KJDIM2)
      CHARACTER*4 YPCHAR,YOCHAR
      DIMENSION ZDATA1(JPMG),ZDATA2(JPJGG)
      LOGICAL LOPR,LOUTF,LOLONG,LOLAT

**    Check the dimensions
      IF(KSIZE.EQ.JPMG) THEN
         LOLAT=.FALSE.
         LOLONG=.TRUE.
         IF(KINDXT.EQ.2) THEN
            IF((KIDIM1.NE.JPMG).OR.(KIDIM2.NE.JPMG)) THEN
               WRITE(6,6100)KIDIM1,KIDIM2,JPMG
6100           FORMAT(1X,'***RDSGTS: ERROR IN DIMENSIONS, KIDIM1,
     -               KIDIM2 AND JPMG = ',3I12)
               CALL ABORT
            ENDIF
         ELSE
            IF((KJDIM1.NE.JPMG).OR.(KJDIM2.NE.JPMG)) THEN
               WRITE(6,6110)KJDIM1,KJDIM2,JPMG
6110           FORMAT(1X,'***RDSGTS: ERROR IN DIMENSIONS, KJDIM1,
     -               KJDIM2 AND JPMG = ',3I12)
               CALL ABORT
            ENDIF
         ENDIF
      ELSE IF(KSIZE.EQ.JPJGG) THEN
         LOLAT=.TRUE.
         LOLONG=.FALSE.
         IF(KINDXT.EQ.2) THEN
            IF((KIDIM1.NE.JPJGG).OR.(KIDIM2.NE.JPJGG)) THEN
               WRITE(6,6105)KIDIM1,KIDIM2,JPJGG
6105           FORMAT(1X,'***RDSGTS: ERROR IN DIMENSIONS, KIDIM1,
     -               KIDIM2 AND JPJGG = ',3I12)
               CALL ABORT
            ENDIF
         ELSE
            IF((KJDIM1.NE.JPJGG).OR.(KJDIM2.NE.JPJGG)) THEN
               WRITE(6,6115)KJDIM1,KJDIM2,JPJGG
6115           FORMAT(1X,'***RDSGTS: ERROR IN DIMENSIONS, KJDIM1,
     -               KJDIM2 AND JPJGG = ',3I12)
               CALL ABORT
            ENDIF
         ENDIF
      ELSE
         WRITE(6,6120)KSIZE
6120     FORMAT(1X,'***RDSGTS: ERROR IN VALUE OF KSIZE ',I5)
         CALL ABORT
      ENDIF

**    LOLONG is .TRUE.: ZDATA1 used
**    LOLAT is .TRUE.: ZDATA2 used

      REWIND KCHAN
      IPR=0
      IUTF=0
      INTRAO=0
      INTERO=0

10    CONTINUE
      IF(LOLONG) THEN
         READ(KCHAN,END=100)YOCHAR,ICODE,ISTEPT,ILEV,ZDATA1
      ELSE IF(LOLAT) THEN
         READ(KCHAN,END=100)YOCHAR,ICODE,ISTEPT,ILEV,ZDATA2
      ENDIF

      IF((YOCHAR.EQ.YPCHAR).AND.(ICODE.EQ.KCODE)
     -      .AND.(ILEV.EQ.KLEV)) THEN
**       Diagnostic type and field type match
         INCR=ISTEPT-NSTART
         IF(NFREQP.GT.0) THEN
            LOPR=LWRITE.AND.(INCR.EQ.NFREQP*(INCR/NFREQP))
         ELSE
            LOPR=.FALSE.
         ENDIF
         IF(NFREQA.GT.0) THEN
            LOUTF=LASCII.AND.(INCR.EQ.NFREQA*(INCR/NFREQA))
         ELSE
            LOUTF=.FALSE.
         ENDIF

         IF(LOPR) THEN
            IF((KINDXT.EQ.2.AND.IPR.EQ.KJDIM1).OR.
     -            (KINDXT.EQ.1.AND.IPR.EQ.KIDIM1)) THEN
               WRITE(6,6010)ISTEPT,KCODE,KLEV
6010           FORMAT(1X,'***RDSGTS - PPR FULL, DATA NOT USED FOR ',
     -               'TIMESTEP, FIELD, LEVEL ',I12,2I5)
               GO TO 110
            ENDIF
**          Copy data to print array
            IPR=IPR+1
            IF(IPR.EQ.1) K1PR=ISTEPT
            IF(KINDXT.EQ.1) THEN
               IF(LOLONG) THEN
                  DO 1010 J=1,KJDIM1
                  PPR(IPR,J)=ZDATA1(J)
1010              CONTINUE
               ELSE IF(LOLAT) THEN
                  DO 1015 J=1,KJDIM1
                  PPR(IPR,J)=ZDATA2(J)
1015              CONTINUE
               ENDIF
            ELSE
               IF(LOLONG) THEN
                  DO 1000 J=1,KIDIM1
                  PPR(J,IPR)=ZDATA1(J)
1000              CONTINUE
               ELSE IF(LOLAT) THEN
                  DO 1005 J=1,KIDIM1
                  PPR(J,IPR)=ZDATA2(J)
1005              CONTINUE
               ENDIF
            ENDIF
**          Check time interval of data in PPR array
            IF(IPR.GT.1) THEN
               INTERV=ISTEPT-KSTEPO
               IF(IPR.GT.2.AND.(INTERV.NE.INTERO)) THEN
                  WRITE(6,6000)YOCHAR,ICODE,ILEV,ISTEPT,ISTEPT-INTERV,
     -                  ISTEPT-INTERV-INTERO
6000              FORMAT(1X,'***RDSGTS WARNING:',/10X,A4,
     -                  ' PR FILE FOR ',
     -                  'FIELD/LEVEL',2I3,' HAS VARYING TIME INTERVAL;',
     -                  ' STEPS -',3I12)
               ENDIF
               INTERO=INTERV
            ENDIF
            KSTEPO=ISTEPT
         ENDIF

110      CONTINUE

         IF(LOUTF) THEN
            IF((KINDXT.EQ.2.AND.IUTF.EQ.KJDIM2).OR.
     -            (KINDXT.EQ.1.AND.IUTF.EQ.KIDIM2)) THEN
               WRITE(6,6020)ISTEPT,KCODE,KLEV
6020           FORMAT(1X,'***RDSGTS - PPA FULL, DATA NOT USED FOR ',
     -               'TIMESTEP, FIELD, LEVEL ',I12,2I5)
               GO TO 120
            ENDIF
**          Copy data to UTF array
            IUTF=IUTF+1
            IF(IUTF.EQ.1) K1UTF=ISTEPT
            IF(KINDXT.EQ.1) THEN
               IF(LOLONG) THEN
                  DO 1110 J=1,KJDIM2
                  PPA(IUTF,J)=ZDATA1(J)
1110              CONTINUE
               ELSE IF(LOLAT) THEN
                  DO 1115 J=1,KJDIM2
                  PPA(IUTF,J)=ZDATA2(J)
1115              CONTINUE
               ENDIF
            ELSE
               IF(LOLONG) THEN
                  DO 1100 J=1,KIDIM2
                  PPA(J,IUTF)=ZDATA1(J)
1100              CONTINUE
               ELSE IF(LOLAT) THEN
                  DO 1105 J=1,KIDIM2
                  PPA(J,IUTF)=ZDATA2(J)
1105              CONTINUE
               ENDIF
            ENDIF
**          Check time interval of data in PPA array
            IF(IUTF.GT.1) THEN
               INTERA=ISTEPT-KSTPAO
               IF(IUTF.GT.2.AND.(INTERA.NE.INTRAO)) THEN
                  WRITE(6,6030)YOCHAR,ICODE,ILEV,ISTEPT,ISTEPT-INTERA,
     -                  ISTEPT-INTERA-INTRAO
6030              FORMAT(1X,'**RDSGTS WARNING:',/10X,A4,
     -                 ' UTF FILE FOR FIELD/LEVEL ',2I3,
     -                 ' HAS VARYING TIME INTERVAL; STEPS - ',3I12)
               ENDIF
               INTRAO=INTERA
            ENDIF
            KSTPAO=ISTEPT
         ENDIF
      ENDIF
120   CONTINUE
      GO TO 10

100   CONTINUE
**    End of file reached
      KTIMPR=IPR
      KTIMPL=IUTF
**    Check data field size
      IF((KINDXT.EQ.2.AND.IPR.NE.KJDIM1).OR.
     -      (KINDXT.EQ.1.AND.IPR.NE.KIDIM1)) THEN
         WRITE(6,6310)KCODE,YPCHAR,KLEV
6310     FORMAT(1X,'***RDSGTS: WARNING IPR<MAXIMUM TIME DIMENSION',
     -         ' FOR FIELD/LEVEL ',I5,1X,A,1X,I5)
      ENDIF
      IF((KINDXT.EQ.2.AND.IUTF.NE.KJDIM2).OR.
     -      (KINDXT.EQ.1.AND.IUTF.NE.KIDIM2)) THEN
         WRITE(6,6300)KCODE,YPCHAR,KLEV
6300     FORMAT(1X,'***RDSGTS: WARNING IUTF<MAXIMUM TIME DIMENSION',
     -         ' FOR FIELD/LEVEL ',I5,1X,A,1X,I5)
      ENDIF

      RETURN
      END
      SUBROUTINE SGTRAN(PSP,PGP,KLEV,KLAT,KTYPE,KCHAN)
**    Function - Indirect transform to obtain grid point from spectral
**          field
**    Args in -
**               PSP     - Complex array containing spectral data.
**               KLEV    - Number of levels in field.
**               KLAT    - If grid point data written to file (KCHAN>0),
**                         must be set to 1. If global gridpoint data
**                         returned in PGP array, must be JPJG.
**               KTYPE   - Type of indirect transform. Permissible
**                         values are
**                           1 or 2 : normal transform
**                           3 or 4 : y-derivative
**                           5 or 6 : del**(-2) transform
**                           7 or 8 : y-derivative of del**(-2)
**                         Odd/even value implies odd/even symmetry in
**                         the spectral field.
**               KCHAN   - Channel for grid point data.  If all JPJG
**                         latitudes returned in PGP array, use
**                         KCHAN<=0.
**    Args out -
**               PGP     - Real array of grid point data, or workspace
**                         array.
**    Args for work -
**               PGP     - Only used for work if KCHAN>1
**    Com used - /COMIOC/NCLEG,/COMFFT/WORK,TRIG,MFAX,/LEGAU/JINC
**    Com changed - /LEGAU/ALP,DALP,RLP,RDLP
**    Params used - /PARAM1/JPJG,JPNHEM,JPCRAY,JPJGL,JPMG,/PARAM2/
**          JPMGPP,JPIGC,JPIGA
**    Called by - none
**    Calls - ABORT,HEXP,FFT991(Library routine)
**    Files read - NCLEG
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      DIMENSION PGP(JPIGC*KLEV,KLAT)
      COMPLEX PSP(JPIGA*KLEV)

**    Check value of KLAT
      IF((KCHAN.LE.0.AND.KLAT.NE.JPJG).OR.
     -      (KCHAN.GT.0.AND.KLAT.NE.1)) THEN
         WRITE(6,6000)KCHAN,KLAT,JPJG
6000     FORMAT(1X,'SGTRAN: INCOMPATIBLE VALUES FOR KCHAN, KLAT AND ',
     -         'JPJG: ',3I6)
         CALL ABORT
      ENDIF

**    Set up number of single level Fourier transforms for batching.
      ITRSG=KLEV*JPNHEM
      ITSG=(ITRSG-1)/JPCRAY
      IRSTSG=ITRSG-JPCRAY*ITSG

**    Grid-point array is preset to zero in HEXP at each latitude.
**    No preset needed here.
**    Perform transform in latitude loop, reading Legendre functions
**    and writing grid-point data if required.
      IL=1
      IF(JPJGL.EQ.1) REWIND NCLEG
      ILGP=1
      IGPINC=1
      IF (KCHAN.GT.0) THEN
         IGPINC=0
         REWIND KCHAN
      ENDIF

      DO 30 JIH=1,JPJG
      IF (JPJGL.EQ.1) READ(NCLEG) ALP,DALP,RLP,RDLP
      IJH=JIH
      CALL HEXP(PSP,PGP(1,ILGP),KLEV,KTYPE,IL)

      IF (ITSG.NE.0) THEN
         DO 10 JI=1,ITSG
         CALL FFT991(PGP(1+(JI-1)*JPCRAY*JPMGPP,ILGP),WORK,TRIG,MFAX
     -         ,1,JPMGPP,JPMG,JPCRAY,1)
10       CONTINUE
      ENDIF
      CALL FFT991(PGP(1+ITSG*JPCRAY*JPMGPP,ILGP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,IRSTSG,1)

      IF (KCHAN.GT.0) WRITE(KCHAN) (PGP(I,ILGP),I=1,JPIGC*KLEV)
      IL=IL+JINC
      ILGP=ILGP+IGPINC
30    CONTINUE

      RETURN
      END
      SUBROUTINE SPFILT(PIN,KNWJ2,KNN,KMM,KMOCT,KHEM,KNL,KPAR,KTYPE,
     -      KCRIT,POUT,PZFILT)
**    Function -  General purpose spectral filtering and truncation
**          routine. Performs either triangular truncation at a given
**          total wavenumber or the isotropic filtering described in
**          Sardeshmukh & Hoskins (1984, Mon Wea Rev, 112, 2524-2529).
**          The input spectral array is assumed to use the jagged
**          triangular truncation of the Reading baroclinic spectral
**          models.
**    Args in -
**               PIN     - Complex array containing input spectral
**                         field. The truncation is assumed to be jagged
**                         triangular. I.e. symmetric (even) coefficients
**                         are included up to total wavenumber (KCRIT-1),
**                         while anti-symmetric (odd) coefficients are
**                         included up to wavenumber KCRIT.  This
**                         gives equal numbers of even and odd
**                         coefficients in the truncated series.  Ordering
**                         is of increasing total wavenumber within
**                         increasing zonal wavenumber.
**               KNWJ2   - First dimension of PIN and POUT: number of
**                         even or odd coeffs at a single level in the
**                         jagged triangular truncation.
**               KNN     - Highest total wavenumber of input truncation.
**               KMM     - Highest zonal wavenumber of input truncation.
**               KMOCT   - Symmetry in longitude.  Only zonal wavenumbers
**                         0,KMOCT,2*KMOCT,..,KMM are included in the
**                         input truncation.
**               KHEM    - Symmetry in latitude:
**                                 1 = hemispheric, only even or
**                                     odd coefficients included.
**                                 2 = global, both even and odd
**                                     coefficients included.
**               KNL     - Number of levels in vertical.
**               KPAR    - Parity of field:
**                            KPAR=even for even hemispherical symmetry,
**                            KPAR=odd  for odd hemispherical symmetry.
**               KTYPE   - Type of filtering required :
**                            =0  : Isotropic truncation at total wavenumber
**                                  KCRIT.
**                            >0  : Isotropic filter with response at total
**                                  wavenumber n given by
**                                  F(n) = exp - [ n*(n+1)/n0*(n0+1) ]**r
**                                  where r = KTYPE and n0 = KCRIT.
**                            <0  : Isotropic filter as above, but
**                                  F(n=KCRIT) = 0.1 and r = -KTYPE.
**                                  (n0 is computed rather than specified).
**              KCRIT   - Critical wavenumber for truncation / filtering.
**    Args in -
**              POUT    - Filtered spectral field.  Ordering of spectral
**                        coefficients is unchanged. Can be equivalenced
**                        to PIN via CALL statement if user requires
**                        overwriting of input field.
**             Other arguments unchanged.
**    Args for work - 
**              PZFILT  - Work array
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by -
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - M Blackburn, University of Reading (05.08.92). Modified
**          to meet UMAPLIB conventions by R Brugge, University of Reading
**          (04.11.94)

      COMPLEX PIN(KNWJ2,KHEM,KNL),POUT(KNWJ2,KHEM,KNL)
      DIMENSION PZFILT(KNN+1)

**    Set up filter coefficients.

      IF (KTYPE.EQ.0) THEN
**       Special case.  Triangular truncation at n=KCRIT.
         DO 10 JN=0,KCRIT
         PZFILT(JN+1)=1.0
10       CONTINUE
         DO 20 JN=KCRIT+1,KNN
         PZFILT(JN+1)=0.0
20       CONTINUE
      ELSE
**       Isotropic filter described in Sardeshmukh & Hoskins (1984).
**       f(n)=exp-[n(n+1)/n0(n0+1)]**r, where r=abs(itype).
         IORD=ABS(KTYPE)
         ZNZNCP=FLOAT(KCRIT*(KCRIT+1))
         IF (KTYPE.GT.0) THEN
**          Specify total wavenumber n0=ncrit for which response
**          function has a value exp(-1).
            ZN0N0P=ZNZNCP
         ELSE
**          Specify value of response function at total wavenumber
**          ncrit to be f(ncrit)=fncrit.  Wavenumber n0 is computed,
**          at which the value of the response function is exp(-1).
            ZFNC=0.1
            ZN0N0P=ZNZNCP/((-ALOG(ZFNC))**(1.0/FLOAT(IORD)))
         ENDIF
         DO 30 N=0,KNN
         PZFILT(N+1)=EXP(-((FLOAT(N*(N+1))/ZN0N0P)**IORD))
30       CONTINUE
      ENDIF

**    Apply filter.  INOF increases total wavenumber for anti-symmetric
**    coefficients.
      DO 100 JHEM=1,KHEM
      INOF=1-MOD(JHEM+KPAR,2)
      DO 100 JL=1,KNL
      I=0
      DO 100 JM=0,KMM,KMOCT
      DO 100 JN=JM,KNN-1,2
      I=I+1
      POUT(I,JHEM,JL)=PIN(I,JHEM,JL)*PZFILT(JN+1+INOF)
100   CONTINUE

**    Check that inner loop count is KNWJ2.
      IF (I.NE.KNWJ2) THEN
         PRINT *,' ***SPFILT: ERROR IN WAVENUMBER COUNTING: FINAL I = '
     -         ,I,' SHOULD EQUAL KNWJ2 = ',KNWJ2
         CALL ABORT
      ENDIF

      RETURN
      END
      SUBROUTINE TLABEL(PDAY1,PDAY2,PXUT,KLUTF)
**    Function - to calculate UTF time coordinates(labels) between
**          two specified day numbers inclusive
**    Args in -
**               PDAY1   - first day number in series
**               PDAY2   - last day number in series
**               KLUTF   - number of day values in series
**    Args out -
**               PXUT    - day numbers (equally-spaced)
**    Args for work - none
**    Com used - /COMTIM/NFREQA,TSPD
**    Com changed - none
**    Params used - none
**    Called by - OPPHTS,OPSGTS,OPTRTS,OPXPTS
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      DIMENSION PXUT(KLUTF)

      PXUT(1)=PDAY1
      IF(KLUTF.GT.1) THEN
         DO 100 J=2,KLUTF
         PXUT(J)=PXUT(J-1)+FLOAT(NFREQA)/TSPD
100      CONTINUE
      ENDIF
      IF(ABS(PXUT(KLUTF)-PDAY2).GT.0.000001) THEN
         WRITE(6,6000)PDAY2,PXUT(KLUTF)
6000     FORMAT(1X,'***TLABEL - ERROR IN PDAY2 ',F15.6,/
     -         ' WHICH SHOULD BE ',F15.6)
         CALL ABORT
      ENDIF

      RETURN
      END
      SUBROUTINE WELATR(PLAT,ALAT,PX,K1,K2,K3,PM)
**    Function - To extract a 2D west-east slice at a specified latitude
**          from a 3D array of data. Land/air masks are not employed,
**          and the routine does not distinguish 'underground' data.
**          The routine can cope with JPNHEM=1 OR 2.
**    Args in -
**               PLAT    - Latitude where data required
**               ALAT    - Latitudes where gridpoint data is known (deg)
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**    Args out -
**               PM      - Meridional slice at required latitude
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNHEM
**    Called by - PHINST,OPPHTD,GMOUT,TMOUT
**    Calls - ABORT,INTRNS,EXTRNS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      DIMENSION PX(K1,K2,K3),ALAT(K2),PM(K1,K3)

      IF(JPNHEM.EQ.1) THEN
         ZLATMN=0.0
         ZLATMX=90.0
      ELSE
         ZLATMN=-90.0
         ZLATMX=90.0
      ENDIF

**    Error checking
      IF(PLAT.LT.ZLATMN.OR.(PLAT.GT.ZLATMX)) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***WELAT: ERROR IN VALUE OF PLAT =', F12.5)
         CALL ABORT
      ENDIF


      ZLATN=90.0
      ZLATS=ALAT(1)
      IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
         DO 100 JK=1,K3
         CALL EXTRNS(PM(1,JK),PLAT,PX(1,1,JK),ALAT(1),
     -         PX(1,2,JK),ALAT(2),K1)
100      CONTINUE
         RETURN
      ENDIF

      ZLATN=ZLATS
      DO 400 J=2,K2
      ZLATS=ALAT(J)
      IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
         DO 200 JK=1,K3
         CALL INTRNS(PX(1,J-1,JK),ZLATN,PM(1,JK),PLAT,PX(1,J,JK),
     -         ZLATS,K1)
200      CONTINUE
         RETURN
      ENDIF
      ZLATN=ZLATS
400   CONTINUE

      IF(JPNHEM.EQ.2) THEN
**       Assume linear extrapolation wrt sine of latitude
         ZLATS=-90.0
         IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
            DO 300 JK=1,K3
            CALL EXTRNS(PM(1,JK),PLAT,PX(1,K2,JK),ALAT(K2),
     -            PX(1,K2-1,JK),ALAT(K2-1),K1)
300         CONTINUE
            RETURN
         ENDIF
      ELSE
**       Assume linear extrapolation wrt square of latitude - this
**       follows the convention in BGFLUX
         ZLATS=0.0
         IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
            ZP2=PLAT**2
            Z2LATN=ALAT(K2)**2
            Z2LATP=ALAT(K2-1)**2
            DO 500 JK=1,K3
            DO 500 JI=1,K1
            PM(JI,JK)=(PX(JI,K2,JK)*(ZP2-Z2LATP)+
     -            PX(JI,K2-1,JK)*(Z2LATN-ZP2))/
     -            (Z2LATN-Z2LATP)
500         CONTINUE
         ENDIF
      ENDIF

      END
      SUBROUTINE ZMEAN3(PX,K1,K2,K3,PZ,KXDAT,YPT,LPINST)
**    Function - To compute the zonal mean of a three-dimensional array
**    Args in -
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**               KXDAT   - Number of 'real' data values in first
**                         dimension
**               YPT     - CHARACTER*1, type of field
**                            'S' - surface field
**                            'F' - full level field
**                            'H' - half-level field
**                            'M' - masking field, use arithmetic mean
**               LPINST  - .TRUE. if PX is an instantaneous field, else
**                         time-averaged
**    Args out -
**               PZ      - Zonal mean of PX
**    Args for work - none
**    Com used - /COMAVG/NAVTYP,/COMIOC/NCGP,NCGPAV,/COMNGP/NR1ALM,
**          NR1TH,/COMMSK/AMSKV,/CURSGF/all elements
**    Com changed - /CWORK/WORK3D
**    Params used - /PARAM1/JPMG,JPNL,JPNHEM,/PARAM2/JPJGG,JPMGPP,
**          JPJGGP,/PARAM3/JPTRMX
**    Called by - GZOUT,HROUT,INIMSK,PHINST,OPPHTD,THOUT,TZOUT
**    Calls - ABORT
**    Files read - NCGP,NCGPAV
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LPINST
      CHARACTER*1 YPT
      DIMENSION PX(K1,K2,K3),PZ(K2,K3)
      DIMENSION ZMASK(JPMGPP,JPNHEM,JPNL),ZMZ(JPJGG,JPNL)
      EQUIVALENCE(ZMASK(1,1,1),WORK3D(1))

      ZK1=1.0/FLOAT(KXDAT)

**    Simple, arithmetic mean average
      IF(NAVTYP.EQ.1.OR.(YPT.EQ.'H').OR.(YPT.EQ.'S').OR.
     -         (YPT.EQ.'M')) THEN
         DO 100 JK=1,K3
         DO 200 J=1,K2
         PZ(J,JK)=SSUM(KXDAT,PX(1,J,JK),1)*ZK1
200      CONTINUE
100      CONTINUE
         RETURN
      ENDIF

**    Land/air mask-weighted average: NAVTYP=2
**    Sigma-weighted average: NAVTYP=3
      IF(NAVTYP.EQ.2.OR.NAVTYP.EQ.3) THEN
         IF((KXDAT.NE.JPMG).OR.(K2.NE.JPJGG).OR.(K3.NE.JPNL)) THEN
            WRITE(6,6000)
6000        FORMAT(1X,'***ZMEAN3 - INVALID DIMENSIONS FOR NAVTYP.NE.1,'
     -            ' ABORT CALLED')
            CALL ABORT
         ENDIF
         IF(LPINST) THEN
            ICHAN=NCGP(1)
         ELSE
            ICHAN=NCGPAV(1)
         ENDIF

         DO 1000 J=1,JPJG
         IF(NAVTYP.EQ.2) THEN
            READ(ICHAN,REC=NR1ALM+J-1) ZMASK
**          ZMASK contains number of data points at each level for
**          latitudes J and JPJGG+1-J
         ELSE
            READ(ICHAN,REC=NR1TH+J-1) ZMASK
**          ZMASK contains sigma function at each level for latitudes
**          J and JPJGG+J-1
         ENDIF
         IN=J
         IF(JPNHEM.EQ.2) IS=JPJGGP-J

         IF(JPNHEM.EQ.2) THEN
            DO 1100 JK=1,K3
            ZMZ(IN,JK)=SSUM(KXDAT,ZMASK(1,1,JK),1)
            ZMZ(IS,JK)=SSUM(KXDAT,ZMASK(1,2,JK),1)
1100        CONTINUE
            DO 1200 JI=1,JPMG
            DO 1200 JK=1,JPNL
            ZMASK(JI,1,JK)=ZMASK(JI,1,JK)*PX(JI,IN,JK)
            ZMASK(JI,2,JK)=ZMASK(JI,2,JK)*PX(JI,IS,JK)
1200        CONTINUE
            DO 1300 JK=1,K3
            PZ(IN,JK)=SSUM(KXDAT,ZMASK(1,1,JK),1)
            PZ(IS,JK)=SSUM(KXDAT,ZMASK(1,2,JK),1)
1300        CONTINUE
         ELSE
            DO 1101 JK=1,K3
            ZMZ(IN,JK)=SSUM(KXDAT,ZMASK(1,1,JK),1)
1101        CONTINUE
            DO 1201 JI=1,JPMG
            DO 1201 JK=1,JPNL
            ZMASK(JI,1,JK)=ZMASK(JI,1,JK)*PX(JI,IN,JK)
1201        CONTINUE
            DO 1301 JK=1,K3
            PZ(IN,JK)=SSUM(KXDAT,ZMASK(1,1,JK),1)
1301        CONTINUE
         ENDIF

1000     CONTINUE

**       Average = zonal mean of ZMASK*PX, divided by zonal mean
**             of ZMASK
         DO 1500 JK=1,K3
         DO 1500 J=1,K2
         IF(ZMZ(J,JK).EQ.0.0) THEN
**          PZ contains zero; set average to a large value
            PZ(J,JK)=AMSKV
         ELSE
            PZ(J,JK)=PZ(J,JK)/ZMZ(J,JK)
         ENDIF
1500     CONTINUE
         RETURN
      ENDIF

      RETURN
      END
      SUBROUTINE ZNGLBM(PZ,K2,K3,PG,PLVWT)
**    Function - To compute a global mean from a zonal mean, using a
**          weighting factor at each level in the vertical. Land/air
**          masks are not enployed and the routine cannot detect
**          'underground' data.
**    Args in -
**               PZ      - Zonal mean data array
**               K2      - First (latitude) data dimension
**               K3      - Second (vertical) data dimension
**               PLVWT   - Vertical weighting factor
**    Args out -
**               PG      - Global mean
**    Args for work - none
**    Com used - /LEGAU/GWT
**    Com changed - none
**    Params used - none
**    Called by - PHINST
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      DIMENSION PZ(K2,K3),PLVWT(K3)
      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)

      PG=0.0
      DO 100 JK=1,K3
      PG=PG+SDOT(K2,GWT,1,PZ(1,JK),1)*PLVWT(JK)
100   CONTINUE

      RETURN
      END
      SUBROUTINE ZNLEVM(PZONAL,K2,K3,PLEV)
**    Function - to create a level-mean array from a zonal array.
**          Land/air masks are not employed, and the routine cannot
**          distinguish 'underground' data.
**    Args in -
**               PZONAL  - Zonal data array
**               K2      - First (latitude) data dimension
**               K3      - Second (vertical) data dimension
**    Args out -
**               PLEV    - Level mean data array
**    Args for work - none
**    Com used - /LEGAU/GWT
**    Com changed - none
**    Params changed - none
**    Called by - XPINST,OPXPTD
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R.Brugge, University of Reading (SMAP version)

      DIMENSION PZONAL(K2,K3),PLEV(K3)
      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)

      DO 100 JK=1,K3
      PLEV(JK)=SDOT(K2,GWT,1,PZONAL(1,JK),1)
100   CONTINUE

      RETURN
      END
      SUBROUTINE ABORT
**    Function - to prematurely stop the job
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Called by - ALLCHP,AOUT14,AVFLGS,AWIL,COLSUM,
**          DATCHK,DECOMU,DEHEAP,DLSGCR,GETFIL,GSTRAN,GTRMSR,HANAL,
**          HEXP,INTERP,INTERT,INTREW,INTTH2,ITRACR,
**          LLCNVS,LMERGE,MERMN3,OMGCR,OPXPTD,PARCHK,PCOLOP,PHINIT,
**          PHTIME,PHYSEC,PHYSOP,PROFIL,PSGCE,PVCR,RDNPH4,
**          RDNXP2,RDSGTS,RDSPCF,RESEQ1,SGCONV,SGTRAN,THOUT,TLABEL,
**          TMOUT,TZOUT,UNPAKX,UTF14,WELATR,XPINST,XPTIME,ZMEAN3
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (Tested 21-07-92)

      STOP
      END
      SUBROUTINE ANALYS
**    Function - controls the time stepping during the analysis period
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMTIM/NSTART,NFREQD,TSPD,NFREQP,NFREQA,
**          /COMDAT/LWRITE,LASCII,YTYPSF,/DIAGTP/LDPH,LDXP,LDSG,LDTF,
**          LDOD,LDTJ,LDTR,LDZF/ODDIAG/LDODIN,/TJCNST/LATTTR,
**          /COMFLG/LGETSP,LGETTR,/ORDIAG/LMSKH,LMSKNS,LMSKWE,
**          /COMIOC/NCGP,/SGDIAG/LDSGIN,/TRDIAG/LDTRIN,/TFCNST/LTFTRC,
**          /ZFCNST/LZFTRC,/ZFDIAG/LDZFIN,/OUTCON/RNTAPE,
**          /MODELC/LHISPH,LHISXP,LDIABH,BEGDYP
**    Com changed - /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
**    Params used - /PARAM1/JPNL,JPJG/PARAM3/JPTFMX
**    Called by - MAINBF
**    Calls - PHYSOP,PHYSEC,RDSPCF,OPCOEF,SGFLUX,SGCALC,INIMSK,TRCALC,
**          ODCALC,ZFCALC,TJCTL,RCHECK,SKPHIS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,LQFLG
      COMMON /COMFLG/LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,
     -      LQFLG
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      LOGICAL LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN
      COMMON /ODDIAG/LDOH,LDOZ,LDOM,LDOP,LDO3,LDODTD,LDODTS,LDODIN,
     -      NCOD,NVODHR(JPNL),VODSFC(JPNL)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LFNDAT,LATTSG,LATTTR,LTJCPY,LTJINT,LNEWAT
      CHARACTER*50 YTJFLD
      COMMON /TJCNST/LFNDAT,LATTSG,LATTTR,LTJCPY,LTJINT,TJTTOL,
     -      LNEWAT(JPTJMX),NRECAT(JPTJMX),NTJOPC(JPTJMX),NBINSQ(JPTJMX),
     -      NCTJWK,NRTJWK(JPTJMX,2),YTJFLD(JPTJMX)
      LOGICAL LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN
      COMMON /TRDIAG/LDTH,LDTZ,LDTM,LDTP,LDT3,LDTRTD,LDTRTS,LDTRIN,
     -      NCTR,NVTRHR(JPNL),VTRSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LZFTRC,LDZFPR,LDZFPL,LZFGLB,LZFLEV
      CHARACTER*50 YNAMZF
      COMMON /ZFCNST/LZFTRC,LDZFPR(JPZFMX),LDZFPL(JPZFMX),LZFGLB,
     -      CIZF(JPZFMX),LZFLEV(JPNL),YNAMZF(2,JPZFMX)
      LOGICAL LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      COMMON /ZFDIAG/NCZF,NZFPR(JPZFMX),NZFPL(JPZFMX),
     -      CINTZF(JPZFMX),NVZFHR(JPNL),
     -      NZF,FACTZF(2,JPZFMX),NFLDZF(4,JPZFMX),VZFSFC(JPNL),
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      LOGICAL LOSG,LOTR,LOTF,LOOD,LOZF

**    NSTEPT will be used as 'current' timestep counter
      NSTEPT=NSTART-NFREQD

**    Start timestep of parameterisations
      IPBEG=BEGDYP*TSPD

**    Start of time loop
1000  CONTINUE
      write(4,*)'WIERD BUGFIX'

**    Specify time-dependent 'constants'
      NSTEPT=NSTEPT+NFREQD
      DAYT=NSTEPT/TSPD
      ISTEPS=NSTEPT-NSTART

**    Determine if printout or UTFs required this step
      IF(NFREQP.GT.0) THEN
         LTPRNT=LWRITE.AND.(ISTEPS.EQ.NFREQP*(ISTEPS/NFREQP))
      ELSE
         LTPRNT=.FALSE.
      ENDIF
      IF(NFREQA.GT.0) THEN
         LTASCI=LASCII.AND.(ISTEPS.EQ.NFREQA*(ISTEPS/NFREQA))
      ELSE
         LTASCI=.FALSE.
      ENDIF
      LTOUT=LTPRNT.OR.LTASCI

**    2-D lat-long and zonal parameterised tendencies are stored
**    first on the SGCM history file -- process these diagnostics
**    first

      IF(NSTEPT.GT.IPBEG) THEN
         CALL RCHECK(NCHIST,RNTAPE,NSTEPT,TSPD)
**       Uninterpolated fields retrieved and processed
         IF(LHISPH) THEN
            IF(LDPH) THEN
               CALL PHYSOP
            ELSE
**             Skip the unwanted uninterpolated data records
               CALL SKPHIS(JPJG)
            ENDIF
         ENDIF

**       Zonal mean parameterisation tendencies retrieved and processed
         IF(LHISXP) THEN
            IF(LDXP) THEN
               CALL PHYSEC
            ELSE
**             Skip the unwanted uninterpolated data records
               CALL SKPHIS(1)
            ENDIF
         ENDIF
      ENDIF

**    Perform diagnostics requiring spectral data
      IF(LGETSP.OR.LGETTR) THEN

**       Retrieve spectral data
         CALL RDSPCF

**       Print out the spectral coefficients for non-tracer fields
         IF(LGETSP.AND.LTPRNT.AND.LDCO) CALL OPCOEF

**       Convert spectral data to gridpoint format
         IF(LDSG.OR.LDTR.OR.LDTF.OR.LDOD.OR.LDZF.OR.LDTJ) THEN
            LOSG=LDSG
            LOTF=LDTF
            LOOD=LDOD
            LOZF=LDZF
            LOTR=LDTR.OR.LTFTRC.OR.LZFTRC.OR.(LDTJ.AND.LATTTR)
            CALL SGFLUX(LOSG,LOTR,LOTF,LOOD,LOZF)
         ENDIF

**       Create orographic masks for lat-long, zonal mean and
**       meridional mean fields
         IF(((LDSG.AND.LDSGIN).OR.(LDTR.AND.LDTRIN).OR.
     -         (LDOD.AND.LDODIN)).AND.
     -         YTYPSF.EQ.'IS'.AND.
     -         (LMSKH.OR.LMSKNS.OR.LMSKWE))
     -         CALL INIMSK(NCGP(2),NSTEPT,-1,DAYT,-1.0)

**       Diagnose gridpoint fields
         IF(LDSG) CALL SGCALC

**       End of diagnostics requiring spectral data

      ELSE
**       Skip unwanted spectral data
         IF(LDIABH)CALL SKPHIS(1)
         CALL SKPHIS(1)
      ENDIF

**    Return to top of time loop unless NEND has been reached
      IF(NSTEPT.LT.NEND) GO TO 1000
**    End of time loop

      RETURN
      END
      SUBROUTINE ENDOP
**    Function - to control any output production after the end of the
**          time loop
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /DIAGTP/LDPH,LDXP,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
**          /COMDAT/LWRITE,LASCII,/COMTRV/NTRCRS
**    Com changed - /VARTIM/LTPRNT,LTASCI,LTOUT
**    Params used - /PARAM2/JPIGB,JPIGD,/TRPTR,JPITR
**    Called by - MAINBF
**    Calls - DEHEAP,ENDPH,ENDXP,ENDSG,ENDTR,ENDTF,ENDOD,ENDZF,ENDTJ
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version))

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      COMPLEX TRCR
      POINTER (JPITRG,TRCRG(JPIGD,NTRCRS)),(JPITR,TRCR(JPIGB,NTRCRS))
      COMMON /TRPTR/JPITRG,JPITR
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT

      LTPRNT=LWRITE
      LTASCI=LASCII
      LTOUT=LTPRNT.OR.LTASCI

      IF(LTOUT) THEN
**       SG Diagnostics
         IF(LDSG) CALL ENDSG
**       PH diagnostics
         IF(LDPH) CALL ENDPH
**       XP diagnostics
         IF(LDXP) CALL ENDXP
**       TF diagnostics
         IF(LDTF) CALL ENDTF
      ENDIF

      RETURN
      END
      SUBROUTINE INIOP
**    Function - to control any output production before the
**          time loop; this must not require a knowledge of the
**          'current' time
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/LWRITE,LASCII,LROGR
**    Com changed - /VARTIM/LTPRNT,LTASCI,LTOUT
**    Params used - none
**    Called by - MAINBF
**    Calls - INIROG
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT

      LTPRNT=LWRITE
      LTASCI=LASCII
      LTOUT=LTPRNT.OR.LTASCI

**    Orography field retrieved, printed and/or plotted
      CALL INIROG

      IF(LTOUT) THEN
**       Currently, there are no initial data diagnostics other
**       orography which is output directly from INIROG
      ENDIF

      RETURN
      END
      SUBROUTINE ENDPH
**    Function - To control output of time-averaged PH diagnostics, of
**          the PH time-series, and of the instantaneous PH diagnostics
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /PHDIAG/LDPHTD,LDPHTS,/COMTIM/NSTART,NEND,
**          NFREQA,NFREQP
**    Com changed - none
**    Params used - /PARAM1/JPMG,/PARAM2/JPJGG,/PARAM3/JPPHMX
**    Called by - ENDOP
**    Calls - OPPHTD,OPPHTS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH

**    Time-averaged PH diagnostics from t=NSTART
      IF(LDPHTD) THEN
         CALL OPPHTD('LDPHTD')
      ENDIF

**    Time series PH diagnostics
      IF(LDPHTS) THEN
         IF(NFREQA.EQ.0) THEN
            ISTEPA=1
         ELSE
            ISTEPA=(NEND-NSTART)/NFREQA+1
         ENDIF
         IF(NFREQP.EQ.0) THEN
            ISTEPP=1
         ELSE
            ISTEPP=(NEND-NSTART)/NFREQP+1
         ENDIF
         IMG=JPMG
         IJGG=JPJGG
         CALL OPPHTS(ISTEPA,ISTEPP,IMG,IJGG)
      ENDIF

      RETURN
      END
      SUBROUTINE OPPHTD(YPTIME)
**    Function - Produces the time averaged PH output
**    Args in -
**               YPTIME  - Character*6 defining type of time averages
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCPHY3,NCUTF,/COMDAT/LWRITE,LASCII,
**          BEGDAY,ENDDAY,NASCII,NSIGFG,/PHCNST/NPHIDX,
**          MCODE,LDPHPL,LDPHPR,CIPH,YNAMPH,DFACPH,
**          /COMTIM/TSPD,NEND,NSTART,NFRACC,/PHDIAG/NCPH,LDPHLL,
**          LDPHZM,LDPHMM,LDPHGM,VPHEW,VPHEWA,VPHEWS,VPHNS,
**          VPHNSA,VPHNSS,VPHAA,VPHAS,/LEGAU/ALAT,ALATBY,
**          /COMMSK/AMSKV,/ACCPH/all elements
**    Com changed - /CWORK/WGP2D1,WGP2D2,WGP2D3,WGP2D4
**    Params used - /PARAM1/JPMG,JPNHEM,JPMOCT,/PARAM2/JPJGG,JPMGP,
**          JPJGGP,/PARAM3/JPPHMX
**    Called by - ENDPH
**    Calls - U14OUT,GLLOUT,ZMEAN3,GZMOUT,G14OUT,GMEAN3,
**          MERMN3,WELATR,GMMOUT,AWIL,NSLONR,SCOPY
**    Files read - NCPHY3
**    Files written - NCPH
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      CHARACTER*6 YPTIME,YOTITL
      CHARACTER*50 YONAME,YONAM
      LOGICAL LOUTF,LOPR
      DIMENSION ZX(JPMG,JPJGG),ZZONAL(JPJGG),ZMERID(JPMG)
      EQUIVALENCE (ZX(1,1),WGP2D1(1,1)),(ZZONAL(1),WGP2D2(1,1)),
     -      (ZMERID(1),WGP2D3(1,1))
      DIMENSION ZLONI(JPMGP),ZLONO(JPMGP),ZLATO(JPJGGP),ZDATAE(JPMG),
     -      ZDATAN(JPJGG)
      EQUIVALENCE (ZLONI(1),WGP2D2(1,1)),(ZLONO(1),WGP2D2(1,2)),
     -      (ZLATO(1),WGP2D3(1,1)),(ZDATAE(1),WGP2D4(1,1)),
     -      (ZDATAN(1),WGP2D4(1,1))
      DIMENSION ZMASK(JPMG,JPJGG)

**    Rewind scratch file before reading in the data
      REWIND NCPHY3

10    READ(NCPHY3,END=100)YOTITL,ICODE,ZX,INCNT
      IF(YOTITL.NE.YPTIME) GO TO 10
**    If INCNT is zero, no data available in the file for this field
      IF(INCNT.EQ.0) GO TO 10
      ITAB=0
110   CONTINUE
      ITAB=ITAB+1
      IF(ITAB.GT.JPPHMX) THEN
         WRITE(6,'('' ***OPPHTD: ERROR IN THE FIELD CODE '')')
         WRITE(6,'('' ***OPPHTD: TIME-AVERAGES NOT PRODUCED'',
     -      '' FOR ICODE='',/I4,A)')ICODE,YOTITL
         GO TO 10
      ENDIF
      IINDX=NPHIDX(ITAB)
      IF(IINDX.EQ.0) GO TO 10
      IF(MCODE(IINDX).NE.ICODE) GO TO 110

      IF(YPTIME.EQ.'LDPHTD') THEN
         ZSTART=BEGDAY
      ELSE
         WRITE(6,6200)YPTIME
6200     FORMAT(1X,'OPPHTD ERROR; ABORT DUE TO INVALID YPTIME:',A)
         CALL ABORT
      ENDIF
      ZEND=ENDDAY

**    Local variables for current field
      LOUTF=LDPHPL(ITAB).AND.LASCII
      LOPR=LDPHPR(ITAB).AND.LWRITE
      ZCI=CIPH(ITAB)
      YONAME=YNAMPH(ITAB)
      ZDFAC=DFACPH(ITAB)
      IDIMX=JPMG
      IDIMY=JPJGG
      ITFLAG=1
      IF(JPMOCT.EQ.1) THEN
         IPHTYP=1
         ZLONMX=360.0
      ELSE
         IPHTYP=3
         ZLONMX=360.0/(JPMOCT)
      ENDIF
      IF(JPNHEM.EQ.1) THEN
         ZAXMIN=0.0
         ZAXMAX=90.0
      ELSE
         ZAXMIN=-90.0
         ZAXMAX=90.0
      ENDIF

**    Compute time average of latitude-longitude field
      IF(YPTIME.EQ.'LDPHTD') THEN
         DO 1000 J=1,IDIMY
         DO 1000 JI=1,IDIMX
         ZX(JI,J)=ZX(JI,J)*ZDFAC/FLOAT(INCNT)
         ZMASK(JI,J)=1.0
1000     CONTINUE
      ENDIF

**    Output the 2D latitude-longitude fields
      IF(LDPHLL) THEN
         YONAM=YONAME
         YONAM(39:50)='    LAT-LONG'
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL U14OUT(ZX,IDIMX,IDIMY,IDIMX,IPHTYP,1,0,0,1,0,ZCI,
     -               JPNHEM,YONAM,50,NCUTF,NASCII,IFAIL,ZSTART,ZEND,
     -               ZX,ZX,' ',' ',1,1,ITFLAG,ZX)
            ENDIF
         ENDIF
         IF(LOPR) CALL GLLOUT(IDIMX,IDIMY,ZX,0.0,NSIGFG,-1,-1,NCPH,
     -         1,IDIMX,1,IDIMY,YONAM,ZSTART,ZEND)
      ENDIF

**    Zonal means
      IF(LDPHZM) THEN
         CALL ZMEAN3(ZX,IDIMX,IDIMY,1,ZZONAL,IDIMX,'S',.FALSE.)
         YONAM=YONAME
         YONAM(39:50)='  ZONAL MEAN'
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(ALAT,ZZONAL,IDIMY,1,31,0,0,1,2,ZAXMIN,
     -               ZAXMAX,YONAM,'Latitude (deg)','Zonal mean',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GZMOUT(IDIMY,1,ZZONAL,0.0,NSIGFG,-1,-1,NCPH,
     -         1,IDIMY,1,1,YONAM,ZSTART,ZEND,' ')
      ENDIF

**    Meridional means - weighted by area
      IF(LDPHMM) THEN
         CALL MERMN3(ZX,IDIMX,IDIMY,1,ZMERID,IDIMX,'S',.FALSE.)
         YONAM=YONAME
         YONAM(39:50)='  MERID.MEAN'
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(WGP2D4,ZMERID,IDIMX,1,31,0,0,1,1,
     -               0.0,ZLONMX,YONAM,'Longitude (deg)',
     -               'Meridional mean',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GMMOUT(IDIMX,1,ZMERID,0.0,NSIGFG,-1,-1,NCPH,
     -         1,IDIMX,1,1,YONAM,ZSTART,ZEND)
      ENDIF

**    Global mean
      IF(LDPHGM.AND.LOPR) THEN
         CALL GMEAN3(ZX,IDIMX,IDIMY,1,WGP2D3,ZGLOBM,1.0)
         YONAM=YONAME
         YONAM(39:50)='              '
         WRITE(NCPH,6000)ZSTART,ZEND
6000     FORMAT(1X,/' DAY ',F12.3,' - ',F12.3)
         WRITE(NCPH,6001)YONAM,ZGLOBM
6001     FORMAT(10X,'GLOBAL MEAN ',A50,E14.5)
      ENDIF

**    East-west slice of values at a specified latitude : use
**          d(field)/d(sin(latitude)) is constant
      IF(VPHEW.GT.-999.0) THEN
         CALL WELATR(VPHEW,ALAT,ZX,IDIMX,IDIMY,1,ZMERID)
         YONAM=YONAME
         WRITE(YONAM(39:50),'(''LAT. '',F5.1,2X)')VPHEW
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(WGP2D4,ZMERID,IDIMX,1,31,0,0,1,1,
     -               0.0,ZLONMX,YONAM,'Longitude (deg)',
     -               'Value',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GMMOUT(IDIMX,1,ZMERID,0.0,NSIGFG,-1,-1,NCPH,
     -         1,IDIMX,1,1,YONAM,ZSTART,ZEND)
      ENDIF

**    East-west slice of area-averaged values between two specified
**          latitudes - ZDATAE
      IF(VPHEWA(1).GT.-999.0.AND.VPHEWA(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(ZX,ILONI,ILATI,ALATBY,ALONBY,1,ZDATAE,ILONI,.FALSE.,
     -      ZMASK,AMSKV,ALONBY(1),ALONBY(JPMGP),VPHEWA(1),VPHEWA(2))
         YONAM=YONAME
         WRITE(YONAM(39:50),'(''AV'',F4.0,''/'',F4.0,''N'')')
     -         VPHEWA(1),VPHEWA(2)
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(WGP2D3,ZDATAE,ILONI,1,31,0,0,1,1,
     -               0.0,360.0,YONAM,'Longitude (deg)',
     -               'Value',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GMMOUT(ILONI,1,ZDATAE,0.0,NSIGFG,-1,-1,NCPH,
     -         1,ILONI,1,1,YONAM,ZSTART,ZEND)
      ENDIF

**    East-west slice of area-summed values between two specified
**          latitudes - ZDATAE
      IF(VPHEWS(1).GT.-999.0.AND.VPHEWS(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(ZX,ILONI,ILATI,ALATBY,ALONBY,1,ZDATAE,ILONI,.TRUE.,
     -      ZMASK,AMSKV,ALONBY(1),ALONBY(JPMGP),VPHEWS(1),VPHEWS(2))
         YONAM=YONAME
         WRITE(YONAM(39:50),'(''SU'',F4.0,''/'',F4.0,''N'')')
     -         VPHEWS(1),VPHEWS(2)
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(WGP2D3,ZDATAE,ILONI,1,31,0,0,1,1,
     -               0.0,360.0,YONAM,'Longitude (deg)',
     -               'Value',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GMMOUT(ILONI,1,ZDATAE,0.0,NSIGFG,-1,-1,NCPH,
     -         1,ILONI,1,1,YONAM,ZSTART,ZEND)
      ENDIF

**    North-south slice of values at a specified longitude : use
**          d(field)/d(longitude) is constant
      IF(VPHNS.GT.-999.0) THEN
         CALL NSLONR(VPHNS,JPMG,ZX,IDIMX,IDIMY,1,ZZONAL)
         YONAM=YONAME
         WRITE(YONAM(39:50),'(''LON. '',F5.1,2X)')VPHNS
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(ALAT,ZZONAL,IDIMY,1,31,0,0,1,2,
     -               ZAXMIN,ZAXMAX,YONAM,'Latitude (deg)',
     -               'Value',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GZMOUT(IDIMY,1,ZZONAL,0.0,NSIGFG,-1,-1,NCPH,
     -         1,IDIMY,1,1,YONAM,ZSTART,ZEND,' ')
      ENDIF

**    North-south slice of area-averaged values between two specified
**          longitudes - ZDATAN
      IF(VPHNSA(1).GT.-999.0.AND.VPHNSA(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(ZX,ILONI,ILATI,ALATBY,ALONBY,2,ZDATAN,ILATI,.FALSE.,
     -      ZMASK,AMSKV,VPHNSA(1),VPHNSA(2),ALATBY(1),ALATBY(JPJGGP))
         YONAM=YONAME
         WRITE(YONAM(39:50),'(''A'',I4,''/'',I4,''E'')')
     -         NINT(VPHNSA(1)),NINT(VPHNSA(2))
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(WGP2D3,ZDATAN,ILATI,1,31,0,0,1,2,
     -               -90.0,90.0,YONAM,'Latitude (deg)',
     -               'Value',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GZMOUT(ILATI,1,ZDATAN,0.0,NSIGFG,-1,-1,NCPH,
     -         1,ILATI,1,1,YONAM,ZSTART,ZEND,' ')
      ENDIF

**    North-south slice of area-summed values between two specified
**          longitudes - ZDATAN
      IF(VPHNSS(1).GT.-999.0.AND.VPHNSS(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(ZX,ILONI,ILATI,ALATBY,ALONBY,2,ZDATAN,ILATI,.TRUE.,
     -      ZMASK,AMSKV,VPHNSS(1),VPHNSS(2),ALATBY(1),ALATBY(JPJGGP))
         YONAM=YONAME
         WRITE(YONAM(39:50),'(''SU'',I4,''/'',I4,''E'')')
     -         NINT(VPHNSA(1)),NINT(VPHNSA(2))
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL G14OUT(WGP2D3,ZDATAN,ILATI,1,31,0,0,1,2,
     -               -90.0,90.0,YONAM,'Latitude (deg)',
     -               'Value',' ',
     -               ZSTART,ZEND,IFAIL,ITFLAG)
            ENDIF
         ENDIF
         IF(LOPR) CALL GZMOUT(ILATI,1,ZDATAN,0.0,NSIGFG,-1,-1,NCPH,
     -         1,ILATI,1,1,YONAM,ZSTART,ZEND,' ')
      ENDIF

**    Non-global area-averaged values between two specified
**          longitudes and latitudes
      IF(VPHAA(1).GT.-999.0.AND.VPHAA(2).GT.-999.0.AND.
     -      VPHAA(3).GT.-999.0.AND.VPHAA(4).GT.-999.0.AND.
     -      LOPR) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(ZX,ILONI,ILATI,ALATBY,ALONBY,3,ZAMEAN,1,.FALSE.,
     -      ZMASK,AMSKV,VPHAA(3),VPHAA(4),VPHAA(1),VPHAA(2))
         YONAM=YONAME
         YONAM(39:50)='              '
         WRITE(NCPH,6000)ZSTART,ZEND
         WRITE(NCPH,6010)VPHAA(1),VPHAA(2),VPHAA(3),VPHAA(4)
6010     FORMAT(10X,'LATITUDES ',F6.2,' - ',F6.2,/
     -         9X,'LONGITUDES ',F6.2,' - ',F6.2)
         WRITE(NCPH,6011)YONAM,ZAMEAN
6011     FORMAT(10X,'AREA MEAN FOR ',A50,E14.5)
      ENDIF

**    Non-global area-summed values between two specified
**          longitudes and latitudes
      IF(VPHAS(1).GT.-999.0.AND.VPHAA(2).GT.-999.0.AND.
     -      VPHAS(3).GT.-999.0.AND.VPHAS(4).GT.-999.0.AND.
     -      LOPR) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(ZX,ILONI,ILATI,ALATBY,ALONBY,3,ZASUM,1,.TRUE.,
     -      ZMASK,AMSKV,VPHAS(3),VPHAS(4),VPHAS(1),VPHAS(2))
         YONAM=YONAME
         YONAM(39:50)='              '
         WRITE(NCPH,6000)ZSTART,ZEND
         WRITE(NCPH,6010)VPHAS(1),VPHAS(2),VPHAS(3),VPHAS(4)
         WRITE(NCPH,6021)YONAM,ZASUM
6021     FORMAT(10X,'AREA SUM FOR ',A50,E14.5)
      ENDIF

**    Now read in the next field of data
      GO TO 10

100   CONTINUE
**    No more data on scratch file
      RETURN
      END
      SUBROUTINE OPPHTS(KSTEPU,KSTEPP,KMG,KJGG)
**    Function - To generate time-series PH output
**    Args in -
**               KSTEPU  - number of timesteps for which data on NCPHY4
**                         will be written to the UTF
**               KSTEPP  - number of timesteps for which data on NCPHY4
**                         will be printed
**               KMG     - maximum number of data values (=JPMG) per
**                         timestep written to scratch file NCPHY4.
**               KJGG    - number of data values (non-zero) written to a
**                         record of NCPHY4 containing zonal data
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/BEGDAY,LWRITE,LASCII,NSIGFG,LUTF14,
**          NASCII,/COMIOC/NCUTF,/COMTIM/TSPD,NFREQA,NFREQP,
**          /PHCNST/all elements,/LEGAU/ALAT
**          /PHDIAG/NPH,LDPHZM,NCPH,LDPHMM,LDPHGM,VPHEW,VPHEWA,VPHEWS,
**          VPHNS,VPHNSA,VPHNSS,VPHAA,VPHAS
**    Com changed - none
**    Params used - /PARAM3/JPPHMX,/PARAM1/JPMG,JPMOCT,JPNHEM
**    Called by - ENDPH
**    Calls - ALLCHP,DEHEAP,RDNPH4,U14OUT,GTZOUT,DEHEAP,G14OUT,
**          GMTOUT,GTSOUT,ATRUNC,MLABEL
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      DIMENSION ZLONG(JPMG)
      POINTER(IPPM,ZXPM(KMG,KSTEPP)),(IPUM,ZXUM(KMG,KSTEPU))
      POINTER(IPPZ,ZXPZ(KSTEPP,KJGG)),(IPUZ,ZXUZ(KSTEPU,KJGG))
      POINTER(IPPG,ZXPG(KSTEPP)),(IPUG,ZXUG(KSTEPU))
      POINTER(IPUT,ZXUT(KSTEPU))
      CHARACTER*6 YOCHAR
      CHARACTER*50 YONAM
      LOGICAL LOUTF,LOPR,LOUT

**    For each time-series an area of heap will be used to store the
**          data temporarily. Fortran unit NCPHY4 is read, record by
**          record, and arrays ZXP* and ZXU* are constructed; these
**          arrays are then used to produce printed and UTF output
**          respectively. *: M=meridional, Z=zonal, G=global, T=time.

**    Loop over all the MARS files
      DO 100 J=1,NPH
      INDX=NPHIDX(J)
      ICODE=MCODE(INDX)
      YONAM=YNAMPH(J)
      ZDFAC=DFACPH(J)
      ZCI=CIPH(J)
      LOPR=LWRITE.AND.LDPHPR(J)
      LOUTF=LASCII.AND.LDPHPL(J).AND.LUTF14
      LOUT=LOPR.OR.LOUTF
      ITFLAG=2

**    Zonal means
      IF(LDPHZM.AND.LOUT) THEN
         CALL ALLCHP(IPPZ,KJGG*KSTEPP,KERR)
         CALL ALLCHP(IPUZ,KJGG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='LDPHZM'
         CALL RDNPH4(YOCHAR,ICODE,ZXPZ,KSTEPP,KJGG,ZXUZ,KSTEPU,KJGG,
     -         KLPR,KLUTF,1,K1PR,K1UTF)
         YONAM(37:50)='T - ZONAL MEAN'
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=21
            IF(KLUTF.NE.KSTEPU) THEN
               CALL ATRUNC(ZXUZ,KSTEPU,KJGG,KLUTF,KJGG)
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL U14OUT(ZXUZ,KLUTF,KJGG,KLUTF,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZXUT,ALAT,'Time',
     -            'Latitude',4,8,ITFLAG,ZXUZ)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTZOUT(KSTEPP,KJGG,ZXPZ,0.0,NSIGFG,1,-1,
     -         NCPH,1,KLPR,1,KJGG,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPZ,KERR)
         CALL DEHEAP(IPUZ,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF

**    Meridional means
      IF(LDPHMM.AND.LOUT) THEN
         CALL ALLCHP(IPPM,KMG*KSTEPP,KERR)
         CALL ALLCHP(IPUM,KMG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='LDPHMM'
         CALL RDNPH4(YOCHAR,ICODE,ZXPM,KMG,KSTEPP,ZXUM,KMG,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         YONAM(37:50)='MERID.MEAN - T'
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=24
            IF(KLUTF.NE.KSTEPU) THEN
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
               CALL MLABEL(ZLONG,JPMG)
            ENDIF
            CALL U14OUT(ZXUM,KMG,KLUTF,KMG,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZLONG,ZXUT,
     -            'Longitude','Time',9,4,ITFLAG,ZXUM)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GMTOUT(KMG,KLPR,ZXPM,0.0,NSIGFG,-1,1,
     -         NCPH,1,KMG,1,KLPR,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPM,KERR)
         CALL DEHEAP(IPUM,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF

**    Global means
      IF(LDPHGM.AND.LOUT) THEN
         CALL ALLCHP(IPPG,KSTEPP,KERR)
         CALL ALLCHP(IPUG,KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='LDPHGM'
         CALL RDNPH4(YOCHAR,ICODE,ZXPG,1,KSTEPP,ZXUG,1,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         YONAM(37:50)='GLOB. MEAN - T'
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IFAIL=0
            IPTYP=31
            IXTYP=4
            ZXMIN=ZDAY1
            ZXMAX=ZDAY2
            IF(KLUTF.NE.KSTEPU) THEN
**             Fewer time points than in UTf header; need to specify
**             them in the current UTF field data
               IXTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL G14OUT(ZXUT,ZXUG,KLUTF,1,IPTYP,0,0,1,IXTYP,
     -            ZXMIN,ZXMAX,YONAM,'Time (days)','Global mean',' ',
     -            ZDAY1,ZDAY2,IFAIL,ITFLAG)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTSOUT(KLPR,ZXPG,0.0,NSIGFG,1,
     -         NCPH,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPG,KERR)
         CALL DEHEAP(IPUG,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF

**    West-east (Meridional) slice at specified latitude
      IF(VPHEW.GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPM,KMG*KSTEPP,KERR)
         CALL ALLCHP(IPUM,KMG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHEW '
         CALL RDNPH4(YOCHAR,ICODE,ZXPM,KMG,KSTEPP,ZXUM,KMG,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         WRITE(YONAM(37:50),'(''LAT. '',F5.1,'' - T'')')VPHEW
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=24
            IF(KLUTF.NE.KSTEPU) THEN
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
               CALL MLABEL(ZLONG,KMG)
            ENDIF
            CALL U14OUT(ZXUM,KMG,KLUTF,KMG,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZLONG,ZXUT,
     -            'Longitude','Time',9,4,ITFLAG,ZXUM)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GMTOUT(KMG,KLPR,ZXPM,0.0,NSIGFG,-1,1,
     -         NCPH,1,KMG,1,KLPR,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPM,KERR)
         CALL DEHEAP(IPUM,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF

**    West-east (Meridional) slice of area averaged values between two
**          specified latitude
      IF(JPMOCT.EQ.1.AND.JPNHEM.EQ.2) THEN
      IF(VPHEWA(1).GT.-999.0.AND.VPHEWA(2).GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPM,KMG*KSTEPP,KERR)
         CALL ALLCHP(IPUM,KMG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHEWA'
         CALL RDNPH4(YOCHAR,ICODE,ZXPM,KMG,KSTEPP,ZXUM,KMG,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         WRITE(YONAM(37:50),'(''AV'',F4.0,''/'',F4.0,''N-T'')')
     -         VPHEWA(1),VPHEWA(2)
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=24
            IF(KLUTF.NE.KSTEPU) THEN
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
               CALL MLABEL(ZLONG,KMG)
            ENDIF
            CALL U14OUT(ZXUM,KMG,KLUTF,KMG,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZLONG,ZXUT,
     -            'Longitude','Time',9,4,ITFLAG,ZXUM)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GMTOUT(KMG,KLPR,ZXPM,0.0,NSIGFG,-1,1,
     -         NCPH,1,KMG,1,KLPR,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPM,KERR)
         CALL DEHEAP(IPUM,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF
      ENDIF

**    West-east (Meridional) slice of area summed values between two
**          specified latitude
      IF(JPMOCT.EQ.1.AND.JPNHEM.EQ.2) THEN
      IF(VPHEWS(1).GT.-999.0.AND.VPHEWS(2).GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPM,KMG*KSTEPP,KERR)
         CALL ALLCHP(IPUM,KMG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHEWS'
         CALL RDNPH4(YOCHAR,ICODE,ZXPM,KMG,KSTEPP,ZXUM,KMG,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         WRITE(YONAM(37:50),'(''SU'',F4.0,''/'',F4.0,''N-T'')')
     -         VPHEWS(1),VPHEWS(2)
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=24
            IF(KLUTF.NE.KSTEPU) THEN
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
               CALL MLABEL(ZLONG,KMG)
            ENDIF
            CALL U14OUT(ZXUM,KMG,KLUTF,KMG,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZLONG,ZXUT,
     -            'Longitude','Time',9,4,ITFLAG,ZXUM)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GMTOUT(KMG,KLPR,ZXPM,0.0,NSIGFG,-1,1,
     -         NCPH,1,KMG,1,KLPR,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPM,KERR)
         CALL DEHEAP(IPUM,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF
      ENDIF

**    North-south (zonal) slice of values at a specified longitude
      IF(VPHNS.GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPZ,KJGG*KSTEPP,KERR)
         CALL ALLCHP(IPUZ,KJGG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHNS '
         CALL RDNPH4(YOCHAR,ICODE,ZXPZ,KSTEPP,KJGG,ZXUZ,KSTEPU,KJGG,
     -         KLPR,KLUTF,1,K1PR,K1UTF)
         WRITE(YONAM(37:50),'(''T - LON. '',F5.1)')VPHNS
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=21
            IF(KLUTF.NE.KSTEPU) THEN
               CALL ATRUNC(ZXUZ,KSTEPU,KJGG,KLUTF,KJGG)
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL U14OUT(ZXUZ,KLUTF,KJGG,KLUTF,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZXUT,ALAT,'Time',
     -            'Latitude',4,8,ITFLAG,ZXUZ)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTZOUT(KSTEPP,KJGG,ZXPZ,0.0,NSIGFG,1,-1,
     -         NCPH,1,KLPR,1,KJGG,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPZ,KERR)
         CALL DEHEAP(IPUZ,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF

**    North-south (zonal) slice of area-averaged values between two
**          specified longitude
      IF(JPMOCT.EQ.1.AND.JPNHEM.EQ.2) THEN
      IF(VPHNSA(1).GT.-999.0.AND.VPHNSA(2).GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPZ,KJGG*KSTEPP,KERR)
         CALL ALLCHP(IPUZ,KJGG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHNSA'
         CALL RDNPH4(YOCHAR,ICODE,ZXPZ,KSTEPP,KJGG,ZXUZ,KSTEPU,KJGG,
     -         KLPR,KLUTF,1,K1PR,K1UTF)
         WRITE(YONAM(37:50),'(''T-AV'',I4,''/'',I4,''E'')')
     -         NINT(VPHNSA(1)),NINT(VPHNSA(2))
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=21
            IF(KLUTF.NE.KSTEPU) THEN
               CALL ATRUNC(ZXUZ,KSTEPU,KJGG,KLUTF,KJGG)
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL U14OUT(ZXUZ,KLUTF,KJGG,KLUTF,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZXUT,ALAT,'Time',
     -            'Latitude',4,8,ITFLAG,ZXUZ)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTZOUT(KSTEPP,KJGG,ZXPZ,0.0,NSIGFG,1,-1,
     -         NCPH,1,KLPR,1,KJGG,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPZ,KERR)
         CALL DEHEAP(IPUZ,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF
      ENDIF

**    North-south (zonal) slice of area-summed values between two
**          specified longitudes
      IF(JPMOCT.EQ.1.AND.JPNHEM.EQ.2) THEN
      IF(VPHNSS(1).GT.-999.0.AND.VPHNSS(2).GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPZ,KJGG*KSTEPP,KERR)
         CALL ALLCHP(IPUZ,KJGG*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHNSS'
         CALL RDNPH4(YOCHAR,ICODE,ZXPZ,KSTEPP,KJGG,ZXUZ,KSTEPU,KJGG,
     -         KLPR,KLUTF,1,K1PR,K1UTF)
         WRITE(YONAM(37:50),'(''T-SU'',I4,''/'',I4,''E'')')
     -         NINT(VPHNSS(1)),NINT(VPHNSS(2))
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IPTYP=21
            IF(KLUTF.NE.KSTEPU) THEN
               CALL ATRUNC(ZXUZ,KSTEPU,KJGG,KLUTF,KJGG)
               IPTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL U14OUT(ZXUZ,KLUTF,KJGG,KLUTF,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZXUT,ALAT,'Time',
     -            'Latitude',4,8,ITFLAG,ZXUZ)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTZOUT(KSTEPP,KJGG,ZXPZ,0.0,NSIGFG,1,-1,
     -         NCPH,1,KLPR,1,KJGG,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPZ,KERR)
         CALL DEHEAP(IPUZ,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF
      ENDIF

**    Non-global area-averaged values
      IF(JPMOCT.EQ.1.AND.JPNHEM.EQ.2) THEN
      IF(VPHAA(1).GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPG,KSTEPP,KERR)
         CALL ALLCHP(IPUG,KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHAA '
         CALL RDNPH4(YOCHAR,ICODE,ZXPG,1,KSTEPP,ZXUG,1,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         WRITE(YONAM(35:50),'(''AV'',I3,I3,I4,I4)')
     -         NINT(VPHAA(1)),NINT(VPHAA(2)),NINT(VPHAA(3)),
     -         NINT(VPHAA(4))
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IFAIL=0
            IPTYP=31
            IXTYP=4
            ZXMIN=ZDAY1
            ZXMAX=ZDAY2
            IF(KLUTF.NE.KSTEPU) THEN
**             Fewer time points than in UTf header; need to specify
**             them in the current UTF field data
               IXTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL G14OUT(ZXUT,ZXUG,KLUTF,1,IPTYP,0,0,1,IXTYP,
     -            ZXMIN,ZXMAX,YONAM,'Time (days)','  Area mean',' ',
     -            ZDAY1,ZDAY2,IFAIL,ITFLAG)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTSOUT(KLPR,ZXPG,0.0,NSIGFG,1,
     -         NCPH,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPG,KERR)
         CALL DEHEAP(IPUG,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF
      ENDIF

**    Non-global area-summed values
      IF(JPMOCT.EQ.1.AND.JPNHEM.EQ.2) THEN
      IF(VPHAS(1).GT.-999.0.AND.LOUT) THEN
         CALL ALLCHP(IPPG,KSTEPP,KERR)
         CALL ALLCHP(IPUG,KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         YOCHAR='VPHAS '
         CALL RDNPH4(YOCHAR,ICODE,ZXPG,1,KSTEPP,ZXUG,1,KSTEPU,
     -         KLPR,KLUTF,2,K1PR,K1UTF)
         WRITE(YONAM(35:50),'(''SU'',I3,I3,I4,I4)')
     -         NINT(VPHAS(1)),NINT(VPHAS(2)),NINT(VPHAS(3)),
     -         NINT(VPHAS(4))
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IFAIL=0
            IPTYP=31
            IXTYP=4
            ZXMIN=ZDAY1
            ZXMAX=ZDAY2
            IF(KLUTF.NE.KSTEPU) THEN
**             Fewer time points than in UTf header; need to specify
**             them in the current UTF field data
               IXTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            ENDIF
            CALL G14OUT(ZXUT,ZXUG,KLUTF,1,IPTYP,0,0,1,IXTYP,
     -            ZXMIN,ZXMAX,YONAM,'Time (days)','  Area sum ',' ',
     -            ZDAY1,ZDAY2,IFAIL,ITFLAG)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTSOUT(KLPR,ZXPG,0.0,NSIGFG,1,
     -         NCPH,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPG,KERR)
         CALL DEHEAP(IPUG,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF
      ENDIF

100   CONTINUE

      RETURN
      END
      SUBROUTINE PHINIT(LPPH)
**    Function - To initialise arrays and constants required by PH
**          diagnostics
**    Args in -
**               LPPH    - .TRUE. if PH diagnostics are required
**    Args out -
**               LPPH    - may be reset to .FALSE. if errors are
**                         detected
**    Args for work - none
**    Com used - /COMDAT/LWRITE,LASCII,/PHDIAG/NPHPR,NPHPL,
**          LDPHIN,LDPHTS,LDPHTD,NPH,/INVAR/REFP0,CV,/COMTIM/TSPD,
**          NSTART,NFREQD,/COMIOC/NCHIST,/OUTCON/RNTAPE
**    Com changed - /PHCNST/all elements
**    Params used - /PARAM3/JPPHMX
**    Called by - DINIT
**    Calls - ABORT
**    Files read - NCHIST
**    Files written - none
**    Author - R Brugge, University of Reading, based on code written by
**          J Thuburn (SMAP version)

      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      DIMENSION ZDFAC(JPPHMX),ZPHDIM(JPPHMX)
      CHARACTER*50 YONAME(JPPHMX)
      LOGICAL LPPH,LOFLG

**    Accumulated fields (over the period between history dumps)
**    are denoted by '*'.
      DATA (YONAME(J),J=1,6)/
     -       ' SURFACE STRESS (INST)        Nm-2  '
     -      ,' SURFACE SENS.HEAT FLUX (INST)Wm-2  '
     -      ,' SURFACE LATENT HT FLUX (INST)Wm-2  '
     -      ,' CONVECTIVE PRECIPN (INST)  mm/day  '
     -      ,' LARGE SCALE PRECIPN (INST) mm/day  '
     -      ,' TOTAL PRECIPN (INST)       mm/day  '/

      DATA (YONAME(J),J=7,12)/
     -       '*SURFACE STRESS (AVER)        Nm-2  '
     -      ,'*SURFACE SENS.HEAT FLUX (AVER)Wm-2  '
     -      ,'*SURFACE LATENT HT FLUX (AVER)Wm-2  '
     -      ,'*CONVECTIVE PRECIPN (AVER)  mm/day  '
     -      ,'*LARGE SCALE PRECIPN (AVER  mm/day  '
     -      ,'*TOTAL PRECIPN (AVER)       mm/day  '/

**    MARS field codes
      DATA (MCODE(J),J=1,JPPHMX)/
     -       1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12/

**    Factors for changing from non-dimensional units used in history
**    file to MKS units (BUT METRES/DAY FOR RAINFALL)
      IJPHD2=JPPHMX/2
      DO 200 J=1,IJPHD2
      IF(J.EQ.1) THEN
         ZPHDIM(J)=REFP0
         ZPHDIM(J+IJPHD2)=REFP0
         ZDFAC(J)=1.0
         ZDFAC(J+IJPHD2)=1.0
      ELSE IF(J.EQ.2.OR.J.EQ.3) THEN
         ZPHDIM(J)=CV*REFP0
         ZPHDIM(J+IJPHD2)=CV*REFP0
         ZDFAC(J)=1.0
         ZDFAC(J+IJPHD2)=1.0
      ELSE
         ZPHDIM(J)=TSPD*0.001
         ZPHDIM(J+IJPHD2)=TSPD*0.001
         ZDFAC(J)=1000.0
         ZDFAC(J+IJPHD2)=1000.0
      ENDIF
200   CONTINUE

**    Uninterpolated diagnostics require LPPH=.TRUE.,
**          one of LWRITE and LASCII set to .TRUE., and
**          a valid field-type to process.
      IF((.NOT.LWRITE).AND.(.NOT.LASCII)) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***PHINIT: PH DIAGNOSTICS SWITCHED OFF SINCE ',
     -         'NO OUTPUT REQUESTED')
         LPPH=.FALSE.
      ENDIF
      IF((NPHPR(1).EQ.0).AND.(NPHPL(1).EQ.0)) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'***PHINIT: PH DIAGNOSTICS SWITCHED OFF SINCE ',
     -         'NO OUTPUT FIELD-TYPES DETECTED')
         LPPH=.FALSE.
      ENDIF
      IF((.NOT.LDPHIN).AND.(.NOT.LDPHTS).AND.(.NOT.LDPHTD)) THEN
         WRITE(6,6026)
6026     FORMAT(1X,'***PHINIT: PH DIAGNOSTICS SWITCHED OFF SINCE NO ',
     -         'TIME CONTROLS ARE SET')
         LPPH=.FALSE.
      ENDIF
      IF(NPH.EQ.0) THEN
         LPPH=.FALSE.
      ENDIF
      IF(.NOT.LPPH) THEN
         RETURN
      ENDIF

**    Now initialise PH diagnostics
      DO 100 JTAB=1,JPPHMX
      LDPHPR(JTAB)=.FALSE.
      LDPHPL(JTAB)=.FALSE.
      CIPH(JTAB)=-0.1
      NPHIDX(JTAB)=0
100   CONTINUE

**    Set up the tables for the requested fields
**    NPHIDX() gives the position of a requested field in the array
**          MCODE. IINDX gives the position of the array elements in the
**          tables.

      IINDX=0
**    Printing codes
      IOUT=0
101   CONTINUE
      IOUT=IOUT+1
      IF (IOUT.GT.NPH) GOTO 104
      ICODE=NPHPR(IOUT)
      IF (ICODE.EQ.0) GOTO 104
**    Search table for ICODE
      ITAB=0
102   CONTINUE
      ITAB=ITAB+1
      IF (ITAB.GT.JPPHMX) THEN
         WRITE(6,'('' ***PHINIT: UNKNOWN FIELD CODE REQUESTED - '')')
         WRITE(6,'('' NPHPR('',I6,'')='',I6)') IOUT,ICODE
         CALL ABORT
      ENDIF
      IF (MCODE(ITAB).NE.ICODE) GOTO 102
**    ICODE found in table
      IINDX=IINDX+1
      IF (IINDX.GT.NPH) THEN
         WRITE(6,'('' ***PHINIT: TOO MANY FIELDS REQUESTED '')')
         WRITE(6,'('' INCREASE THE SIZE OF NPH '')')
         CALL ABORT
      ENDIF
      LDPHPR(IINDX)=.TRUE.
      NPHIDX(IINDX)=ITAB
      GOTO 101
104   CONTINUE

**    Plotting codes
      IOUT=0
110   CONTINUE
      IOUT=IOUT+1
      IF (IOUT.GT.NPH) GOTO 114
      ICODE=NPHPL(IOUT)
      IF (ICODE.EQ.0) GOTO 114
**    Search table for ICODE
      ITAB=0
112   CONTINUE
      ITAB=ITAB+1
      IF (ITAB.GT.JPPHMX) THEN
         WRITE(6,'('' ***PHINIT: UNKNOWN FIELD CODE REQUESTED - '')')
         WRITE(6,'('' NPHPL('',I6,'')='',I6)') IOUT,ICODE
         CALL ABORT
      ENDIF
      IF (MCODE(ITAB).NE.ICODE) GOTO 112
**    ICODE found in table

**    Check to see if the field has already been processed (LOFLG=.T.)
**         or not (LOFLG=.F.)
      LOFLG=.FALSE.
      DO 116 JK=1,IINDX
      IF(NPHIDX(JK).EQ.ITAB) THEN
         LOFLG=LDPHPR(JK)
         IK1=JK
      ENDIF
116   CONTINUE
      IF (.NOT.LOFLG) THEN
         IINDX=IINDX+1
         IF (IINDX.GT.NPH) THEN
            WRITE(6,'('' ***PHINIT: TOO MANY FIELDS REQUESTED '')')
            WRITE(6,'('' INCREASE THE SIZE OF NPH '')')
            CALL ABORT
         ENDIF
         KK=IINDX
         NPHIDX(KK)=ITAB
      ELSE
         KK=IK1
      ENDIF

      LDPHPL(KK)=.TRUE.
      CIPH(KK)=CINTPH(IOUT)
      GOTO 110
114   CONTINUE

**    Check that NPH entries have been set
      DO 165 JK=1,NPH
      ITAB=NPHIDX(JK)
      IF(ITAB.EQ.0) THEN
         WRITE(6,6030)
6030     FORMAT(1X,' PHINIT***: LESS THAN NPH FIELDS REQUESTED')
         CALL ABORT
      ENDIF
165   CONTINUE

**    Set up the NPH elements of YNAMPH and DFACPH
      DO 170 JK=1,NPH
      ITAB=NPHIDX(JK)
      YNAMPH(JK)=YONAME(ITAB)
      DFACPH(JK)=ZDFAC(ITAB)
      PHDIM(JK)=ZPHDIM(ITAB)
170   CONTINUE

      RETURN
      END
      SUBROUTINE PHINST(PX,KDIMX,KDIMY,YPNAME,KINDX,KCODE)
**    Function - To perform the PH diagnostics for instantaneous fields
**          and to produce time series.
**    Args in -
**               PX      - Array containing instantaneous PH data for a
**                         single field; data runs from north pole to
**                         south pole in second dimension
**               KDIMX   - First dimension of PX (=JPMG)
**               KDIMY   - Second dimension of PX (=JPJG*JPNHEM)
**               YPNAME  - Character*50 title of field
**               KINDX   - Field code index for arrays LDPHPR, LDPHPL
**               KCODE   - Field code of PX
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/LUTF14,NSIGFG,NASCII
**          /PHDIAG/LDPHLL,NCPH,LDPHZM,VPHEW,VPHEWA,LDPHIN,LDPHTS,DFACPH,
**          LDPHMM,LDPHGM,VPHEWS,VPHNS,VPHNSA,VPHNSS,VPHAA,VPHAS,LDPHIN,
**          /VARTIM/DAYT,LTASCI,LTPRNT,NSTEPT,/COMIOC/NCUTF,NCPHY4,
**          /LEGAU/GWT,ALATBY,ALONBY,/PHCNST/LDPHPR,LDPHPL,CIPH,
**          /COMMSK/AMSKV
**    Com changed - /CWORK/WGP2D1,WGP2D2,WGP2D3
**    Params used - JPPAD1,JPPAD2,JPPAD3,/PARAM1/JPMG,JPNHEM,JPJG,JPMOCT,
**          /PARAM2/JPJGG,JPMGPP,JPJGGP,JPMGP
**    Called by - PHYSOP
**    Calls - U14OUT,GLLOUT,AWIL,WELATR,NSLONR,
**          ZMEAN3,MERMM3,ZNGLBM,MRGLBM,GMEAN3,G14OUT,GZMOUT,GMMOUT
**    Files read - none
**    Files written - NCPHY4,NCPH
**    Variables equivalenced thro call - (PX,WGP2D2)
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      PARAMETER(JPPAD1=JPMG,JPPAD2=JPJGG,JPPAD3=JPMG+JPJGG-1)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION PX(KDIMX,KDIMY)
      DIMENSION ZZONAL(JPJGG),ZMERID(JPMG)
      DIMENSION ZLONI(JPMGP),ZLONO(JPMGP),ZDATAE(JPMG),
     -      ZDATAN(JPJGG),ZLATO(JPJGGP)
      CHARACTER*50 YPNAME,YONAME
      EQUIVALENCE (ZZONAL(1),WGP2D3(1,1)),
     -      (ZMERID(1),WGP2D3(1,4)),(ZLONI(1),WGP2D1(1,1)),
     -      (ZLONO(1),WGP2D1(1,2)),(ZDATAE(1),WGP2D3(1,1))
      DIMENSION ZMASK(JPMG,JPJGG)
      DIMENSION ZPAD1(JPPAD1),ZPAD2(JPPAD2),ZPAD3(JPPAD3)
      SAVE ZPAD1,ZPAD2,ZPAD3
      DATA ZPAD1/JPPAD1*0.0/,ZPAD2/JPPAD2*0.0/,ZPAD3/JPPAD3*0.0/
      LOGICAL LOUTF,LOPR

**    ZPAD1, ZPAD2 and ZPAD3 are used to pad out the length of the
**    contents of each record of NCPHY4 to the same length (ie to
**    JPMG+JPJGG)

**    Note that PX is ordered from north to south pole
      YONAME=YPNAME
      LOPR=LTPRNT.AND.LDPHPR(KINDX)
      LOUTF=LTASCI.AND.LDPHPL(KINDX)
      ITFLAG=0
      IF(JPMOCT.EQ.1) THEN
         IPTYPH=1
         ZLONMX=360.0
      ELSE
         IPTYPH=3
         ZLONMX=360.0/(JPMOCT)
      ENDIF
      IF(JPNHEM.EQ.1) THEN
         ZAXMIN=0.0
         ZAXMAX=90.0
      ELSE
         ZAXMIN=-90.0
         ZAXMAX=90.0
      ENDIF

**    Convert PH field to output units
      DO 500 J=1,KDIMY
      DO 500 JI=1,KDIMX
      PX(JI,J)=PX(JI,J)*DFACPH(KINDX)
      ZMASK(JI,J)=1.0
500   CONTINUE

**    2D latitude-longitude fields
      IF(LDPHLL.AND.LDPHIN) THEN
            YONAME(37:50)='      LAT-LONG'
         IF(LOUTF) THEN
            IF(LUTF14) THEN
               CALL U14OUT(PX,KDIMX,KDIMY,KDIMX,IPTYPH,1,0,0,1,
     -               0,CIPH(KINDX),JPNHEM,YONAME,50,NCUTF,
     -               NASCII,IFAIL,DAYT,-1.0,PX,PX,' ',' ',1,1,ITFLAG,PX)
            ENDIF
         ENDIF
         IF(LOPR) CALL GLLOUT(KDIMX,KDIMY,PX,0.0,NSIGFG,-1,-1,NCPH,
     -         1,KDIMX,1,KDIMY,YONAME,DAYT,-1.0)
      ENDIF

**    All the following results are stored temporarily on NCPHY4 until
**          the end of the time analysis loop. The written arrays
**          contain no extra gridpoints in the any direction.

**    Zonal means
      IF(LDPHZM) THEN
         CALL ZMEAN3(PX,KDIMX,KDIMY,1,ZZONAL,KDIMX,'S',.TRUE.)
         IF(LDPHTS)WRITE(NCPHY4)'LDPHZM',KCODE,NSTEPT,ZZONAL,ZPAD1
         IF(LDPHIN) THEN
            YONAME(39:50)='  ZONAL MEAN'
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(ALAT,ZZONAL,KDIMY,1,31,0,0,1,2,ZAXMIN,
     -                  ZAXMAX,YONAME,'Latitude (deg)','Zonal mean',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GZMOUT(KDIMY,1,ZZONAL,0.0,NSIGFG,-1,-1,NCPH,
     -            1,KDIMY,1,1,YONAME,DAYT,-1.0,' ')
         ENDIF
      ENDIF

**    Meridional means - weighted by area
      IF(LDPHMM) THEN
         CALL MERMN3(PX,KDIMX,KDIMY,1,ZMERID,KDIMX,'S',.TRUE.)
         IF(LDPHTS)WRITE(NCPHY4)'LDPHMM',KCODE,NSTEPT,ZMERID,ZPAD2
         IF(LDPHIN) THEN
            YONAME(39:50)='  MERID.MEAN'
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(WGP2D1,ZMERID,KDIMX,1,31,0,0,1,1,
     -                  0.0,ZLONMX,YONAME,'Longitude (deg)',
     -                  'Meridional mean',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GMMOUT(KDIMX,1,ZMERID,0.0,NSIGFG,-1,-1,NCPH,
     -            1,KDIMX,1,1,YONAME,DAYT,-1.0)
         ENDIF
      ENDIF

**    Global mean
      IF(LDPHGM) THEN
         IF(LDPHZM) THEN
            CALL ZNGLBM(ZZONAL,KDIMY,1,ZGLOBM,1.0)
         ELSE IF(LDPHMM) THEN
            CALL MRGLBM(ZMERID,KDIMX,1,ZGLOBM,1.0)
         ELSE
            CALL GMEAN3(PX,KDIMX,KDIMY,1,WGP2D3,ZGLOBM,1.0)
         ENDIF
         IF(LDPHTS)WRITE(NCPHY4)'LDPHGM',KCODE,NSTEPT,ZGLOBM,ZPAD3
         IF(LDPHIN.AND.LOPR) THEN
            YONAME(39:50)='              '
            WRITE(NCPH,6000)DAYT
6000        FORMAT(1X,/' DAY ',F12.3)
            WRITE(NCPH,6001)YONAME,ZGLOBM
6001        FORMAT(10X,'GLOBAL MEAN FOR ',A50,E14.5)
         ENDIF
      ENDIF

**    East-west slice of values at a specified latitude : use
**          d(field)/d(sin(latitude)) is constant
      IF(VPHEW.GT.-999.0) THEN
         CALL WELATR(VPHEW,ALAT,PX,KDIMX,KDIMY,1,ZMERID)
         IF(LDPHTS)WRITE(NCPHY4)'VPHEW ',KCODE,NSTEPT,ZMERID,ZPAD2
         IF(LDPHIN) THEN
            WRITE(YONAME(39:50),'(''LAT. '',F5.1,2X)')VPHEW
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(WGP2D1,ZMERID,KDIMX,1,31,0,0,1,1,
     -                  0.0,ZLONMX,YONAME,'Longitude (deg)',
     -                  'Value',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GMMOUT(KDIMX,1,ZMERID,0.0,NSIGFG,-1,-1,NCPH,
     -            1,KDIMX,1,1,YONAME,DAYT,-1.0)
         ENDIF
      ENDIF

**    East-west slice of area-averaged values between two specified
**          latitudes
      IF(VPHEWA(1).GT.-999.0.AND.VPHEWA(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(PX,ILONI,ILATI,ALATBY,ALONBY,1,ZDATAE,ILONI,.FALSE.,
     -      ZMASK,AMSKV,ALONBY(1),ALONBY(JPMGP),VPHEWA(1),VPHEWA(2))
         IF(LDPHTS)WRITE(NCPHY4)'VPHEWA',KCODE,NSTEPT,ZDATAE,ZPAD2
         IF(LDPHIN) THEN
            WRITE(YONAME(39:50),'(''AV'',F4.0,''/'',F4.0,''N'')')
     -            VPHEWA(1),VPHEWA(2)
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(WGP2D3,ZDATAE,ILONI,1,31,0,0,1,1,
     -                  0.0,360.0,YONAME,'Longitude (deg)',
     -                  'Value',' ',DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GMMOUT(ILONI,1,ZDATAE,0.0,NSIGFG,-1,-1,NCPH,
     -            1,ILONI,1,1,YONAME,DAYT,-1.0)
         ENDIF
      ENDIF

**    East-west slice of area-summed values between two specified
**          latitudes
      IF(VPHEWS(1).GT.-999.0.AND.VPHEWS(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(PX,ILONI,ILATI,ALATBY,ALONBY,1,ZDATAE,ILONI,.TRUE.,
     -      ZMASK,AMSKV,ALONBY(1),ALONBY(JPMGP),VPHEWS(1),VPHEWS(2))
         IF(LDPHTS)WRITE(NCPHY4)'VPHEWS',KCODE,NSTEPT,ZDATAE,ZPAD2
         IF(LDPHIN) THEN
            WRITE(YONAME(39:50),'(''SU'',F4.0,''/'',F4.0,''N'')')
     -            VPHEWS(1),VPHEWS(2)
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(WGP2D3,ZDATAE,ILONI,1,31,0,0,1,1,
     -                  0.0,360.0,YONAME,'Longitude (deg)',
     -                  'Value',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GMMOUT(ILONI,1,ZDATAE,0.0,NSIGFG,-1,-1,NCPH,
     -            1,ILONI,1,1,YONAME,DAYT,-1.0)
         ENDIF
      ENDIF

**    North-south slice of values at a specified longitude : use
**          d(field)/d(longitude) is constant
      IF(VPHNS.GT.-999.0) THEN
         CALL NSLONR(VPHNS,JPMG,PX,KDIMX,KDIMY,1,ZZONAL)
         IF(LDPHTS)WRITE(NCPHY4)'VPHNS ',KCODE,NSTEPT,ZZONAL,ZPAD1
         IF(LDPHIN) THEN
            WRITE(YONAME(39:50),'(''LON. '',F5.1,2X)')VPHNS
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(ALAT,ZZONAL,KDIMY,1,31,0,0,1,2,
     -                  ZAXMIN,ZAXMAX,YONAME,'Latitude (deg)',
     -                  'Value',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GZMOUT(KDIMY,1,ZZONAL,0.0,NSIGFG,-1,-1,NCPH,
     -            1,KDIMY,1,1,YONAME,DAYT,-1.0,' ')
         ENDIF
      ENDIF

**    North-south slice of area-averaged values between two specified
**          longitudes
      IF(VPHNSA(1).GT.-999.0.AND.VPHNSA(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(PX,ILONI,ILATI,ALATBY,ALONBY,2,ZDATAN,ILATI,.FALSE.,
     -      ZMASK,AMSKV,VPHNSA(1),VPHNSA(2),ALATBY(1),ALATBY(JPJGGP))
         IF(LDPHTS)WRITE(NCPHY4)'VPHNSA',KCODE,NSTEPT,ZDATAN,ZPAD1
         IF(LDPHIN) THEN
            WRITE(YONAME(39:50),'(''AV'',I4,''/'',I4,''E'')')
     -            NINT(VPHNSA(1)),NINT(VPHNSA(2))
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(WGP2D3,ZDATAN,ILATI,1,31,0,0,1,2,
     -                  -90.0,90.0,YONAME,'Latitude (deg)',
     -                  'Value',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GZMOUT(ILATI,1,ZDATAN,0.0,NSIGFG,-1,-1,NCPH,
     -            1,ILATI,1,1,YONAME,DAYT,-1.0,' ')
         ENDIF
      ENDIF

**    North-south slice of area-summed values between two specified
**          longitudes
      IF(VPHNSS(1).GT.-999.0.AND.VPHNSS(2).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(PX,ILONI,ILATI,ALATBY,ALONBY,2,ZDATAN,ILATI,.TRUE.,
     -      ZMASK,AMSKV,VPHNSS(1),VPHNSS(2),ALATBY(1),ALATBY(JPJGGP))
         IF(LDPHTS)WRITE(NCPHY4)'VPHNSS',KCODE,NSTEPT,ZDATAN,ZPAD1
         IF(LDPHIN) THEN
            WRITE(YONAME(39:50),'(''SU'',I4,''/'',I4,''E'')')
     -            NINT(VPHNSS(1)),NINT(VPHNSS(2))
            IF(LOUTF) THEN
               IF(LUTF14) THEN
                  CALL G14OUT(WGP2D3,ZDATAN,ILATI,1,31,0,0,1,2,
     -                  -90.0,90.0,YONAME,'Latitude (deg)',
     -                  'Value',' ',
     -                  DAYT,-1.0,IFAIL,ITFLAG)
               ENDIF
            ENDIF
            IF(LOPR) CALL GZMOUT(ILATI,1,ZDATAN,0.0,NSIGFG,-1,-1,NCPH,
     -            1,ILATI,1,1,YONAME,DAYT,-1.0,' ')
         ENDIF
      ENDIF

**    Non-global area-averaged values between two specified
**          longitudes and latitudes
      IF(VPHAA(1).GT.-999.0.AND.VPHAA(2).GT.-999.0.AND.
     -      VPHAA(3).GT.-999.0.AND.VPHAA(4).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(PX,ILONI,ILATI,ALATBY,ALONBY,3,ZAMEAN,1,.FALSE.,
     -      ZMASK,AMSKV,VPHAA(3),VPHAA(4),VPHAA(1),VPHAA(2))
         IF(LDPHTS)WRITE(NCPHY4)'VPHAA ',KCODE,NSTEPT,ZAMEAN,ZPAD3
         IF(LDPHIN.AND.LOPR) THEN
            YONAME(39:50)='            '
            WRITE(NCPH,6000)DAYT
            WRITE(NCPH,6010)VPHAA(1),VPHAA(2),VPHAA(3),VPHAA(4)
6010        FORMAT(10X,'LATITUDES ',F6.2,' - ',F6.2,/
     -            9X,'LONGITUDES ',F6.2,' - ',F6.2)
            WRITE(NCPH,6011)YONAME,ZAMEAN
6011        FORMAT(10X,'AREA MEAN FOR ',A50,E14.5)
         ENDIF
      ENDIF

**    Non-global area-summed values between two specified
**          longitudes and latitudes
      IF(VPHAS(1).GT.-999.0.AND.VPHAA(2).GT.-999.0.AND.
     -      VPHAS(3).GT.-999.0.AND.VPHAS(4).GT.-999.0) THEN
         ILONI=JPMG
         ILATI=JPJGG
         CALL AWIL(PX,ILONI,ILATI,ALATBY,ALONBY,3,ZASUM,1,.TRUE.,
     -      ZMASK,AMSKV,VPHAS(3),VPHAS(4),VPHAS(1),VPHAS(2))
         IF(LDPHTS)WRITE(NCPHY4)'VPHAS ',KCODE,NSTEPT,ZASUM,ZPAD3
         IF(LDPHIN.AND.LOPR) THEN
            YONAME(39:50)='            '
            WRITE(NCPH,6000)DAYT
            WRITE(NCPH,6010)VPHAS(1),VPHAS(2),VPHAS(3),VPHAS(4)
            WRITE(NCPH,6021)YONAME,ZASUM
6021        FORMAT(10X,'AREA SUM FOR ',A50,E14.5)
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE PHYSOP
**    Function - To control the step-by-step processing of the lat-long
**          uninterpolated fields
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /PHCNST/NPHIDX,PHDIM,YNAMPH,/VARTIM/LTOUT,
**          /COMIOC/NCHIST,/PHDIAG/LDPHIN,LDPHTS,LDPHTD,NPH
**    Com changed - /CWORK/WGP2D2,/COMIOC/NCPHY3,NCPHY5
**    Params used - /PARAM1/JPMG,JPNHEM,JPJG,JPNHEM,/PARAM2/JPJGG,
**          JPMGPP,JPJGGP,/PARAM3/JPPHMX
**    Called by - ANALYS
**    Calls - ABORT,PHINST,PHTIME
**    Files read - NCHIST
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      PARAMETER(JPPHD2=(JPPHMX-2)/2)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LOFLG
      DIMENSION ZGPV(JPMGPP,JPNHEM,JPJG,JPPHD2,2)
      DIMENSION ZX(JPMG,JPJGG)
      EQUIVALENCE (ZX(1,1),WGP2D2(1,1))

**    Read in the lat-long data - note that the order in which the fields
**    are read in (as defined by JK and JT must correspond to the titles
**    as specified for YONAME in routine PHINIT)
      DO 10 J=1,JPJG
      READ(NCHIST) ZKOUNT,ZMTAPE,ZDAY,ZRNR,((((ZGPV(JI,JHEM,J,JK,JT),
     -      JI=1,JPMGPP),JHEM=1,JPNHEM),JK=1,JPPHD2),JT=2,1,-1),
     -      ZMTAP1
      IF (NINT(ZRNR).NE.J) THEN
         WRITE(6,6900) ZDAY,NINT(ZRNR),J
6900     FORMAT(' ***ABORT IN PHYSOP AT DAY',F10.2,
     -         ' : LATITUDE COUNTER IN DATA =',I5,'  NOT',I5)
         CALL ABORT
      ENDIF
      IF(ZMTAPE.NE.ZMTAP1) THEN
         WRITE(6,6901)
6901     FORMAT(' ***ABORT IN PHYSOP AT DAY',F10.2,' : ',
     -         '/ ZMTAPE VARIATION ON HISTORY TAPE SUGGESTS SMAP ',
     -         'PARAMETERS ARE INVALID')
         CALL ABORT
      ENDIF
10    CONTINUE
      WRITE(6,6000)ZKOUNT,ZDAY
6000  FORMAT(1X,'PHYSOP: DATA READ FOR STEP ',F12.1,' DAY ',F10.2)

**    Process each field in turn
      DO 100 JF=1,JPPHMX
**    Firstly, check that diagnostics for the field are requested - this
**    means that the array NPHIDX contains the value J (=MCODE(J))
      LOFLG=.FALSE.
      DO 110 JC=1,NPH
      IF(JF.EQ.NPHIDX(JC)) THEN
**       Use JF to mean that the JF'th array in the history data list
**       (as read in loop 10 above)
**       is required, and that this corresponds to the ITAB'th elements
**       of NPHIDX, YNAMPH, LDPHPR/L etc.
         ITAB=JC
         LOFLG=.TRUE.
      ENDIF
110   CONTINUE
      IF(.NOT.LOFLG) GO TO 100

**    Secondly, extract data from ZGPV array and convert to MKS values
      IF(YNAMPH(ITAB)(1:1).EQ.'*') THEN
         IT=2
         IF=JF-JPPHMX/2
      ELSE
         IT=1
         IF=JF
      ENDIF
      IF(YNAMPH(ITAB)(2:14).NE.'TOTAL PRECIPN') THEN
         DO 200 JL=1,JPJG
         DO 201 JH=1,JPNHEM
         ILAT=(2-JH)*JL+(JH-1)*(JPJGGP-JL)
         DO 202 JI=1,JPMG
         ZX(JI,ILAT)=ZGPV(JI,JH,JL,IF,IT)*PHDIM(ITAB)
202      CONTINUE
201      CONTINUE
200      CONTINUE
      ELSE
         DO 300 JL=1,JPJG
         DO 301 JH=1,JPNHEM
         ILAT=(2-JH)*JL+(JH-1)*(JPJGGP-JL)
         DO 302 JI=1,JPMG
         ZX(JI,ILAT)=(ZGPV(JI,JH,JL,IF-1,IT)+ZGPV(JI,JH,JL,IF-2,IT))
     -         *PHDIM(ITAB)
302      CONTINUE
301      CONTINUE
300      CONTINUE
      ENDIF

**    Time average calculations
      IF(LDPHTD) THEN
         IDIM=JPMG*JPNHEM*JPJG
         ICODE=NPHIDX(ITAB)
         CALL PHTIME(ZX,IDIM,ICODE)
      ENDIF

**    Instantaneous fields and time-series
      IF((LDPHIN.OR.LDPHTS).AND.LTOUT) THEN
         IDIM1=JPMG
         IDIM2=JPJGG
         CALL PHINST(ZX,IDIM1,IDIM2,YNAMPH(ITAB),ITAB,NPHIDX(ITAB))
      ENDIF

100   CONTINUE

      REWIND NCPHY3
      REWIND NCPHY5

**    Switch channels for next read/write READ/WRITE of time-averaged data
      ICHNL2=NCPHY3
      NCPHY3=NCPHY5
      NCPHY5=ICHNL2

      RETURN
      END
      SUBROUTINE PHTIME(PX,KDIM,KCODE)
**    Function - To perform the PH calculations for time averages
**    Args in -
**               PX      - Array containing  PH data for a
**                         single field at current time
**               KDIM    - Total dimension of PX
**               KCODE   - Field code of input array PX
**    Args out - none
**    Args for work - none
**    Com used - /VARTIM/NSTEPT,/COMTIM/NSTART,/COMIOC/NCPHY3,NCPHY5,
**          /PHDIAG/LDPHTD,/PHCNST/NPHIDX,/ACCPH/all elements
**    Com changed - /CWORK/WGP2D3
**    Params used - /PARAM1/JPMG,/PARAM2/JPJGG,/PARAM3/JPPHMX
**    Called by - PHYSOP
**    Calls - ABORT,ISRCHEQ,SCOPY
**    Files read - NCPHY3
**    Files written - NCPHY5
**    Variables equivalenced thro call - (PX,WGP2D2)
**    Author - R Brugge, University of Reading. (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDPHPR,LDPHPL
      CHARACTER*50 YNAMPH
      COMMON /PHCNST/LDPHPR(JPPHMX),LDPHPL(JPPHMX),MCODE(JPPHMX),
     -      DFACPH(JPPHMX),CIPH(JPPHMX),NPHIDX(JPPHMX),PHDIM(JPPHMX),
     -      YNAMPH(JPPHMX)
      LOGICAL LDPHLL,LDPHZM,LDPHMM,LDPHGM,LDPHTD,LDPHIN,LDPHTS
      COMMON /PHDIAG/NCPH,NPHPR(JPPHMX),NPHPL(JPPHMX),
     -      CINTPH(JPPHMX),LDPHLL,LDPHZM,LDPHMM,LDPHGM,
     -      LDPHTD,LDPHIN,VPHEW,VPHEWA(2),VPHEWS(2),VPHNS,
     -      VPHNSA(2),VPHNSS(2),VPHAA(4),VPHAS(4),LDPHTS,NPH
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION PX(KDIM)
      DIMENSION ZXD(JPMG*JPJGG)
      CHARACTER*6 YOTITL
      LOGICAL LORWND
      EQUIVALENCE (ZXD(1),WGP2D3(1,1))

      IF(KDIM.NE.JPMG*JPJGG) THEN
         WRITE(6,6000)KDIM,JPMG*JPJGG
6000     FORMAT(1X,'PHTIME: ERROR IN ARRAY DIMENSIONS; ',
     -         ' KDIM = ',I5,' JPMG*JPJGG = ',I5,/
     -         ' ABORT CALLED')
         CALL ABORT
      ENDIF

      IF(NSTEPT.EQ.NSTART) THEN
**       Assign zero values
         IF(LDPHTD) THEN
            DO 200 J=1,JPMG*JPJGG
            ZXD(J)=0.0
200         CONTINUE
            ICNTD=0
         ENDIF
      ELSE
**       Read in the work data, and check that it corresponds to PX
170      CONTINUE
         IF(LDPHTD) THEN
            LORWND=.FALSE.
            READ(NCPHY3,END=150)YOTITL,ICODE,ZXD,ICNTD
            IF(KCODE.EQ.ICODE.AND.YOTITL.EQ.'LDPHTD') GO TO 160
            GO TO 170
150         IF(LORWND) THEN
               WRITE(6,6010)
6010           FORMAT(1X,'***PHTIME TD: SCRATCH FIELD NOT FOUND')
               CALL ABORT
            ENDIF
            REWIND NCPHY3
            LORWND=.TRUE.
            GO TO 170
         ENDIF
      ENDIF
160   CONTINUE

**    Time averages from t=NSTART to t=NEND timesteps
      DO 250 J=1,JPJGG*JPMG
      ZXD(J)=ZXD(J)+PX(J)
250   CONTINUE
      ICNTD=ICNTD+1


**    Write out the work data
      IF(LDPHTD) WRITE(NCPHY5)'LDPHTD',KCODE,ZXD,ICNTD

      RETURN
      END
      SUBROUTINE RDNPH4(YPCHAR,KCODE,PPR,KIDIM1,KJDIM1,PPA,KIDIM2,
     -      KJDIM2,KTIMPR,KTIMPL,KINDXT,K1PR,K1UTF)
**    Function - To read the contents of NCPHY4 for a particular field
**          and diagnostic type, and to construct arrays containing the
**          data that will be printed and used to convert to a UTF.
**    Args in -
**               YPCHAR  - character*6 flag indicating which diagnostic
**                         type is required
**               KCODE   - MARS field code of required field
**               KIDIM1  - Dimension of PPR
**               KJDIM1  - Dimension of PPR
**               KIDIM2  - Dimension of PPA
**               KJDIM2  - Dimension of PPA
**               KINDXT  - 1 or 2, indicating if PPR and PPA have time
**                         as the first or second dimension
**    Args out -
**               PPR     - Array of data values to be printed
**               PPA     - Array of data values to be passed to UTF
**               KTIMPR  - Number of timesteps of data in PPR
**               KTIMPL  - Number of timesteps of data in PPA
**               K1PR    - Timestep of first PPR data
**               K1UTF   - Timestep of first PPA data
**    Args for work - none
**    Com used - /COMIOC/NCPHY4,/COMTIM/NFREQP,NFREQA,NSTART,
**          /COMDAT/LASCII,LWRITE
**    Com changed - none
**    Params used - /PARAM1/JPMG
**    Called by - OPPHTS
**    Calls - ABORT
**    Files read - NCPHY4
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      DIMENSION PPR(KIDIM1,KJDIM1),PPA(KIDIM2,KJDIM2)
      CHARACTER*6 YPCHAR,YOCHAR
      DIMENSION ZDATA(JPMG+JPJGG)
      LOGICAL LOPR,LOUTF

**    Check the dimensions
      IF(KINDXT.EQ.2) THEN
         IF(((KIDIM1.GT.JPMG).OR.(KIDIM2.GT.JPMG)).AND.
     -         ((KIDIM1.GT.JPJGG).OR.(KIDIM2.GT.JPJGG))) THEN
            WRITE(6,6100)KIDIM1,KIDIM2,JPMG,JPJGG
6100        FORMAT(1X,'***RDNPH4: ERROR IN DIMENSIONS, KIDIM1,KIDIM2',
     -            ' AND JPMG, JPJGG = ',4I12)
            CALL ABORT
         ENDIF
      ELSE
         IF(((KJDIM1.GT.JPMG).OR.(KJDIM2.GT.JPMG)).AND.
     -         ((KJDIM1.GT.JPJGG).OR.(KJDIM2.GT.JPJGG))) THEN
            WRITE(6,6110)KJDIM1,KJDIM2,JPMG,JPJGG
6110        FORMAT(1X,'***RDNPH4: ERROR IN DIMENSIONS, KJDIM1,KJDIM2',
     -            ' AND JPMG,JPJGG = ',4I12)
            CALL ABORT
         ENDIF
      ENDIF

      REWIND NCPHY4
      IPR=0
      IUTF=0
      INTRAO=0
      INTERO=0

10    CONTINUE
      READ(NCPHY4,END=100)YOCHAR,ICODE,ISTEPT,ZDATA
      IF((YOCHAR.EQ.YPCHAR).AND.(ICODE.EQ.KCODE)) THEN
**       Diagnostic type and field type match
         INCR=ISTEPT-NSTART
         IF(NFREQP.GT.0) THEN
            LOPR=LWRITE.AND.(INCR.EQ.NFREQP*(INCR/NFREQP))
         ELSE
            LOPR=.FALSE.
         ENDIF
         IF(NFREQA.GT.0) THEN
            LOUTF=LASCII.AND.(INCR.EQ.NFREQA*(INCR/NFREQA))
         ELSE
            LOUTF=.FALSE.
         ENDIF

         IF(LOPR) THEN
            IF((KINDXT.EQ.2.AND.IPR.EQ.KJDIM1).OR.
     -            (KINDXT.EQ.1.AND.IPR.EQ.KIDIM1)) THEN
               WRITE(6,6010)ISTEPT
6010           FORMAT(1X,'***RDNPH4 - PPR FULL, DATA NOT USED FOR ',
     -               'TIMESTEP ',I12)
               GO TO 110
            ENDIF
**          Copy data to print array
            IPR=IPR+1
            IF(IPR.EQ.1) K1PR=ISTEPT
            IF(KINDXT.EQ.1) THEN
               DO 1010 J=1,KJDIM1
               PPR(IPR,J)=ZDATA(J)
1010           CONTINUE
            ELSE
               DO 1000 J=1,KIDIM1
               PPR(J,IPR)=ZDATA(J)
1000           CONTINUE
            ENDIF
**          Check time interval of data in PPR array
            IF(IPR.GT.1) THEN
               INTERV=ISTEPT-KSTEPO
               IF(IPR.GT.2.AND.(INTERV.NE.INTERO)) THEN
                  WRITE(6,6000)YOCHAR,ICODE,ISTEPT,ISTEPT-INTERV,
     -                  ISTEPT-INTERV-INTERO
6000              FORMAT(1X,'***RDNPH4 WARNING:',/10X,A6,
     -                  ' PR FILE FOR ',
     -                  'FIELD ',I3,' HAS VARYING TIME INTERVAL; ',
     -                  'STEPS -',3I12)
               ENDIF
               INTERO=INTERV
            ENDIF
            KSTEPO=ISTEPT
         ENDIF

110      CONTINUE

         IF(LOUTF) THEN
            IF((KINDXT.EQ.2.AND.IUTF.EQ.KJDIM2).OR.
     -            (KINDXT.EQ.1.AND.IUTF.EQ.KIDIM2)) THEN
               WRITE(6,6020)ISTEPT
6020           FORMAT(1X,'***RDNPH4 - PPA FULL, DATA NOT USED FOR ',
     -               'TIMESTEP ',I12)
               GO TO 120
            ENDIF
**          Copy data to UTF array
            IUTF=IUTF+1
            IF(IUTF.EQ.1) K1UTF=ISTEPT
            IF(KINDXT.EQ.1) THEN
               DO 1110 J=1,KJDIM2
               PPA(IUTF,J)=ZDATA(J)
1110           CONTINUE
            ELSE
               DO 1100 J=1,KIDIM2
               PPA(J,IUTF)=ZDATA(J)
1100           CONTINUE
            ENDIF
**          Check time interval of data in PPA array
            IF(IUTF.GT.1) THEN
               INTERA=ISTEPT-KSTPAO
               IF(IUTF.GT.2.AND.(INTERA.NE.INTRAO)) THEN
                  WRITE(6,6030)YOCHAR,ICODE,ISTEPT,ISTEPT-INTERA,
     -                  ISTEPT-INTERA-INTRAO
6030              FORMAT(1X,'**RDNPH4 WARNING:',/10X,A6,' UTF FILE FOR '
     -                 ,'FIELD',I3,' HAS VARYING TIME INTERVAL; STEPS -'
     -                  ,3I12)
               ENDIF
               INTRAO=INTERA
            ENDIF
            KSTPAO=ISTEPT
         ENDIF
      ENDIF
120   CONTINUE
      GO TO 10

100   CONTINUE
**    End of file reached
      KTIMPR=IPR
      KTIMPL=IUTF
**    Check data field size
      IF((KINDXT.EQ.2.AND.IPR.NE.KJDIM1).OR.
     -      (KINDXT.EQ.1.AND.IPR.NE.KIDIM1)) THEN
         WRITE(6,6310)KCODE,YPCHAR
6310     FORMAT(1X,'***RDNPH4: WARNING IPR<MAXIMUM TIME DIMENSION',
     -         ' FOR FIELD ',I5,1X,A)
      ENDIF
      IF((KINDXT.EQ.2.AND.IUTF.NE.KJDIM2).OR.
     -      (KINDXT.EQ.1.AND.IUTF.NE.KIDIM2)) THEN
         WRITE(6,6300)KCODE,YPCHAR
6300     FORMAT(1X,'***RDNPH4: WARNING IUTF<MAXIMUM TIME DIMENSION',
     -         ' FOR FIELD ',I5,1X,A)
      ENDIF

      RETURN
      END
      SUBROUTINE G14OUT(PX,PY,KPTS,KCURVE,KPTYP,KSTYL,KLVTYP,
     -      KFRAME,KXTYP,ZXMIN,ZXMAX,YPNAM,
     -      YPX,YPY,YPL,PDAY1,PDAY2,KFAIL,KTFLAG)
**    Function - Interface between SMAP and UTF1.4 graph
**          data packer.
**    Args in -
**               PX      - Array containing x-axis data
**               PY      - Array containing y-axis data
**               KPTS    - Number of points on the each graph line
**               KCURVE  - Number of curves on the graph
**               KPTYP   - Plot type
**               KSTYL   - Plot style
**               KLVTYP  - Level type
**               KFRAME  - New frame switch
**               KXTYP   - X-axis type
**               ZXMIN   - Minimum x-axis value
**               ZXMAX   - Maximum x-axis value
**               YPNAM   - Array name/title
**               YPX     - X-axis label
**               YPY     - Y-axis label
**               YPL     - Line title
**               PDAY1   - Day number, or the first day in a range of
**                         days
**               PDAY2   - Last day in a range of days if PDAY2>PDAY1
**               KFAIL   - Error code passed to WTGUTF
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time-average
**                            2 : time-series
**    Args out - none
**    Args for work - none
**    Com used - /OUTCON/YNULL,/COMIOC/NCUTF,/COMDAT/NASCII
**    Com changed - none
**    Params used - none
**    Called by - GMOUT,GZOUT,OPPHTD,OPPHTS,OPSGTS,OPTRTS,OPXPTD,PCOLOP,
**          PHINST,XPINST
**    Calls - WTGU14,LENSIG
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      DIMENSION PX(KPTS),PY(KPTS,KCURVE)
      CHARACTER*50 YPNAM
      CHARACTER*(*) YPX,YPY,YPL(KCURVE)
      CHARACTER*50 YOXLAB,YOYLAB
      CHARACTER*8 YOLLAB(100)

**    Centre the axis labels, and pad all axis labels
**          out to 50 characters
      ILX=LENSIG(YPX)
      IS=(50-ILX)/2+1
      IE=IS+ILX-1
      YOXLAB=YNULL
      YOXLAB(IS:IE)=YPX
      ILY=LENSIG(YPY)
      IS=(50-ILY)/2+1
      IE=IS+ILY-1
      YOYLAB=YNULL
      YOYLAB(IS:IE)=YPY

**    Line labels can only contain 8 characters
      DO 100 J=1,KCURVE
      IYL=LENSIG(YPL(J))
      IY8=MIN(8,IYL)
      YOLLAB(J)='        '
      YOLLAB(J)=YPL(J)(1:IY8)
100   CONTINUE

      ICODE=0
      IFDTYP=6
      CALL WTGU14(PX,PY,KPTS,KCURVE,KPTYP,KSTYL,IFDTYP,KLVTYP,
     -      KFRAME,ICODE,KXTYP,ZXMIN,ZXMAX,
     -      YPNAM,YOXLAB,YOYLAB,YOLLAB,PDAY1,PDAY2,
     -      NCUTF,NASCII,KFAIL,KTFLAG)

      RETURN
      END
      SUBROUTINE UTF14(KNAME,KNCHAN)
**    Note - this subroutine is applicable to UTF version 1.4
**    Function - to initialise the UTF data
**    Args in -
**               KNAME   - Second global title for the UTF header
**               KNCHAN  - Output channel for the UTF
**    Args out - none
**    Args for work - none
**    Com used - /VERTCL/SIGMA,/COMDAT/YTYPSF,/THDAT/NTHL,
**          /ISDAT/NISL,/LEGAU/ALAT,/COMTIM/TSPD,NSTART,NEND,NFREQA
**          /OUTCON/RNTAPE,/LVDIAG/SFCOUT
**    Com changed - none
**    Params used - /PARAM1/JPMOCT,JPMM,JPNN,JPNWJ2,JPJGL,
**          JPMG,JPNL,JPJG,JPNHEM,/PARAM2/JPJGG,JPMJP
**    Called by - MAINBF
**    Calls - INIU14,ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /INIDAT/NYEAR,NDAY,NMIN
      COMMON /ISDAT/NISL
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      COMMON /THDAT/NTHL
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      INTEGER KNAME(2)
      DIMENSION ZALOND(JPMG)
      DIMENSION ZASIG(JPNL)

**    Determine level parameters
      IF(YTYPSF.EQ.'ET') THEN
         ILTYP=0
         INL=JPNL
         DO 300 J=1,JPNL
         ZASIG(J)=1000.*SIGMA(J)
300      CONTINUE
      ELSE IF(YTYPSF.EQ.'IS') THEN
         ILTYP=2
         INL=NISL
         DO 301 J=1,INL
         ZASIG(J)=SFCOUT(J)*0.01
301      CONTINUE
      ELSE IF(YTYPSF.EQ.'TH') THEN
         ILTYP=3
         INL=NTHL
         DO 302 J=1,INL
         ZASIG(J)=SFCOUT(J)
302      CONTINUE
      ENDIF

      ITIME=(NEND-NSTART)/NFREQA+1

**    The following define the start time of the model run, NOT
**    the restart time
      IYEAR=NYEAR
      IDAY=NDAY
      IMIN=NMIN

**    Longitudes
      ZDALON=360./FLOAT(JPMG*JPMOCT)
      DO 200 J=1,JPMG
      ZALOND(J)=FLOAT(J-1)*ZDALON
200   CONTINUE

      ZBEGDY=FLOAT(NSTART)/TSPD
      ZENDDY=FLOAT(NEND)/TSPD
      ZFRQDY=FLOAT(NFREQA)/TSPD

**    Only Gaussian data points in the north-south direction
      IJTYP=0

**    Write out the UTF global header
      CALL INIU14(KNAME,KNCHAN,IFAIL,JPMG,JPJG,INL,JPNHEM,JPMOCT,
     -      IJTYP,ILTYP,JPMM,JPNN,JPNWJ2,ITIME,IYEAR,IDAY,IMIN,
     -      ZALOND,ZASIG,ALAT,JPJGG,ZBEGDY,ZENDDY,ZFRQDY,RNTAPE)

      IF(IFAIL.EQ.1) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***UTF14: INVALID PARAMETER - UTF HEADER ',
     -         'NOT CREATED')
         CALL ABORT
      ENDIF

      RETURN
      END
      SUBROUTINE ENDXP
**    Function - To control the output of time-averaged XP diagnostics
**          and of the XP time-series
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /XPDIAG/LDXPTD,LDXPTS,
**          /COMTIM/NFREQA,NFREQP,NSTART,NEND,/COMDAT/BEGDAY,ENDDAY
**    Com changed - none
**    Params used - /PARAM1/JPNL,/PARAM3/JPXPMX
**    Called by - ENDOP
**    Calls - OPXPTD,OPXPTS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP

**    Time-averaged XP diagnostics from t=NSTART
      IF(LDXPTD) THEN
         CALL OPXPTD('LDXPTD',BEGDAY,ENDDAY)
      ENDIF

**    Time-series XP diagnostics
      IF(LDXPTS) THEN
         IF(NFREQA.EQ.0) THEN
            ISTEPA=1
         ELSE
            ISTEPA=(NEND-NSTART)/NFREQA+1
         ENDIF
         IF(NFREQP.EQ.0) THEN
            ISTEPP=1
         ELSE
            ISTEPP=(NEND-NSTART)/NFREQP+1
         ENDIF
         IJNL=JPNL
         CALL OPXPTS(ISTEPA,ISTEPP,IJNL)
      ENDIF

      RETURN
      END
      SUBROUTINE OPXPTD(YPTIME,PDAY1,PDAY2)
**    Function - Produces the time averaged XP output
**    Args in -
**               YPTIME  - Character*6 defining type of time averages
**               PDAY1   - Start time of averaging period
**               PDAY2   - End time of averaging period
**    Args out - none
**    Args for work - none
**    Com used - /XPCNST/LXPPRZ,LXPPLZ,DFACXP,CIXP,YNAMXP,LXPPRM,
**          LXPPLM,/VARTIM/LTOUT,/COMIOC/NCDYN1,/XPDIAG/NCXP,
**          /COMDAT/NSIGFG,LWRITE,LASCII,YTYPSF,/VERTCL/SIGMA3,
**          /LEGAU/ALAT,/ACCXP/all elements
**    Com changed - /ZONAVP/GPPZ,
**    Params used - /PARAM1/JPNL,/PARAM2/JPIGG,JPJGG,/PARAM3/JPXPMX
**    Called by - ENDXP
**    Calls - ABORT,ZSECTE,ZNLEVM,G14OUT,GLMOUT
**    Files read - NCDYN1
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      LOGICAL LXPPRZ,LXPPLZ,LXPPRM,LXPPLM
      CHARACTER*50 YNAMXP
      COMMON /XPCNST/LXPPRZ(JPXPMX),LXPPLZ(JPXPMX),DFACXP(JPXPMX),
     -      LXPPRM(JPXPMX),LXPPLM(JPXPMX),CIXP(JPXPMX),YNAMXP(JPXPMX)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      PARAMETER(JPXPD2=JPXPMX/2)
      COMMON /ZONAVP/UTVDZ(JPIGG,2),VTVDZ(JPIGG,2),TTVDZ(JPIGG,2),
     -      QTVDZ(JPIGG,2),TTCRZ(JPIGG,2),QTCRZ(JPIGG,2),TTLRZ(JPIGG,2),
     -      QTLRZ(JPIGG,2),TTRDZ(JPIGG,2),UTBLZ(JPIGG,2),VTBLZ(JPIGG,2),
     -      TTBLZ(JPIGG,2),QTBLZ(JPIGG,2),UTOTZ(JPIGG,2),VTOTZ(JPIGG,2),
     -      TTOTZ(JPIGG,2),QTOTZ(JPIGG,2),CTCRZ(JPIGG,2),CTLRZ(JPIGG,2)
      DIMENSION GPPZ(JPIGG,2,JPXPD2)
      EQUIVALENCE (GPPZ(1,1,1),UTVDZ(1,1))
      CHARACTER*6 YPTIME,YOTITL
      CHARACTER*50 YONAME
      LOGICAL LOPR,LOUTF
      EQUIVALENCE (ZGPPZ(1),GPPZ(1,1,1))
      DIMENSION ZLEV(JPNL),ZGPPZ(JPIGG)

**    Constants for output of time-average diagnostics
      IYDIM=JPJGG
      IZDIM=JPNL
      ZMINMG=0.0
      IFRAME=1
      ICSTYL=0
      IFOUT=0
      ITFLAG=1
      ILTYP=1
      IF(YTYPSF.EQ.'ET') THEN
         IPTYP=11
      ELSE
         IPTYP=0
      ENDIF

**    Rewind scratch file before reading in the data
      REWIND NCDYN1
10    READ(NCDYN1,END=100)YOTITL,IELEM,IFLD,ZGPPZ
      IF(YOTITL.NE.YPTIME) GO TO 10

**    IFLD lies in the range 1 - JPXPMX
**    IELEM should have been set to zero.
      IF(IELEM.NE.0) THEN
         WRITE(6,6000) IFLD,IELEM
6000     FORMAT(1X,'***OPXPTD: ERROR, IFLD,IELEM= ',2I5)
         CALL ABORT
      ENDIF

**    Output total zonal mean and level mean fields
      IF((LXPPRZ(IFLD).OR.LXPPLZ(IFLD).OR.LXPPRM(IFLD).OR.
     -      LXPPLM(IFLD)).AND.LTOUT) THEN

         YONAME=YNAMXP(IFLD)
         WRITE(YONAME(32:42),'(I5,''-'',I5)')
     -         NINT(PDAY1),NINT(PDAY2)
         ZCONTI=CIXP(IFLD)

**       Output total zonal mean
         LOUTF=LASCII.AND.LXPPLZ(IFLD)
         LOPR=LWRITE.AND.LXPPRZ(IFLD)
         IF(LOPR.OR.LOUTF) THEN
            WRITE(YONAME(43:50),'(A8)') ' Z. MEAN'
            CALL ZSECTE(ZGPPZ,IYDIM,IZDIM,YONAME,ZMINMG,NSIGFG,50,
     -            -1,1,NCXP,1,IYDIM,1,IZDIM,PDAY1,PDAY2,ZCONTI,
     -            LOPR,LOUTF,IFRAME,ICSTYL,0.0,0,ITFLAG,IPTYP,0,0,ILTYP,
     -            ALAT,SIGMA3,'Latitude','Sigma',8,5)
         ENDIF

**       Calculate level mean from the total zonal mean
         IF((LXPPLM(IFLD).OR.LXPPRM(IFLD)).AND.LTOUT) THEN
            CALL ZNLEVM(ZGPPZ,IYDIM,IZDIM,ZLEV)
         ENDIF

**       Output level mean
         LOUTF=LASCII.AND.LXPPLM(IFLD)
         LOPR=LWRITE.AND.LXPPRM(IFLD)
         IF(LOPR.OR.LOUTF) THEN
            WRITE(YONAME(43:50),'(A8)') 'LEV MEAN'
            IF(LOUTF) THEN
               ZLEVN=ZLEV(1)
               ZLEVX=ZLEV(1)
               DO 4100 J=2,JPNL
               ZLEVN=AMIN1(ZLEVN,ZLEV(J))
               ZLEVX=AMAX1(ZLEVX,ZLEV(J))
4100           CONTINUE
               CALL G14OUT(ZLEV,SIGMA3,IZDIM,1,31,0,0,1,0,ZLEVN,
     -               ZLEVX,YONAME,'Level mean','Sigma',' ',PDAY1,
     -               PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LOPR) CALL GLMOUT(IZDIM,ZLEV,ZMINMG,NSIGFG,1,NCXP,
     -            1,JPNL,YONAME,PDAY1,PDAY2,'SIGMA SFCS  ')
         ENDIF
      ENDIF

**    Now read in the next field of data
      GO TO 10

100   CONTINUE
**    No more data in scratch file

      RETURN
      END
      SUBROUTINE OPXPTS(KSTEPU,KSTEPP,KJNL)
**    Function - To generate time-series XP output of level mean fields
**    Args in -
**               KSTEPU  - number of timesteps for which data on NCDYN2
**                         will be written to the UTF
**               KSTEPP  - number of timesteps for which data on NCDYN2
**                         will be printed
**               KJNL    - number of data values  written to a
**                         record of NCDYN2
**    Args out - none
**    Args for work - none
**    Com used - /XPCNST/YNAMXP,CIXP,LXPPLM,LXPPRM,/XPDIAG/NCXP,
**          /COMDAT/LWRITE,LASCII,NSIGFG,NASCII,YTYPSF,
**          /COMTIM/TSPD,NFREQP,NFREQA,/COMIOC/NCUTF,/VERTCL/SIGMA
**    Com changed - none
**    Params used - /PARAM3/JPXPMX
**    Called by - ENDXP
**    Calls - ALLCHP,RDNXP2,ATRUNC,TLABEL,U14OUT,DEHEAP,GTZOUT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAp version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      LOGICAL LXPPRZ,LXPPLZ,LXPPRM,LXPPLM
      CHARACTER*50 YNAMXP
      COMMON /XPCNST/LXPPRZ(JPXPMX),LXPPLZ(JPXPMX),DFACXP(JPXPMX),
     -      LXPPRM(JPXPMX),LXPPLM(JPXPMX),CIXP(JPXPMX),YNAMXP(JPXPMX)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      POINTER(IPPZ,ZXPZ(KSTEPP,KJNL)),(IPUZ,ZXUZ(KSTEPU,KJNL))
      POINTER(IPUT,ZXUT(KSTEPU))
      LOGICAL LOUT,LOPR,LOUTF
      CHARACTER*50 YONAM

**    For each time-series an area of heap will be used to store the
**          data temporarily. Fortran unit NCDYN2 is read, record by
**          record, and arrays ZXPZ and ZXUZ are constructed; these
**          arrays are then used to produce printed and UTF output
**          respectively.

**    Loop over all the MARS files
      DO 100 J=1,JPXPMX

**    Check if time-series output is required
      LOUTF=LXPPLM(J).AND.LASCII
      LOPR=LXPPRM(J).AND.LWRITE
      LOUT=LOUTF.OR.LOPR

      IF(LOUT) THEN
         YONAM=YNAMXP(J)
         ZCI=CIXP(J)
         ITFLAG=2

**       Level means
         CALL ALLCHP(IPPZ,KJNL*KSTEPP,KERR)
         CALL ALLCHP(IPUZ,KJNL*KSTEPU,KERR)
         CALL ALLCHP(IPUT,KSTEPU,KERR)
         CALL RDNXP2(J,ZXPZ,KSTEPP,KJNL,ZXUZ,KSTEPU,KJNL,
     -         KLPR,KLUTF,K1PR,K1UTF)
         YONAM(43:50)='LEV MEAN'
         IF(LOUTF.AND.KLUTF.GE.1) THEN
            ZDAY1=FLOAT(K1UTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
            IF(YTYPSF.EQ.'ET') THEN
               IPTYP=21
            ELSE
               IPTYP=0
            ENDIF
            IF(KLUTF.NE.KSTEPU) THEN
               CALL ATRUNC(ZXUZ,KSTEPU,KJNL,KLUTF,KJNL)
               IPTYP=0
            ENDIF
            IF(IPTYP.EQ.0) CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
            CALL U14OUT(ZXUZ,KLUTF,KJNL,KLUTF,IPTYP,0,0,0,1,0,ZCI,2,
     -            YONAM,50,NCUTF,NASCII,0,ZDAY1,ZDAY2,ZXUT,SIGMA3,
     -            'Time','Sigma',4,5,ITFLAG,ZXUZ)
         ENDIF
         IF(LOPR.AND.KLPR.GE.1) THEN
            ZDAY1=FLOAT(K1PR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
            CALL GTZOUT(KSTEPP,KJNL,ZXPZ,0.0,NSIGFG,1,-1,
     -         NCXP,1,KLPR,1,KJNL,YONAM,ZDAY1,ZDAY2)
         ENDIF
         CALL DEHEAP(IPPZ,KERR)
         CALL DEHEAP(IPUZ,KERR)
         CALL DEHEAP(IPUT,KERR)
      ENDIF

100   CONTINUE

      RETURN
      END
      SUBROUTINE PHYSEC
**    Function - to control the step-by-step processing of the MARS
**          diagnostic fields. The code assumes that all JPXP2 zonal
**          mean diagnostic fields are available (in the order specified
**          in XPINIT) on the MARS file
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /XPDIAG/LDXPIN,LDXPTS,LDXPTD,/XPCNST/LXPPRM,
**          LXPPLM,LXPPRZ,LXPPLZ,/LEGAU/CS,/VARTIM/NSTEPT,DAYT,LTOUT,
**          /COMIOC/NCHIST,NCDYN1,NCDYN3,/COMTIM/NSTART,NEND
**    Com changed - /ZONAVP/all elements
**    Params used - /PARAM1/JPNL,/PARAM2/JPJGG,JPIGG,JPJGP,JPNLM,
**          /PARAM3/JPXPMX
**    Called by - ANALYS
**    Calls - ABORT,XPINST,XPTIME
**    Files read - NCHIST
**    Files written - none
**    Author - R. Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LXPPRZ,LXPPLZ,LXPPRM,LXPPLM
      CHARACTER*50 YNAMXP
      COMMON /XPCNST/LXPPRZ(JPXPMX),LXPPLZ(JPXPMX),DFACXP(JPXPMX),
     -      LXPPRM(JPXPMX),LXPPLM(JPXPMX),CIXP(JPXPMX),YNAMXP(JPXPMX)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      PARAMETER(JPXPD2=JPXPMX/2)
      COMMON /ZONAVP/UTVDZ(JPIGG,2),VTVDZ(JPIGG,2),TTVDZ(JPIGG,2),
     -      QTVDZ(JPIGG,2),TTCRZ(JPIGG,2),QTCRZ(JPIGG,2),TTLRZ(JPIGG,2),
     -      QTLRZ(JPIGG,2),TTRDZ(JPIGG,2),UTBLZ(JPIGG,2),VTBLZ(JPIGG,2),
     -      TTBLZ(JPIGG,2),QTBLZ(JPIGG,2),UTOTZ(JPIGG,2),VTOTZ(JPIGG,2),
     -      TTOTZ(JPIGG,2),QTOTZ(JPIGG,2),CTCRZ(JPIGG,2),CTLRZ(JPIGG,2)
      DIMENSION GPPZ(JPIGG,2,JPXPD2)
      EQUIVALENCE (GPPZ(1,1,1),UTVDZ(1,1))
      LOGICAL LOINST,LOAVD
      DIMENSION ZGPPZ(JPIGG*JPXPD2*2)
      EQUIVALENCE (ZGPPZ(1),GPPZ(1,1,1))

**    Set switches etc to define processing for current analysis time
      LOINST=(LDXPIN.OR.LDXPTS).AND.LTOUT
      LOAVD=LDXPTD

**    Set all elements to zero to simplify subsequent calculations
      DO 1000 J=1,JPIGG*JPXPD2*2
      ZGPPZ(J)=0.0
1000  CONTINUE

**    Access the data; note that the history file contains data for
**    fields averaged over the previous NREQD timesteps before the data
**    for instantaneous values.
      IF(.NOT.(LOINST.OR.LOAVD)) THEN
         READ(NCHIST)
         RETURN
      ELSE
         INL=JPNLM*JPJGG+1
         READ(NCHIST) ZKOUNT,ZMTAPE,ZDAY,ZRNR,
     -         ((UTVDZ(I,IN),I=1,JPIGG),(VTVDZ(I,IN),I=1,JPIGG),
     -         (TTVDZ(I,IN),I=1,JPIGG),(QTVDZ(I,IN),I=1,JPIGG),
     -         (TTCRZ(I,IN),I=1,JPIGG),(QTCRZ(I,IN),I=1,JPIGG),
     -         (TTLRZ(I,IN),I=1,JPIGG),(QTLRZ(I,IN),I=1,JPIGG),
     -         (TTRDZ(I,IN),I=1,JPIGG),
     -         (CTCRZ(I,IN),I=1,JPIGG),(CTLRZ(I,IN),I=1,JPIGG),
     -         (UTBLZ(I,IN),I=INL,JPIGG),(VTBLZ(I,IN),I=INL,JPIGG),
     -         (TTBLZ(I,IN),I=INL,JPIGG),(QTBLZ(I,IN),I=INL,JPIGG),
     -         IN=2,1,-1),ZMTAP1

         IF(NINT(ZRNR).NE.JPJGP) THEN
            WRITE(6,6900) DAYT,NINT(ZRNR)
6900        FORMAT(1x,'***ABORT IN PHYSEC AT DAY',F10.2,
     -            ' : RECORD COUNTER =',I5,'   NOT JPJGP')
            CALL ABORT
         ENDIF
      ENDIF

**    Remove cos(latitude) factor from U and V tendency arrays, and
**    create 'total' tendency arrays.
      DO 200 JN=1,2
      DO 100 JL=1,JPNL
      IOF=(JL-1)*JPJGG
      DO 100 J=1,JPJGG
      I=IOF+J
      UTVDZ(I,JN)=UTVDZ(I,JN)/CS(J)
      VTVDZ(I,JN)=VTVDZ(I,JN)/CS(J)
      UTBLZ(I,JN)=UTBLZ(I,JN)/CS(J)
      VTBLZ(I,JN)=VTBLZ(I,JN)/CS(J)
100   CONTINUE

      DO 110 JI=1,JPIGG
      UTOTZ(JI,JN)=UTBLZ(JI,JN)+UTVDZ(JI,JN)
      VTOTZ(JI,JN)=VTBLZ(JI,JN)+VTVDZ(JI,JN)
      TTOTZ(JI,JN)=TTBLZ(JI,JN)+TTVDZ(JI,JN)+TTCRZ(JI,JN)+TTLRZ(JI,JN)
     -      +TTRDZ(JI,JN)
      QTOTZ(JI,JN)=QTBLZ(JI,JN)+QTVDZ(JI,JN)+QTCRZ(JI,JN)+QTLRZ(JI,JN)
110   CONTINUE
200   CONTINUE

**    Rewind NCDYN1 once for each timestep
      REWIND NCDYN1
      REWIND NCDYN3
      DO 2000 JOUT=1,JPXPMX
      IF(JOUT.GT.JPXPMX/2) THEN
         IN=2
         IF=JOUT-JPXPMX/2
      ELSE
         IN=1
         IF=JOUT
      ENDIF
**    Now process the field for non-time averages - create instantaneous
**    field values
      IF(LOINST.AND.(LXPPRZ(JOUT).OR.LXPPRM(JOUT).OR.LXPPLZ(JOUT).OR.
     -      LXPPLM(JOUT))) CALL XPINST(JOUT,GPPZ(1,IN,IF))

**    Now process the field for time-averages
      IF(LOAVD.AND.(LXPPRZ(JOUT).OR.LXPPRM(JOUT).OR.LXPPLZ(JOUT).OR.
     -      LXPPLM(JOUT))) THEN
         CALL XPTIME(JOUT,GPPZ(1,IN,IF))
      ENDIF

2000  CONTINUE

**    Switch NCDYN1 and NCDYN3 (the former will be read from at
**    the next step; it contains the latest data).
      ICHAN=NCDYN3
      NCDYN3=NCDYN1
      NCDYN1=ICHAN

      RETURN
      END
      SUBROUTINE RDNXP2(KIELEM,PPR,KIDIM1,KJDIM1,PPA,KIDIM2,
     -      KJDIM2,KTIMPR,KTIMPL,K1PR,K1UTF)
**    Function - To read the contents of NCDYN2 for a particular field
**          and to construct arrays containing the
**          data that will be printed and used to convert to a UTF
**    Args in -
**               KIELEM  - MARS field code(sequence no.) of required
**                         field
**               KIDIM1  - Time dimension of PPR
**               KJDIM1  - Space dimension of PPR
**               KIDIM2  - Time dimension of PPA
**               KJDIM2  - Space dimension of PPA
**    Args out -
**               PPR     - Array of data values to be printed
**               PPA     - Array of data values to be passed to UTF
**               KTIMPR  - Number of timesteps of data in PPR
**               KTIMPL  - Number of timesteps of data in PPA
**               K1PR    - Timestep of first PPR data
**               K1UTF   - Timestep of first PPA data
**    Args for work - none
**    Com used - /COMTIM/NFREQA,NFREQP,NSTART,/COMIOC/NCDYN2,
**          /COMDAT/LWRITE,LASCII
**    Com changed - none
**    Params used - /PARAM1/JPJNL
**    Called by - OPXPTS
**    Calls - ABORT
**    Files read - NCDYN2
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version0

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      DIMENSION PPR(KIDIM1,KJDIM1),PPA(KIDIM2,KJDIM2)
      DIMENSION ZDATA(JPNL)
      LOGICAL LOPR,LOUTF

**    Check the dimensions
      IF((KJDIM1.NE.JPNL).OR.(KJDIM2.NE.JPNL)) THEN
         WRITE(6,6110)KJDIM1,KJDIM2,JPNL
6110     FORMAT(1X,'***RDNXP2: ERROR IN DIMENSIONS, KJDIM1,KJDIM2',
     -         ' AND JPNL = ',3I12)
         CALL ABORT
      ENDIF

      REWIND NCDYN2
      IPR=0
      IUTF=0
      INTRAO=0
      INTERO=0

10    CONTINUE
      READ(NCDYN2,END=100)IIELEM,ISTEPT,ZDATA
      IF((IIELEM.EQ.KIELEM)) THEN
**       Correct field type read
         INCR=ISTEPT-NSTART
         IF(NFREQP.GT.0) THEN
            LOPR=LWRITE.AND.(INCR.EQ.NFREQP*(INCR/NFREQP))
         ELSE
            LOPR=.FALSE.
         ENDIF
         IF(NFREQA.GT.0) THEN
            LOUTF=LASCII.AND.(INCR.EQ.NFREQA*(INCR/NFREQA))
         ELSE
            LOUTF=.FALSE.
         ENDIF

         IF(LOPR) THEN
            IF(IPR.EQ.KIDIM1) THEN
               WRITE(6,6010)ISTEPT
6010           FORMAT(1X,'***RDNXP2 - PPR FULL, DATA NOT USED FOR ',
     -               'TIMESTEP ',I12)
               GO TO 110
            ENDIF
**          Copy data to print array
            IPR=IPR+1
            IF(IPR.EQ.1) K1PR=ISTEPT
            DO 1010 J=1,KJDIM1
            PPR(IPR,J)=ZDATA(J)
1010        CONTINUE
**          Check time interval of data in PPR array
            IF(IPR.GT.1) THEN
               INTERV=ISTEPT-KSTEPO
               IF(IPR.GT.2.AND.(INTERV.NE.INTERO)) THEN
                  WRITE(6,6000)KIELEM,ISTEPT,ISTEPT-INTERV,
     -                  ISTEPT-INTERV-INTERO
6000              FORMAT(1X,'***RDNXP2 WARNING:',/10X,' PR FILE FOR ',
     -                  'FIELD ',I3,' HAS VARYING TIME INTERVAL; ',
     -                  'STEPS -',3I12)
               ENDIF
               INTERO=INTERV
            ENDIF
            KSTEPO=ISTEPT
         ENDIF

110      CONTINUE
         IF(LOUTF) THEN
            IF(IUTF.EQ.KIDIM2) THEN
               WRITE(6,6020)ISTEPT
6020           FORMAT(1X,'***RDNXP2 - PPA FULL, DATA NOT USED FOR ',
     -               'TIMESTEP ',I12)
               GO TO 120
            ENDIF
**          Copy data to UTF array
            IUTF=IUTF+1
            IF(IUTF.EQ.1) K1UTF=ISTEPT
            DO 1110 J=1,KJDIM2
            PPA(IUTF,J)=ZDATA(J)
1110        CONTINUE
**          Check time interval of data in PPA array
            IF(IUTF.GT.1) THEN
               INTERA=ISTEPT-KSTPAO
               IF(IUTF.GT.2.AND.(INTERA.NE.INTRAO)) THEN
                  WRITE(6,6030)KIELEM,ISTEPT,ISTEPT-INTERA,
     -                  ISTEPT-INTERA-INTRAO
6030              FORMAT(1X,'**RDNXP2 WARNING:',/10X,' UTF FILE FOR ',
     -                 'FIELD ',I3,' HAS VARYING TIME INTERVAL; STEPS -'
     -                  ,3I12)
               ENDIF
               INTRAO=INTERA
            ENDIF
            KSTPAO=ISTEPT
         ENDIF
      ENDIF
120   CONTINUE
      GO TO 10

100   CONTINUE
**    End of file reached
      KTIMPR=IPR
      KTIMPL=IUTF
**    Check data field size
      IF(IPR.NE.KIDIM1) THEN
         WRITE(6,6310)KIELEM
6310     FORMAT(1X,'***RDNXP2: WARNING IPR<MAXIMUM TIME DIMENSION',
     -         ' FOR FIELD ',I5)
      ENDIF
      IF(IUTF.NE.KIDIM2) THEN
         WRITE(6,6300)KIELEM
6300     FORMAT(1X,'***RDNXP2: WARNING IUTF<MAXIMUM TIME DIMENSION',
     -         ' FOR FIELD ',I5)
      ENDIF

      RETURN
      END
      SUBROUTINE XPINIT(LPXP)
**    Function - to initialise the arrays and constants required by the
**          XP diagnostics
**    Args in -
**               LPXP    - .TRUE. if XP diagnostics are required
**    Args out -
**               LPXP    - may be set to false if XP diagnostics are
**                         inappropriate
**    Args for work - none
**    Com used - /XPDIAG/NXPPR,NXPPL,CINTXP,LDXPZM,LDXPIN,LDXPTS,
**          LDXPTD,LDXPLM,/COMDAT/LWRITE,LASCII,/INVAR/PI2
**    Com changed - /XPCNST/all elements
**    Params used - /PARAM3/JPXPMX
**    Called by - DINIT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      LOGICAL LXPPRZ,LXPPLZ,LXPPRM,LXPPLM
      CHARACTER*50 YNAMXP
      COMMON /XPCNST/LXPPRZ(JPXPMX),LXPPLZ(JPXPMX),DFACXP(JPXPMX),
     -      LXPPRM(JPXPMX),LXPPLM(JPXPMX),CIXP(JPXPMX),YNAMXP(JPXPMX)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      LOGICAL LPXP
      CHARACTER*50 YONAME(JPXPMX)
**    All fields are accumulated
      DATA (YONAME(I),I=1,10)/
     -        ' U-TEND VD       m/s/day   DAY                    '
     -       ,' V-TEND VD       m/s/day   DAY                    '
     -       ,' T-TEND VD       K/day     DAY                    '
     -       ,' Q-TEND VD       g/kg/day  DAY                    '
     -       ,' T-TEND CR       K/day     DAY                    '
     -       ,' Q-TEND CR       g/kg/day  DAY                    '
     -       ,' T-TEND LR       K/day     DAY                    '
     -       ,' Q-TEND LR       g/kg/day  DAY                    '
     -       ,' T-TEND RD       K/day     DAY                    '
     -       ,' U-TEND BL       m/s/day   DAY                    '
     -       /
      DATA (YONAME(I),I=11,19)/
     -        ' V-TEND BL       m/s/day   DAY                    '
     -       ,' T-TEND BL       K/day     DAY                    '
     -       ,' Q-TEND BL       g/kg/day  DAY                    '
     -       ,' U-TEND TOTAL    m/s/day   DAY                    '
     -       ,' V-TEND TOTAL    m/s/day   DAY                    '
     -       ,' T-TEND TOTAL    K/day     DAY                    '
     -       ,' Q-TEND TOTAL    g/kg/day  DAY                    '
     -       ,' CONVECTION COUNTER                               '
     -       ,' LSR COUNTER                                      '
     -       /

      DO 100 J=JPXPMX/2+1,JPXPMX
      JM=J-JPXPMX/2
      YONAME(J)=YONAME(JM)
      YONAME(J)(1:1)='*'
100   CONTINUE

**    XP diagnostics require LPXP=.TRUE.,
**          one of LWRITE and LASCII set to .TRUE., and
**          a valid field-type to process
      IF((.NOT.LWRITE).AND.(.NOT.LASCII)) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***XPINIT: XP DIAGNOSTICS SWITCHED OFF SINCE ',
     -         'NO OUTPUT REQUESTED')
         LPXP=.FALSE.
      ENDIF
      IF((NXPPR(1).EQ.0).AND.(NXPPL(1).EQ.0)) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'***XPINIT: XP DIAGNOSTICS SWITCHED OFF SINCE ',
     -         'NO OUTPUT FIELD-TYPES DETECTED')
         LPXP=.FALSE.
      ENDIF
      IF((.NOT.LDXPIN).AND.(.NOT.LDXPTS).AND.(.NOT.LDXPTD)) THEN
         WRITE(6,6026)
6026     FORMAT(1X,'***XPINIT: XP DIAGNOSTICS SWITCHED OFF SINCE NO ',
     -         'TIME CONTROLS ARE SET')
         LPXP=.FALSE.
      ENDIF
      IF(.NOT.LPXP) RETURN

**    Process namelist information, and set up array titles etc
**    Default values set
      DO 1000 JI=1,JPXPMX
**    Set dimensionalising factors for K, g/kg, m/s
      IF (YONAME(JI)(2:2).EQ.'Q') THEN
         DFACXP(JI)=1000.0*PI2
      ELSE IF(YONAME(JI)(2:4).EQ.'LSR') THEN
         DFACXP(JI)=1.0
      ELSE IF(YONAME(JI)(2:4).EQ.'CON') THEN
         DFACXP(JI)=1.0
      ELSE IF(YONAME(JI)(2:2).EQ.'T') THEN
         DFACXP(JI)=CT*PI2
      ELSE IF(YONAME(JI)(2:2).EQ.'U'.OR.YONAME(JI)(2:2).EQ.'V') THEN
         DFACXP(JI)=CV*PI2
      ENDIF
      CIXP(JI)=0.5
      LXPPRZ(JI)=.FALSE.
      LXPPLZ(JI)=.FALSE.
      LXPPLM(JI)=.FALSE.
      LXPPRM(JI)=.FALSE.
      YNAMXP(JI)=YONAME(JI)
1000  CONTINUE

**    Now overwrite the default values according to the user's
**    namelist input
      DO 2000 JI=1,NXP
**    Printing control
      IGR=NXPPR(JI)
      IF(IGR.GT.0.AND.IGR.LE.JPXPMX) THEN
         LXPPRZ(IGR)=LDXPZM
         LXPPRM(IGR)=LDXPLM
      ENDIF
**    Plotting control
      IPL=NXPPL(JI)
      IF(IPL.GT.0.AND.IPL.LE.JPXPMX) THEN
         LXPPLZ(IPL)=LDXPZM
         LXPPLM(IPL)=LDXPLM
         CIXP(IPL)=CINTXP(JI)
      ENDIF
2000  CONTINUE

      RETURN
      END
      SUBROUTINE XPINST(KOUT,PF)
**    Function - to perform the XP calculations for instantaneous fields
**          and time series
**    Args in -
**               KOUT    - Field sequence number in array containing
**                         titles
**               PF      - Array containing data
**    Args out - none
**    Args for work - none
**    Com used - /COMTIM/NFREQD,NSTART,NEND,/XPCNST/all elements,
**          /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT,
**          /XPDIAG/LDXPIN,LDXPTS,NCXP,/COMDAT/NSIGFG,YTYPSF,
**          /VERTCL/SIGMA,/COMIOC/NCDYN2,/VARTIM/NSTEPT,/LEGAU/ALAT
**    Com changed - none
**    Params used - /PARAM1/JPMG,/PARAM2/JPIGG,JPJGG
**    Called by - PHYSEC
**    Calls - ABORT,ZSECTE,ZNLEVM,G14OUT,GLMOUT
**    Files read - none
**    Files written - NCDYN2
**    Author - R.Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      LOGICAL LXPPRZ,LXPPLZ,LXPPRM,LXPPLM
      CHARACTER*50 YNAMXP
      COMMON /XPCNST/LXPPRZ(JPXPMX),LXPPLZ(JPXPMX),DFACXP(JPXPMX),
     -      LXPPRM(JPXPMX),LXPPLM(JPXPMX),CIXP(JPXPMX),YNAMXP(JPXPMX)
      LOGICAL LDXPZM,LDXPLM,LDXPTD,LDXPIN,LDXPTS
      COMMON /XPDIAG/NCXP,NXPPR(JPXPMX),NXPPL(JPXPMX),CINTXP(JPXPMX),
     -      LDXPZM,LDXPLM,LDXPTD,LDXPIN,
     -      LDXPTS,NXP
      CHARACTER*50 YONAMT
      LOGICAL LOUTF,LOPR
      DIMENSION PF(JPIGG),ZF(JPIGG)
      DIMENSION ZLEV(JPNL)

      ZDFAC=DFACXP(KOUT)
      ITFLAG=0

**    Convert the field to meteorological units for instantaneous
**    output
      IF(LDXPIN.OR.LDXPTS) THEN
         DO 1100 J=1,JPIGG
         ZF(J)=PF(J)*ZDFAC
1100     CONTINUE
      ENDIF

**    Output of instantaneous diagnostics
      IYDIM=JPJGG
      IZDIM=JPNL
      YONAMT=YNAMXP(KOUT)
      ZMINMG=0.0
      ZCONTI=CIXP(KOUT)
      IFRAME=1
      ICSTYL=0
      IFOUT=0
      ILTYP=1
      IF(YTYPSF.EQ.'ET') THEN
         IPTYP=11
      ELSE
         IPTYP=0
      ENDIF

**    Complete zonal mean over all gridpoints
      LOUTF=LTASCI.AND.LXPPLZ(KOUT).AND.LDXPIN
      LOPR=LTPRNT.AND.LXPPRZ(KOUT).AND.LDXPIN
      IF(LOPR.OR.LOUTF) THEN
         WRITE(YONAMT(32:40),'(F9.2)') DAYT
         WRITE(YONAMT(41:50),'(A10)') ' ZON. MEAN'
         CALL ZSECTE(ZF,IYDIM,IZDIM,YONAMT,ZMINMG,NSIGFG,50,
     -         -1,1,NCXP,1,IYDIM,1,IZDIM,DAYT,-1.0,ZCONTI,
     -         LOPR,LOUTF,IFRAME,ICSTYL,0.0,0,ITFLAG,IPTYP,0,0,ILTYP,
     -         ALAT,SIGMA3,'Latitude','Sigma',8,5)
      ENDIF

**    Compute level mean over all gridpoints
      IF((LXPPLM(KOUT).OR.LXPPRM(KOUT)).AND.LTOUT) THEN
         CALL ZNLEVM(ZF,IYDIM,IZDIM,ZLEV)
      ENDIF

**    Instantaneous output of level means
      LOUTF=LTASCI.AND.LXPPLM(KOUT).AND.LDXPIN
      LOPR=LTPRNT.AND.LXPPRM(KOUT).AND.LDXPIN
      IF(LOPR.OR.LOUTF) THEN
         WRITE(YONAMT(32:40),'(F9.2)') DAYT
         WRITE(YONAMT(41:50),'(A10)') ' LEV. MEAN'
         IF(LOUTF) THEN
            ZLEVN=ZLEV(1)
            ZLEVX=ZLEV(1)
            DO 4100 J=2,JPNL
            ZLEVN=AMIN1(ZLEVN,ZLEV(J))
            ZLEVX=AMAX1(ZLEVX,ZLEV(J))
4100        CONTINUE
            CALL G14OUT(ZLEV,SIGMA3,JPNL,1,31,0,0,1,0,ZLEVN,ZLEVX,
     -            YONAMT,'Level mean','Sigma',' ',DAYT,-1.0,IFAIL,
     -            ITFLAG)
         ENDIF
         IF(LOPR) CALL GLMOUT(JPNL,ZLEV,ZMINMG,NSIGFG,1,NCXP,
     -         1,JPNL,YONAMT,DAYT,-1.0,'SIGMA SFCS  ')
      ENDIF

**    Time-series preparation - should only be requested if level
**    averages have also been requested; note that the data written
**    to this file is in meteorological units
      IF(LDXPTS.AND.(LXPPLM(KOUT).OR.LXPPRM(KOUT)))
     -      WRITE(NCDYN2)KOUT,NSTEPT,ZLEV

      RETURN
      END
      SUBROUTINE XPTIME(KOUT,PF)
**    Function - to perform the XP calculations for time averages
**    Args in -
**               KOUT    - Field sequence number in array containing
**                         titles
**               PF      - Array containing data
**    Args out - none
**    Args for work - none
**    Com used - /VARTIM/NSTEPT,/COMTIM/NSTART,NEND,
**          /XPCNST/DFACXP,/COMIOC/NCDYN1
**    Com changed - /ACCXP/all elements
**    Params used - /PARAM2/JPIGG,/PARAM3/JPXPMX
**    Called by - PHYSEC
**    Calls - ABORT,SCOPY
**    Files read - NCDYN1
**    Files written - NCDYN3
**    Author - R.Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LXPPRZ,LXPPLZ,LXPPRM,LXPPLM
      CHARACTER*50 YNAMXP
      COMMON /XPCNST/LXPPRZ(JPXPMX),LXPPLZ(JPXPMX),DFACXP(JPXPMX),
     -      LXPPRM(JPXPMX),LXPPLM(JPXPMX),CIXP(JPXPMX),YNAMXP(JPXPMX)
      DIMENSION PF(JPIGG),ZF(JPIGG)
      CHARACTER*6 YOFLAG

      IF(NSTEPT.EQ.NSTART) THEN
         ISTEP=1
         WRITE(NCDYN3)'LDXPTD',ISTEP,KOUT,PF
      ELSE IF(NSTEPT.LT.NEND) THEN
**       Assume that fields are passed through to this routine in
**       the same order at all timesteps - NCDYN1 should have been
**       rewound already if this is the first data array of the
**       current time
         READ(NCDYN1)YOFLAG,ISTEP,IOUT,ZF
         IF(YOFLAG.NE.'LDXPTD') THEN
            WRITE(6,6005)YOFLAG
6005        FORMAT(1X,'***XPTIME: ERROR, YOFLAG= ',A6)
            CALL ABORT
         ENDIF
         IF(IOUT.NE.KOUT) THEN
            WRITE(6,6010)IOUT,KOUT
6010        FORMAT(1X,'***XPTIME: ERROR, IOUT = ',I2,' EXPECTED ',
     -            I2)
            CALL ABORT
         ENDIF
         DO 100 J=1,JPIGG
         ZF(J)=ZF(J)+PF(J)
100      CONTINUE
         ISTEP=ISTEP+1
         WRITE(NCDYN3)'LDXPTD',ISTEP,KOUT,ZF
      ELSE IF(NSTEPT.EQ.NEND) THEN
         READ(NCDYN1)YOFLAG,ISTEP,IOUT,ZF
         IF(YOFLAG.NE.'LDXPTD') THEN
            WRITE(6,6005)YOFLAG
            CALL ABORT
         ENDIF
         IF(IOUT.NE.KOUT) THEN
            WRITE(6,6010)IOUT,KOUT
            CALL ABORT
         ENDIF
         ISTEP=ISTEP+1
         DO 200 J=1,JPIGG
         ZF(J)=DFACXP(KOUT)*(ZF(J)+PF(J))/FLOAT(ISTEP)
200      CONTINUE
         ISTEP=0
         WRITE(NCDYN3)'LDXPTD',ISTEP,KOUT,ZF
      ENDIF

      RETURN
      END
      SUBROUTINE INIROG
**    Function - Reads spectral non-dimensional geopotential and
**          calculates dimensional orographic height, which is then
**          stored, and optionally output. If JPJGL=1, write JPJG
**          records to scratch channel NCROGG. If JPJGL=JPJG store all
**          latitudes in /COMROG/.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /ORDIAG/LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE,CINTOR,
**          /COMDAT/LUTF14,LROGR,NSIGFG,NASCII,/LEGAU/ALP,JINC,
**          /COMIOC/NCUTF,NCROGG,NCROGS,NCLEG,/INVAR/GA,CG,
**          /VARTIM/LTPRNT,LTASCI,/COMFFT/MFAX,TRIG
**    Com changed - /COMROG/GSG,/SPECTR/GS,/COMFFT/WORK,
**          /CWORK/WGP2D1,WGP2D2
**    Params used - /PARAM1/JPJG,JPJGL,JPCRAY,JPNHEM,JPMG,/PARAM2/JPJGG,
**          JPMGPP,JPIGC,JPIGA
**    Called by - INIOP
**    Calls - RESEQ1,GLLOUT,U14OUT,HEXP,FFT991
**    Files read - NCROGG,NCROGS,NCLEG
**    Files written - NCROGG
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMROG/GSG(JPIGC,JPJGL)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION ZGPV(JPIGC*JPJG),ZGSG(JPIGC*JPJGL),ZOUT(JPMG,JPJGG)
      EQUIVALENCE (ZGPV(1),WGP2D1(1,1)),(ZGSG(1),GSG(1,1)),
     -      (ZOUT(1,1),WGP2D2(1,1))
      LOGICAL LOPR,LOUTF
      CHARACTER*50 YONAME
      DATA YONAME /'OROGRAPHIC HEIGHT                        METRES   '/

**    Preset spectral and grid point orography to zero, in case
**    orography is not read in.
      DO 10 JI=1,JPIGA
10    GS(JI)=(0.0,0.0)
      DO 20 JI=1,JPIGC*JPJGL
20    ZGSG(JI)=0.0

      IF(.NOT.LROGR) RETURN

      WRITE(6,6000)
6000  FORMAT(/' INIROG: OROGRAPHY INCLUDED IN DIAGNOSTICS')
      IF (LMSKH) WRITE(6,6010)
6010  FORMAT(/' INIROG: OROGRAPHIC MASK PLOTTED ON LAT-LONG FIELDS')
      IF (LMSKNS) WRITE(6,6020)
6020  FORMAT(/' INIROG: OROGRAPHIC MASK PLOTTED ON ZONAL SECTIONS')
      IF (LMSKWE) WRITE(6,6030)
6030  FORMAT(/' INIROG: OROGRAPHIC MASK PLOTTED ON MERIDIONAL SECTIONS')

**    Assume initial gridpoint data file (INUGP) assigned in script.
      INUGP=NCROGS
      WRITE(6,6040) INUGP
6040  FORMAT(/' INIROG : READ OROGRAPHY FROM NUGP FILE ON CHANNEL',I3)

**    Read spectral orography into GS array; at this stage GS contains
**    the non-dimensional geopotential.
      READ(NCROGS) GS
**    The following lines may be used as an alternative to the one above
**    if the data is in 'READD' format.
C     IDIM=JPIGA
C     CALL READD(GS,-1,3*JPNL+1,JPNHEM,JPNN,NCROGS,IDIM)
C     CALL READD(GS,JPMM-1,1,JPNHEM,JPNN,NCROGS,IDIM)

**    Transform to grid point space.
      IF (JPJGL.EQ.1) THEN
         REWIND NCROGG
         REWIND NCLEG
         IJL=1
         DO 30 JIH=1,JPJG
         READ(NCLEG) ALP
         CALL HEXP(GS,GSG(1,IJL),1,2,1)
         CALL FFT991(GSG(1,IJL),WORK,TRIG,MFAX,1,JPMGPP,JPMG,JPNHEM,1)
         DO 100 J=I,JPIGC
         GSG(J,IJL)=GSG(J,IJL)*CG/GA
100      CONTINUE
         WRITE(NCROGG) GSG
30       IJL=IJL+JINC
         REWIND NCROGG
         REWIND NCLEG
      ELSE
         IBATCH=(JPJGG-1)/JPCRAY
         IREST=JPJGG-IBATCH*JPCRAY
         IJL=1
         DO 40 JIH=1,JPJG
         CALL HEXP(GS,GSG(1,IJL),1,2,IJL)
40       IJL=IJL+JINC
         IF (IBATCH.EQ.0) GOTO 60
         DO 50 JJ=1,IBATCH
50       CALL FFT991(ZGSG(1+(JJ-1)*JPCRAY*JPMGPP),WORK,TRIG
     -         ,MFAX,1,JPMGPP,JPMG,JPCRAY,1)
60       CONTINUE
         CALL FFT991(ZGSG(1+IBATCH*JPCRAY*JPMGPP),WORK,TRIG
     -         ,MFAX,1,JPMGPP,JPMG,IREST,1)
         DO 110 J=1,JPIGC*JPJGL
         ZGSG(J)=ZGSG(J)*CG/GA
110      CONTINUE
      ENDIF

**    Print/plot orography depending on switches in /ORDIAG/.
      LOPR=LTPRNT.AND.LROGPR
      LOUTF=LTASCI.AND.LROGPL
**    RESEQ1 reorders the orography for output
      IF(JPJGL.EQ.1) THEN
         REWIND NCROGG
         DO 1000 J=1,JPJG
         IOF=(J-1)*JPIGC
         READ(NCROGG)(ZGPV(I),I=IOF+1,IOF+JPIGC)
1000     CONTINUE
         CALL RESEQ1(ZGPV,JPMGPP,JPNHEM,JPJG,ZOUT,JPMG,JPJGG)
      ELSE
         CALL RESEQ1(ZGSG,JPMGPP,JPNHEM,JPJG,ZOUT,JPMG,JPJGG)
      ENDIF
**    Write output to channel 6
      ICOUT=6
      IF(LOPR) CALL GLLOUT(JPMG,JPJGG,ZOUT,0.0,NSIGFG,-1,-1,ICOUT,
     -      1,JPMG,1,JPJGG,YONAME,0.0,-1.0)
      IF(LOUTF) THEN
         IF(LUTF14) THEN
            ITFLAG=0
            IF(JPMOCT.EQ.1) THEN
               IORTYP=1
            ELSE
               IORTYP=3
            ENDIF
            CALL U14OUT(ZOUT,JPMG,JPJGG,JPMG,IORTYP,1,0,0,1,0,CINTOR,
     -            JPNHEM,YONAME,50,NCUTF,NASCII,IFAIL,0.0,-1.0,
     -            ZOUT,ZOUT,' ',' ',1,1,ITFLAG,ZOUT)
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE READD(ZGS,KZONAL,KNLL,KNOHEM,KNND,KUNIT,KDIM)
**    Function - Read spectral orography data (KZONAL=>0)
**          from channel KUNIT or skip records (KZONAL<0).
**    Args in -
**               KZONAL  - Flag -- see above
**               KNLL    -
**               KNOHEM  - Number of hemispheres of data
**               KNND    - Total wavenumber of data
**               KUNIT   - Channel number containing data
**               KDIM    - Dimension of ZGS
**    Args out -
**               ZGS     - non-dimensional spectral geopotential
**                         (complex array)
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNWJ2,JPNN
**    Called by - INIROG
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on a routine by
**          Paul Valdes. (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      COMPLEX ZGS(KDIM)

      IGA=JPNWJ2*KNOHEM

**    Initial checks
      IF (KZONAL.GT.(KNND-1)) THEN
         WRITE(6,'('' ***ABORT IN READD: KZONAL ERROR'')')
         CALL ABORT
      ENDIF

      IF (KZONAL.LT.0) THEN
         IMSKIP=KNLL*KNND
         IF (IMSKIP.GT.0) THEN
            DO 10 I=1,IMSKIP
10          READ(KUNIT)
         ENDIF
         RETURN
      ENDIF

      IMSKIP=KNND-1-KZONAL
      DO 50 IL=1,KNLL
      II=(IL-1)*IGA
      DO 30 IM=0,KZONAL
      IN=(JPNN+1-IM)/2
      IN1=(KNND+1-IM)/2
      IN2=MIN(IN,IN1)
      INDUM=IN1-IN2
      IF(KNOHEM.EQ.1) THEN
         READ(KUNIT) (ZGS(I),I=II+1,II+IN2)
      ELSE
         IF (INDUM.LE.0) THEN
         READ(KUNIT) (ZGS(I),I=II+1,II+IN2)
     -         ,(ZGS(I),I=II+JPNWJ2+1,II+JPNWJ2+IN2)
         ELSE
            READ(KUNIT) (ZGS(I),I=II+1,II+IN2),(ZDUM,I=1,INDUM)
     -         ,(ZGS(I),I=II+JPNWJ2+1,II+JPNWJ2+IN2)
         ENDIF
      ENDIF
      IF (IM.EQ.0) THEN
         DO 20 IHEM=1,KNOHEM
         I1=(IHEM-1)*JPNWJ2
         DO 20 I=1,IN2
         ZGS(II+I+I1)=CMPLX(REAL(ZGS(II+I+I1)),0.)
20       CONTINUE
      ENDIF
      II=II+IN
30    CONTINUE
      IF (KZONAL.LT.(KNND-1).AND.IMSKIP.GT.0) THEN
         DO 40 I=1,IMSKIP
40       READ(KUNIT)
      ENDIF
50    CONTINUE

      RETURN
      END
      SUBROUTINE COINIT(LPCO)
**    Function - to initialise the arrays and constants required by the
**          CO diagnostics
**    Args in -
**               LPCO    - .TRUE. if CO diagnostics are required
**    Args out -
**               LPCO    - may be set to .FALSE. if CO diagnostics are
**                         inappropriate
**    Args for work - none
**    Com used - /CODIAG/NCOPR,NVCOHR,/COMDAT/LWRITE
**    Com changed - /COCNST/all elements
**    Params used - /PARAM1/JPNL,/PARAM3/JPCOMX
**    Called by - DINIT
**    Calls - WRSPI
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LDCOPR,LVCOHR
      CHARACTER*50 YNAMCO
      COMMON /COCNST/LDCOPR(JPCOMX),LVCOHR(JPNL),YNAMCO(JPCOMX)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LPCO
      CHARACTER*50 YONAME(JPCOMX)
      DATA (YONAME(J),J=1,JPCOMX)/
     -       'RELATIVE VORTICITY   ON SIG=                      '
     -      ,'DIVERGENCE           ON SIG=                      '
     -      ,'PERT. TEMPERATURE    ON SIG=                      '
     -      ,'SPECIFIC HUMIDITY    ON SIG=                      '
     -      ,'DIABATIC HEATING     ON SIG=                      '
     -      ,'LOG(SURFACE PRESSURE)                             '/

**    Ensure diagnostics switched off if no printout requested
      IF((.NOT.LWRITE).AND.LPCO) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***COINIT: CO DIAGNOSTICS SWITCHED OFF SINCE NO',
     -         ' PRINTOUT REQUESTED')
         LPCO=.FALSE.
      ENDIF
      IF(.NOT.LPCO) RETURN

**    Process namelist information, and set up array titles etc
**    Default values set
      DO 1000 J=1,JPCOMX
      YNAMCO(J)=YONAME(J)
      LDCOPR(J)=.FALSE.
1000  CONTINUE
      DO 1100 JL=1,JPNL
      LVCOHR(JL)=.FALSE.
1100  CONTINUE

**    Now overwrite the default values according to the user's namelist
**          input
      DO 2000 J=1,JPCOMX
      JF=NCOPR(J)
      IF(JF.GT.0) LDCOPR(JF)=.TRUE.
2000  CONTINUE
      DO 2100 JL=1,JPNL
      JLEV=NVCOHR(JL)
      IF(JLEV.GT.0) LVCOHR(JLEV)=.TRUE.
2100  CONTINUE

**    Set up pointer information for output
      CALL WRSPI

      RETURN
      END
      SUBROUTINE OPCOEF
**    Function - Print spectral coefficients for model level fields at
**          current timestep
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /VARTIM/DAYT,/SPECTR/VO,D,T,Q,H,SP,/INVAR/EZ,
**          /COCNST/LDCOPR,LVCOHR,YNAMCO,/COMFLG/LVOFLG,LDFGL,
**          LTFLG,LQFLG,LSPFLG,LHFLG,/VERTCL/SIGMA,/CODIAG/NCCO
**    Com changed - none
**    Params used - /PARAM1/JPNL,/PARAM2/JPIGA,JPIGB
**    Called by - ANALYS
**    Calls - WRSPS
**    Files read - none
**    Files written - NCCO
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LDCOPR,LVCOHR
      CHARACTER*50 YNAMCO
      COMMON /COCNST/LDCOPR(JPCOMX),LVCOHR(JPNL),YNAMCO(JPCOMX)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      LOGICAL LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,LQFLG
      COMMON /COMFLG/LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,
     -      LQFLG
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      CHARACTER*50 YONAME

      WRITE(NCCO,6000)DAYT
6000  FORMAT(/' PROCESSING SPECTRAL COEFFS AT DAY',F10.2)

**    Output relative vorticity
      IF(LDCOPR(1))THEN
         IF(LVOFLG) THEN
            YONAME=YNAMCO(1)
**          Need to remove planetary vorticity
            DO 100 JI=1,JPIGB,JPIGA
            VO(JI)=VO(JI)-EZ
100         CONTINUE
            DO 110 JL=1,JPNL
            IF(LVCOHR(JL)) THEN
               WRITE(YONAME(31:36),'(F6.4)') SIGMA(JL)
               CALL WRSPS(VO(1+(JL-1)*JPIGA),1,JPIGA,YONAME)
            ENDIF
110         CONTINUE
**          Convert VO back to absolute vorticity
            DO 120 JI=1,JPIGB,JPIGA
            VO(JI)=VO(JI)+EZ
120         CONTINUE
         ELSE
            WRITE(6,6100)
6100        FORMAT(/' OPCOEF: RELATIVE VORTICITY SPECTRA NOT',
     -           ' AVAILABLE')
         ENDIF
      ENDIF

**    Output divergence
      IF(LDCOPR(2)) THEN
         IF(LDFLG) THEN
            YONAME=YNAMCO(2)
            DO 210 JL=1,JPNL
            IF(LVCOHR(JL)) THEN
               WRITE(YONAME(31:36),'(F6.4)') SIGMA(JL)
               CALL WRSPS(D(1+(JL-1)*JPIGA),2,JPIGA,YONAME)
            ENDIF
210         CONTINUE
         ELSE
            WRITE(6,6200)
6200        FORMAT(/' OPCOEF: DIVERGENCE SPECTRA NOT AVAILABLE')
         ENDIF
      ENDIF

**    Output temperature
      IF(LDCOPR(3)) THEN
         IF(LTFLG) THEN
            YONAME=YNAMCO(3)
            DO 310 JL=1,JPNL
            IF(LVCOHR(JL)) THEN
               WRITE(YONAME(31:36),'(F6.4)') SIGMA(JL)
               CALL WRSPS(T(1+(JL-1)*JPIGA),2,JPIGA,YONAME)
            ENDIF
310         CONTINUE
         ELSE
            WRITE(6,6300)
6300        FORMAT(/' OPCOEF: TEMPERATURE SPECTRA NOT AVAILABLE')
         ENDIF
      ENDIF

**    Output specific humidity
      IF(LDCOPR(4)) THEN
         IF(LQFLG) THEN
            YONAME=YNAMCO(4)
            DO 410 JL=1,JPNL
            IF(LVCOHR(JL)) THEN
               WRITE(YONAME(31:36),'(F6.4)') SIGMA(JL)
               CALL WRSPS(Q(1+(JL-1)*JPIGA),2,JPIGA,YONAME)
            ENDIF
410         CONTINUE
         ELSE
            WRITE(6,6400)
6400        FORMAT(/' OPCOEF: HUMIDITY SPECTRA NOT AVAILABLE')
         ENDIF
      ENDIF

**    Output diabatic heating
      IF(LDCOPR(5)) THEN
         IF(LHFLG) THEN
            YONAME=YNAMCO(5)
            DO 510 JL=1,JPNL
            IF(LVCOHR(JL)) THEN
               WRITE(YONAME(31:36),'(F6.4)') SIGMA(JL)
               CALL WRSPS(H(1+(JL-1)*JPIGA),2,JPIGA,YONAME)
            ENDIF
510         CONTINUE
         ELSE
            WRITE(6,6500)
6500        FORMAT(/' OPCOEF: DIABATIC HEATING SPECTRA NOT',
     -           ' AVAILABLE')
         ENDIF
      ENDIF

**    Output log of surface pressure
      IF(LDCOPR(6)) THEN
         IF(LSPFLG) THEN
            YONAME=YNAMCO(6)
            CALL WRSPS(SP(1),2,JPIGA,YONAME)
         ELSE
            WRITE(6,6600)
6600        FORMAT(/' OPCOEF: SURFACE PRESSURE SPECTRA NOT ',
     -            'AVAILABLE')
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE RDSPCF
**    Function - Controls the reading of the spectral data
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /VARTIM/NSTEPT,/COMIOC/NCHIST,/MODELC/LDRY,LDIABH,
**          BEGDYP,
**          /COMTIM/TSPD,/OUTCON/RNTAPE,/INVAR/WROTAT,CT,CTT,REFP0
**    Com changed - /SPECTR/H,SP,Q,T,VO,D,/COMFLG/all elements
**    Params used - /PARAM1/JPJG,/PARAM2/JPIGB,JPIGA
**    Called by - ANALYS
**    Calls - RCHECK,ABORT,SPECT0
**    Files read - NCHIST
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,LQFLG
      COMMON /COMFLG/LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,
     -      LQFLG
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      CHARACTER*50 YNULL
      COMMON /OUTCON/RNTAPE,YNULL
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
C      LOGICAL LOCAL1
C      SAVE LOCAL1
C      DATA LOCAL1/.TRUE./

      IPBEG=BEGDYP*TSPD
**    Define the diabatic heating spectral coefficients as
**    defining the heating rate for the parameterised physical
**    processes, excluding the linear processes of biharmonic
**    diffusion and restoration.
      IF(LDIABH.AND.(NSTEPT.GT.IPBEG)) THEN
         CALL RCHECK(NCHIST,RNTAPE,NSTEPT,TSPD)
         READ(NCHIST) ZKOUNT,ZMTAPE,ZDAY,ZRNR,H,ZMTAP1
         IF (NINT(ZRNR).NE.JPJG+2) THEN
            WRITE(6,6900) ZDAY,NINT(ZRNR),JPJG+2
6900        FORMAT(' ***ABORT IN RDSPCF AT DAY',F10.2,
     -            ' : LATITUDE COUNTER IN DATA =',I5,'  NOT',I5)
            CALL ABORT
         ENDIF
         IF(ZMTAPE.NE.ZMTAP1) THEN
            WRITE(6,6901)
6901        FORMAT(' ***ABORT IN PHYSOP AT DAY',F10.2,' : ',
     -            '/ ZMTAPE VARIATION ON HISTORY TAPE SUGGESTS SMAP ',
     -            'PARAMETERS ARE INVALID')
            CALL ABORT
         ENDIF
         LHFLG=.TRUE.
      ELSE
         CALL SPECT0(H,JPIGB,'DIABATIC HEATING')
         LHFLG=.FALSE.
      ENDIF

**    Remaining spectral data
      CALL RCHECK(NCHIST,RNTAPE,NSTEPT,TSPD)
      IF (.NOT.LDRY) THEN
C         IF(LOCAL1) THEN
C**          IREAL is the number of reals (complex counting as 2) expected
C**          when record is not a restart
C**          IREALR is the number of reals (complex counting as 2) expected
C**          when record is a restart
C            IREAL=3+JPIGB*4*2+JPIGA*2+1
C            IREALR=3+JPIGB*4*2+JPIGA*2+1+JPIGB*4*2+JPIGA*2+1
C
C**          Assume record is not a restart
C            READ(NCHIST,END=200,ERR=201,IOSTAT=IOS)(Z,I=1,IREAL+1)
C**          End of record not reached - assume record is a restart
C            BACKSPACE(NCHIST)
C            READ(NCHIST,END=200,ERR=201,IOSTAT=IOS)(Z,I=1,IREALR+1)
C**          End of record not reached - error
C            WRITE(6,6950)
C6950        FORMAT(1X,'RDSPCF: NCHIST CONTAINS MORE DATA THAN EXPECTED',
C     -            ' ABORT CALLED')
C            CALL ABORT
C**          Error condition
C201         CONTINUE
C            WRITE(6,6951)IOS
C            IF(IOS.NE.1201) CALL ABORT
C200         CONTINUE
C            LOCAL1=.FALSE.
C**          Backspace one record and proceed with read of NCHIST
C            BACKSPACE(NCHIST)
C         ENDIF
         READ(NCHIST) ZKOUNT,ZMTAPE,ZDAY,VO,D,T,Q,SP,ZMTAP1
         LVOFLG=.TRUE.
         LDFLG=.TRUE.
         LTFLG=.TRUE.
         LQFLG=.TRUE.
         LSPFLG=.TRUE.
      ELSE
C         IF(LOCAL1) THEN
C**          IREAL is the number of reals (complex counting as 2) expected
C**          when record is not a restart
C**          IREALR is the number of reals (complex counting as 2) expected
C**          when record is a restart
C            IREAL=3+JPIGB*3*2+JPIGA*2+1
C            IREALR=3+JPIGB*3*2+JPIGA*2+1+JPIGB*3*2+JPIGA*2+1
C
C**          Assume record is not a restart
C            READ(NCHIST,END=300,ERR=301,IOSTAT=IOS)(Z,I=1,IREAL+1)
C**          End of record not reached - assume record is a restart
C            BACKSPACE(NCHIST)
C            READ(NCHIST,END=300,ERR=301,IOSTAT=IOS)(Z,I=1,IREALR+1)
C**          End of record not reached - error
C            WRITE(6,6950)
C            CALL ABORT
C**          Error condition
C301         CONTINUE
C            WRITE(6,6951)IOS
C6951        FORMAT(1X,'RDSPCF: ERROR WHEN TESTING SPECTRAL RECORD LENGTH'/
C     -            ' ERROR NUMBER ',I5,/
C     -            ' NOTE THAT ERROR NUMBER .NE.1201 ON THE CRAY PROBABLY ',
C     -            ' SIGNIFIES INVALID DIMENSIONS; CHECK PARAMETERS')
C            IF(IOS.NE.1201) CALL ABORT
C300         CONTINUE
C            LOCAL1=.FALSE.
C**          Backspace one record and proceed with read of NCHIST
C            BACKSPACE(NCHIST)
C         ENDIF
         READ(NCHIST) ZKOUNT,ZMTAPE,ZDAY,VO,D,T,SP,ZMTAP1
         CALL SPECT0(Q,JPIGB,'SPECIFIC HUMIDITY')
         LVOFLG=.TRUE.
         LDFLG=.TRUE.
         LTFLG=.TRUE.
         LQFLG=.FALSE.
         LSPFLG=.TRUE.
      ENDIF
**    Note that ZMTAPE and ZMTAP1 are both zero then it is possible that
**    the SMAP parameters do not match those of the history file. The use
**    of LOCAL1 above is an attempt to get around this; it may implemented
**    in future when thoroughly tested.
      IF(ZMTAPE.NE.ZMTAP1) THEN
         WRITE(6,6901)
      ENDIF

**    Convert non-dimensional fields as read from history file into
**    dimensional fields.
**    Absolute vorticity
      IF(LVOFLG) THEN
         DO 1000 J=1,JPIGB
         VO(J)=VO(J)*WROTAT
1000     CONTINUE
      ENDIF
**    Divergence
      IF(LDFLG) THEN
         DO 1010 J=1,JPIGB
         D(J)=D(J)*WROTAT
1010     CONTINUE
      ENDIF
**    Temperature
      IF(LTFLG) THEN
         DO 1020 J=1,JPIGB
         T(J)=T(J)*CT
1020     CONTINUE
      ENDIF
**    Specific humidity
      IF(LQFLG) THEN
         DO 1030 J=1,JPIGB
         Q(J)=Q(J)*1.0
1030     CONTINUE
      ENDIF
**    Diabatic heating
      IF(LHFLG) THEN
         DO 1040 J=1,JPIGB
         H(J)=H(J)*CTT/86400.0
1040     CONTINUE
      ENDIF
**    log(surface ressure)
      IF(LSPFLG) THEN
         SP(1)=SP(1)+ALOG(REFP0)*SQRT(2.0)
      ENDIF

      RETURN
      END
      SUBROUTINE SPCFLG(LPTFTR,LPZFTR,LPTJTR)
**    Function - To determine spectral flags LGETSP (set to .TRUE.
**          if non-tracer spectral coefficient information processed by
**          this job) and LGETTR (set to .TRUE. if tracer spectral
**          information processed by this job).
**    Args in - none
**    Args out -
**               LPTFTR  - .TRUE. if transient fluxes need tracer fields
**               LPZFTR  - .TRUE. if ZF fluxes need tracer fields
**               LPTJTR  - .TRUE. if TJ code needs tracer fields
**    Args for work - none
**    Com used - /DIAGTP/LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ,
**          /COMTRV/LGCMTR,/TFDIAG/NFLDTF,/ZFDIAG/NFLDZF,/TJCNST/
**          LATTTR,LATTSG
**    Com changed - /COMFLG/LGETSP,LGETTR
**    Params used - /PARAM1/JPNL,/PARAM3/JPTFMX,JPZFMX
**    Called by - DINIT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,LQFLG
      COMMON /COMFLG/LGETSP,LGETTR,LVOFLG,LDFLG,LSPFLG,LHFLG,LTFLG,
     -      LQFLG
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LFNDAT,LATTSG,LATTTR,LTJCPY,LTJINT,LNEWAT
      CHARACTER*50 YTJFLD
      COMMON /TJCNST/LFNDAT,LATTSG,LATTTR,LTJCPY,LTJINT,TJTTOL,
     -      LNEWAT(JPTJMX),NRECAT(JPTJMX),NTJOPC(JPTJMX),NBINSQ(JPTJMX),
     -      NCTJWK,NRTJWK(JPTJMX,2),YTJFLD(JPTJMX)
      LOGICAL LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      COMMON /ZFDIAG/NCZF,NZFPR(JPZFMX),NZFPL(JPZFMX),
     -      CINTZF(JPZFMX),NVZFHR(JPNL),
     -      NZF,FACTZF(2,JPZFMX),NFLDZF(4,JPZFMX),VZFSFC(JPNL),
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      LOGICAL LPTFTR,LPZFTR,LPTJTR,LOTFSG

      LGETSP=.FALSE.
      LGETTR=.FALSE.

**    CO, SG and OD diagnostics require spectral data
      IF(LDCO.OR.LDSG.OR.LDOD) THEN
         LGETSP=.TRUE.
      ENDIF


      IF(LDTF) THEN
**       Determine if the required fields are SG or TR in type
         LOTFSG=.FALSE.
         LPTFTR=.FALSE.
         DO 100 J=1,JPTFMX
         DO 100 JI=1,4
         IF((NFLDTF(JI,J).GT.0).AND.(NFLDTF(JI,J).LT.101)) THEN
            LOTFSG=.TRUE.
         ELSE IF(NFLDTF(JI,J).GE.101) THEN
            LPTFTR=.TRUE.
         ENDIF
100      CONTINUE
         IF(LOTFSG) LGETSP=.TRUE.
         IF(LPTFTR) LGETTR=.TRUE.
      ENDIF



**    NOTE THAT IF ZONAL, MERIDIONAL OR TEMPORAL AVERAGES ARE APPLIED TO
**          NON-SURFACE FIELDS WITH NAVTYP.NE.1, THEN SPECTRAL ARRAYS
**          ARE REQUIRED IN ORDER TO DETERMINE APPROPRIATE
**          MASK/WEIGHTING FUNCTIONS.

      RETURN
      END
      SUBROUTINE SPECT0(PX,KDIM,YPNAME)
**    Function - To fill a spectral (ie complex) array with zeroes.
**    Args in -
**               PX      - Spectral array
**               KDIM    - Dimension of complex array
**               YPNAME  - Name/title  of field PX
**    Args out -
**               PX      - Spectral array filled with zeroes
**    Args for work - none
**    Com used - /VARTIM/DAYT
**    Com changed - none
**    Params used - none
**    Called by - RDSPCF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMPLEX PX
      DIMENSION PX(KDIM)
      CHARACTER*(*) YPNAME

      DO 100 JI=1,KDIM
      PX(JI)=CMPLX(0.0,0.0)
100   CONTINUE

      WRITE(6,6000)YPNAME,DAYT
6000  FORMAT(1X,'SPECT0: ',A,' ARRAY FILLED WITH ZEROES AT DAY ',F12.3)

      RETURN
      END
      SUBROUTINE WRSPS(PA,KA,KDIM,YPNAME)
**    Function - Print spectral coefficients for single field at a
**          single level.
**    Args in -
**               PA      - Array of spectral coefficients for a single
**                         level
**               KA      - Integer flag, set to 1 if odd coefficients
**                         are stored internally before the even
**                         coefficients, else set to 2
**               KDIM    - Dimension of PA
**               YPNAME  - Array name/title
**    Args out - none
**    Args for work - none
**    Com used - /INVAR/GPI,/VARTIM/DAYT,NSTEPT
**    Com changed - none
**    Params used - /PARAM1/JPNWJ2,JPNHEM
**    Called by - OPCOEF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /BLANK/MFMP,MFP,MFPP,NFMP,NFP,NFPP,SQ(JPNNP),
     -      RSQ(JPNNP)
      COMMON /CODIAG/NCCO,NCOPR(JPCOMX),NVCOHR(JPNL),NWAVET
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMPLEX PA(KDIM),FPOLAR,Z
      CHARACTER*8 YOCOEF(JPNWJ2,2)
      CHARACTER*10 YOCOF3(JPNWJ2,2)
      CHARACTER*50 YPNAME
      DIMENSION FP(JPNWJ2),IP(JPNWJ2)
      SAVE INSPC,YOCOEF,YOCOF3,FP,IP
      DATA YOCOEF/JPMJP*' (  ,  )'/,YOCOF3/JPMJP*' (   ,   )'/
**    Arithmetic function
      FPOLAR(Z)=CMPLX(CABS(Z),ATAN2(AIMAG(Z),REAL(Z)+1.0E-20)*RAD)

      RAD=180.0/GPI
      IOFF=(2-KA)*JPNWJ2
      IOFF1=(KA-1)*JPNWJ2

**    Write header information
      WRITE(NCCO,6000) YPNAME,DAYT,NSTEPT
6000  FORMAT(/,1X,A50,' DAY ',F10.2,', STEP ',I10)
      WRITE(NCCO,6010)
6010  FORMAT(1X,'SPECTRAL COEFFICIENTS : COEFF  AMPLITUDE  PHASE')

**    Write cofficients using preset arrays and pointers.
      IF(NWAVET.LT.100) THEN
         IF (JPNHEM.EQ.1) THEN
            WRITE(NCCO,6050)(YOCOEF(J,KA),FPOLAR(PA(IP(J))*FP(J)),
     -            J=1,INSPC)
6050        FORMAT(4(A8,E11.4,F8.2))
         ELSE
            WRITE(NCCO,6050)(YOCOEF(J,2),FPOLAR(PA(IP(J)+IOFF)*FP(J)),
     -            YOCOEF(J,1),FPOLAR(PA(IP(J)+IOFF1)*FP(J)),J=1,INSPC)
         ENDIF
      ELSE
         IF (JPNHEM.EQ.1) THEN
            WRITE(NCCO,6100)(YOCOF3(J,KA),FPOLAR(PA(IP(J))*FP(J)),
     -            J=1,INSPC)
6100        FORMAT(4(A10,E11.4,F8.2))
         ELSE
            WRITE(NCCO,6100)(YOCOF3(J,2),FPOLAR(PA(IP(J)+IOFF)*FP(J)),
     -            YOCOF3(J,1),FPOLAR(PA(IP(J)+IOFF1)*FP(J)),J=1,INSPC)
         ENDIF
      ENDIF

      RETURN
      ENTRY WRSPI
**    Function - Initialise pointers for output resolution in full
**    resolution spectral arrays.  Initialise character array with
**    invariant data.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /BLANK/MFP/NFP,/CODIAG/NWAVET
**    Com changed - none
**    Params used - /PARAM1/JPMOCT,/PARAM2/JPMH
**    Called by - COINIT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

**    Now determine YOCOEF/YOCOF3, IP and FP for use when outputting
**    coefficients with a total wavenumber of NWAVET or less. Also
**    compute INSPC, number of odd (or even) spectral coefficients to
**    be output.
**    I: sequential counter from 1 up to total number of coefficients
**          (odd or even) to be output
**    IP: location of the required coefficient. Thus IP represents the
**          location of the I'th odd(even) coefficient in the storage
**          sequence of odd(even) coefficients from 0,1 , 0,3 , ...
**          1,2, ... (0,0 , 0,2 , ... 1,1 , ...)
**    YOCOEF(I,j): label/title of the I'th required coefficient, where
**          j=1 is an odd title and j=2 is an even title. Likewise for
**          YOCOF3 - used when NWAVET.GT.99.
**    FP: set to 1 if MP=1, else set to 2. This factor takes into
**          account the addition of odd and even contributions to
**          the amplitude; the MP=1 (ie m=0) coefficient has only one
**          contribution.
      IF(NWAVET.LT.100) THEN
         I=0
         IG=0
         DO 20 JMP=1,MFP,JPMOCT
         IF (JMP.GT.NWAVET) GOTO 30
         IMPM=JMP-1
         IBEG=IG
         DO 10 JJ=JMP,NWAVET,JPMH
         I=I+1
         IG=IG+1
         IP(I)=IG
         IF(IMPM.EQ.0) THEN
            FP(I)=1.0
         ELSE
            FP(I)=2.0
         ENDIF
         WRITE(YOCOEF(I,1)(3:4),'(I2)')IMPM
         WRITE(YOCOEF(I,2)(3:4),'(I2)')IMPM
         WRITE(YOCOEF(I,1)(6:7),'(I2)')JJ
         WRITE(YOCOEF(I,2)(6:7),'(I2)')JJ-1
10       CONTINUE
         IG=IBEG+(NFP-JMP+2)/JPMH
20       CONTINUE
30       CONTINUE
         INSPC=I
      ELSE
         I=0
         IG=0
         DO 120 JMP=1,MFP,JPMOCT
         IF (JMP.GT.NWAVET) GOTO 130
         IMPM=JMP-1
         IBEG=IG
         DO 110 JJ=JMP,NWAVET,JPMH
         I=I+1
         IG=IG+1
         IP(I)=IG
         IF(IMPM.EQ.0) THEN
            FP(I)=1.0
         ELSE
            FP(I)=2.0
         ENDIF
         WRITE(YOCOF3(I,1)(3:5),'(I2)')IMPM
         WRITE(YOCOF3(I,2)(3:5),'(I2)')IMPM
         WRITE(YOCOF3(I,1)(7:9),'(I2)')JJ
         WRITE(YOCOF3(I,2)(7:9),'(I2)')JJ-1
110      CONTINUE
         IG=IBEG+(NFP-JMP+2)/JPMH
120      CONTINUE
130      CONTINUE
         INSPC=I
      ENDIF

      RETURN
      END
      SUBROUTINE DPDTHG(PGA,PPG,PTH,PDPDTH,PTHMID)
**    Function - Computes -(1/g)dP/dtheta at theta surfaces midway
**          between theta on model full levels.
**    Args in -
**               PGA     - Gravitational acceleration
**               PPG     - Pressure on full model levels
**               PTH     - Full-level theta values
**    Args out -
**               PDPDTH  - -(1/g)dP/dtheta array
**               PTHMID  - Theta at the mid-levels corresponding to
**                         locations where PDPDTH is computed
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPIGC,
**          JPMGPP,JPNLM
**    Called by - INTTH
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      DIMENSION PPG(JPIGC,JPNL),PTH(JPIGC,JPNL),PDPDTH(JPIGC,JPNLM),
     -      PTHMID(JPIGC,JPNLM)

      ZGA=-1.0/PGA
      IF(JPNHEM.EQ.1) THEN
         DO 100 JL=1,JPNLM
         DO 100 JI=1,JPMG
         PDPDTH(JI,JL)=ZGA*(PPG(JI,JL)-PPG(JI,JL+1))/
     -         (PTH(JI,JL)-PTH(JI,JL+1))
         PTHMID(JI,JL)=0.5*(PTH(JI,JL)+PTH(JI,JL+1))
100      CONTINUE
      ELSE
         DO 1100 JL=1,JPNLM
         DO 1100 JI=1,JPMG
         JIP=JI+JPMGPP
         PDPDTH(JI,JL)=ZGA*(PPG(JI,JL)-PPG(JI,JL+1))/
     -         (PTH(JI,JL)-PTH(JI,JL+1))
         PTHMID(JI,JL)=0.5*(PTH(JI,JL)+PTH(JI,JL+1))
         PDPDTH(JIP,JL)=ZGA*(PPG(JIP,JL)-PPG(JIP,JL+1))/
     -         (PTH(JIP,JL)-PTH(JIP,JL+1))
         PTHMID(JIP,JL)=0.5*(PTH(JIP,JL)+PTH(JIP,JL+1))
1100     CONTINUE
1200     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE GHGCR(KIL)
**    Function - Compute geopotential height field.  Integrate
**          hydrostatic equation and add orography if non-zero.
**    Args in -
**               KIL     - Second dimension index of orography
**    Args out - none
**    Args for work - none
**    Com used - /INVAR/RD,GA,CPD,/GRIDP/TG,/COMDAT/LROGR,
**          /COMROG/GSG,/COMGRM/G
**    Com changed - /GRIDP/GHG,AMSFG
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM,/PARAM2/JPIGD,JPIGC,JPMGPP
**    Called by - GRMULT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          BGFLUX (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      COMMON /COMROG/GSG(JPIGC,JPJGL)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD

**    Zero GHG AND AMSFG presets
      DO 100 J=1,JPIGD
      GHG(J)=0.0
      AMSFG(J)=0.0
100   CONTINUE

**    Integrate hydrostatic equation; the geopotential at the level
**    of sigma(r) is calculated by accumulating the geopotential
**    upwards from the surface to the half-level of sigma(r+1/2),
**    and then incrementing from level sigma(r+1/2) to sigma(r).
      IL=0
      DO 20 JL=1,JPNL
      DO 20 JK=1,JPNL
      IL=IL+1
      ZGG=G(IL)
      DO 20 JHEM=1,JPNHEM
      II=(JL-1)*JPIGC+(JHEM-1)*JPMGPP
      IKK=(JK-1)*JPIGC+(JHEM-1)*JPMGPP
      DO 20 JI=1,JPMG
      II=II+1
      IKK=IKK+1
      GHG(II)=GHG(II)+ZGG*TG(IKK)*RD/GA
20    CONTINUE

**    GHG  now contains geopotential height (metres), without orography
**    Optionally add orography (GSG in units of metres).
      IF (LROGR) THEN
         DO 300 JHEM=1,JPNHEM
         IOF=(JHEM-1)*JPMGPP
         DO 300 JJL=1,JPNL
         IK=(JJL-1)*JPIGC+IOF
         DO 300 JI=1,JPMG
         IK=IK+1
         GHG(IK)=GHG(IK)+GSG(JI+IOF,KIL)
300      CONTINUE
      ENDIF

**    Compute the Montgomery streamfunction (=gh + CpT)
      DO 400 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 400 JJL=1,JPNL
      IK=(JJL-1)*JPIGC+IOF
      DO 400 JI=1,JPMG
      IK=IK+1
      AMSFG(IK)=GHG(IK)*GA+CPD*TG(IK)
400   CONTINUE

      RETURN
      END
      SUBROUTINE GRMULT(KJH,KIL)
**    Function - to compute certain gridpoint fields on model levels
**    Args in -
**               KJH     - Current latitude
**               KIL     - Second dimension counter for orography
**    Args out - none
**    Args for work - none
**    Com used - /COMGRM/RGG,/GRIDP/UG,VG,/MODELC/TMEAN
**    Com changed - /GRIDP/APSFCG,AIRG,TG,/COMGRM/DUDLSG,DVDLSG,
**          DTDLSG
**    Params used - /PARAM1/JPNL,/PARAM2/JPIGC
**    Called by - SGFLUX
**    Calls - PCNST,NTEND,GHGCR,OMGCR,SRFCR,DLSGCR,PVCR
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UMAP (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD

**    Specify land/air mask in case output is on sigma levels
      DO 100 J=1,JPIGD
      AIRG(J)=1.0
100   CONTINUE

**    Convert Log(surface pressure) to surface pressure
      DO 10 J=1,JPIGC
10    APSFCG(J)=EXP(APSFCG(J))

**    Use TMEAN to convert temperature perturbations to temperature
      I=0
      DO 20 JL=1,JPNL
      DO 20 JI=1,JPIGC
      I=I+1
      TG(I)=TG(I)+TMEAN(JL)
20    CONTINUE

**    Compute various pressure-related arrays for gridpoint
**    calculations and interpolations at current latitude
      CALL PCNST

**    Non-linear parameterised momentum tendencies.
      CALL NTEND(KJH)

**    Geopotential height.
      CALL GHGCR(KIL)

**    Omega.
      CALL OMGCR(KJH)

**    MSL pressure and surface fields used for extrapolation.
      CALL SRFCR(KJH,KIL)

**    Vertical derivative terms
      CALL DLSGCR(JPIGC,UG,RGG,DUDLSG,JPIGC,JPNL)
      CALL DLSGCR(JPIGC,VG,RGG,DVDLSG,JPIGC,JPNL)
      CALL DLSGCR(JPIGC,TG,RGG,DTDLSG,JPIGC,JPNL)

**    Ertel potential vorticity
      CALL PVCR(KJH)

      RETURN
      END
      SUBROUTINE INTERP(PIN,POUT,KNLOUT,KINTRL,PFINTR,KOW,KXUP,KXDN,PSG,
     -      KJL,PSRF)
**    Function - Interpolate vertically from input array PIN(..,JPNL)
**          (on model levels) to output array POUT(..,KNLOUT), using
**          pre-determined factors PFINTR and levels KINTRL(..,L) and
**          KINTRL(..,L+1) in input data for level L in output data.
**          Extrapolation requirements are determined using model
**          pressures on full levels.
**    Args in -
**               PIN     - Input array on model levels
**               KNLOUT  - Number of levels of output data
**               KINTRL  - Array containing level information for
**                         interpolation
**               PFINTR  - Interpolation factor
**               KOW     - If set to 1, then PIN will be overwritten
**                         with interpolated data
**               KXUP    - Upward  ) extrapolation
**               KXDN    - Downward) options
**                         Current extrapolation options are:
**                         Upward  : KXUP=0: constant value above
**                                           PSG(,1)
**                                        1: same as interpolation
**                                        2: linear interp in p, to zero
**                                           value at p=0
**                         Downward: KXDN=0: constant value below
**                                           PSG(,JPNL)
**                                        1: same as interpolation
**                                        2: interp to surface omega,
**                                           constant below
**                                        3: temperature: const lapse
**                                           below PSG(,JPNL)
**                                        4: Geopotential: based on
**                                           constant lapse
**                                        5: constant down to surface,
**                                           zero below
**               PSG     - Pressure on full model levels
**               KJL     - Second dimension counter for orography
**               PSRF    - Surface pressure
**    Args out -
**               PIN     - If KOW=1, interpolated data is overwritten on
**                         first KNLOUT levels
**               POUT    - Interpolated data
**    Args for work - none
**    Com used - /COMPRL/APSGMX,APSGMN,OMSRF,XLAPSE,TSRF,
**          /LVDIAG/SFCOUT,/COMROG/GSG,/INVAR/RD
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM,/PARAM2/JPIGC,JPMGPP
**    Called by - INTPR
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          subroutine INTER in UMAP (SMAP version)

**    NB.  /COMGRM/ should not be called as it contains KINTRL.
**    NB.  /GRIDP/ should not be called as it can contain PIN.

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /COMROG/GSG(JPIGC,JPJGL)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      DIMENSION KINTRL(JPIGC,KNLOUT)
      DIMENSION PIN(JPIGC,JPNL),POUT(JPIGC,KNLOUT),
     -      PFINTR(JPIGC,KNLOUT),PSG(JPIGC,JPNL),PSRF(JPIGC)

**    Set extrapolation switches.  Override input options if no extrap.
      IXUP=KXUP
      IXDN=KXDN

      IF(IXUP.LT.0.OR.IXUP.GT.2) THEN
         WRITE(6,6000) IXUP
6000     FORMAT(/' ***ABORT IN INTERP: IXUP = ',I3,' NOT ALLOWED')
         CALL ABORT
      ENDIF
      IF(IXDN.LT.0.OR.IXDN.GT.5) THEN
         WRITE(6,6010) IXDN
6010     FORMAT(/' ***ABORT IN INTERP: IXDN = ',I3,' NOT ALLOWED')
         CALL ABORT
      ENDIF
      IF((KNLOUT.GT.JPNL).AND.(KOW.EQ.1)) THEN
         WRITE(6,6020)KNLOUT,JPNL
6020     FORMAT(/' *** ABORT IN INTERP; KNLOUT>JPNL ',2I5)
         CALL ABORT
      ENDIF

**    Now compute output array
      DO 300 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP

**    First perform interpolation and implied extrapolation using
**    default factors.
      DO 5 JN=1,KNLOUT
      DO 5 JI=1,JPMG
      II=JI+IOF
      ILM=KINTRL(II,JN)
5     POUT(II,JN)=PIN(II,ILM)+PFINTR(II,JN)*(PIN(II,ILM+1)-PIN(II,ILM))

C     Upward extrapolation.  Skip levels for which pressure level is
C     wholly below top model level.
      IF(IXUP.NE.1) THEN
         DO 90 JN=1,KNLOUT
         IF(SFCOUT(JN).LT.APSGMX(1,JHEM)) THEN
            IF(IXUP.EQ.0) THEN
               DO 10 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).LT.PSG(II,1)) POUT(II,JN)=PIN(II,1)
10             CONTINUE
            ELSE IF(IXUP.EQ.2) THEN
               DO 20 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).LT.PSG(II,1))
     -               POUT(II,JN)=PIN(II,1)*SFCOUT(JN)/PSG(II,1)
20             CONTINUE
            ENDIF
         ENDIF
90       CONTINUE
      ENDIF

**    Downward extrapolation.  Skip levels for which pressure level is
**    wholly above bottom model level.
      IF(IXDN.NE.1) THEN
         DO 190 JN=1,KNLOUT
         IF(SFCOUT(JN).GT.APSGMN(JPNL,JHEM)) THEN
            IF(IXDN.EQ.0) THEN
               DO 110 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).GT.PSG(II,JPNL)) POUT(II,JN)=PIN(II,JPNL)
110            CONTINUE
            ELSE IF(IXDN.EQ.2) THEN
               DO 120 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).GT.PSRF(II)) POUT(II,JN)=OMSRF(II)
               IF(SFCOUT(JN).GT.PSG(II,JPNL).AND.SFCOUT(JN).LE.PSRF(II))
     -               POUT(II,JN)=PIN(II,JPNL)+(OMSRF(II)-PIN(II,JPNL))*
     -               (SFCOUT(JN)-PSG(II,JPNL))/(PSRF(II)-PSG(II,JPNL))
120            CONTINUE
            ELSE IF(IXDN.EQ.3) THEN
               DO 130 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).GT.PSG(II,JPNL))
     -               POUT(II,JN)=PIN(II,JPNL)*((SFCOUT(JN)/PSG(II,JPNL))
     -               **XLAPSE)
130            CONTINUE
            ELSE IF(IXDN.EQ.4) THEN
               DO 140 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).GT.PSRF(II))
     -               POUT(II,JN)=GSG(II,KJL)-(TSRF(II)*RD/(GA*XLAPSE))*
     -               ((SFCOUT(JN)/PSRF(II))**XLAPSE-1.)
               IF(SFCOUT(JN).GT.PSG(II,JPNL).AND.SFCOUT(JN).LE.PSRF(II))
     -               POUT(II,JN)=PIN(II,JPNL)+(GSG(II,KJL)-
     -               PIN(II,JPNL))*ALOG(SFCOUT(JN)/PSG(II,JPNL))/
     -               ALOG(PSRF(II)/PSG(II,JPNL))
140            CONTINUE
            ELSE IF(IXDN.EQ.5) THEN
               DO 150 JI=1,JPMG
               II=JI+IOF
               IF(SFCOUT(JN).GT.PSRF(II)) POUT(II,JN)=0.0
               IF(SFCOUT(JN).GT.PSG(II,JPNL).AND.SFCOUT(JN).LE.PSRF(II))
     -               POUT(II,JN)=PIN(II,JPNL)
150            CONTINUE
            ENDIF
         ENDIF
190      CONTINUE
      ENDIF

**    Copy to overwrite the input array if requested.
      IF(KOW.EQ.1) THEN
         DO 210 JN=1,KNLOUT
         DO 210 JI=1,JPMG
         II=JI+IOF
         PIN(II,JN)=POUT(II,JN)
210      CONTINUE
      ENDIF
300   CONTINUE

      RETURN
      END
      SUBROUTINE INTERT(PIN,POUT,KNLOUT,KINTRL,PFINTR,KOW,PTHSRF,
     -      PFILL,PTHG,KXUP,KXDN)
**    Function - Interpolate vertically from input array PIN(..,JPNL)
**          (on model levels) to output array POUT(..,KNLOUT), using
**          pre-determined factors PFINTR and levels KINTRL(..,L) and
**          KINTRL(..,L+1) in input data for level L in output data.
**          Extrapolation requirements are determined using model
**          theta at surface.
**    Args in -
**               PIN     - Input array on model levels
**               KNLOUT  - Number of levels of output data
**               KINTRL  - Array containing level information for
**                         interpolation
**               PFINTR  - Interpolation factor
**               KOW     - If set to 1, then PIN will be overwritten
**                         with interpolated data
**               PTHSRF  - Surface theta
**               PFILL   - Value to be assigned to all gridpoints below
**                         surface
**               PTHG    - Theta on full model levels
**               KXUP    - Upward  ) extrapolation
**               KXDN    - Downward) options
**                         Current extrapolation options are:
**                         Upward  : KXUP=0: constant value above
**                                           PTHG(,1)
**                                        1: same as interpolation
**                         Downward: KXDN=1: same as interpolation
**    Args out -
**               PIN     - If KOW=1, interpolated data is overwritten on
**                         first KNLOUT levels
**               POUT    - Interpolated data
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /LVDIAG/SFCOUT
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM,/PARAM2/JPIGC,JPMGPP
**    Called by - INTTH
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      DIMENSION KINTRL(JPIGC,KNLOUT)
      DIMENSION PIN(JPIGC,JPNL),POUT(JPIGC,KNLOUT),PTHG(JPIGC,KNLOUT),
     -      PFINTR(JPIGC,KNLOUT),PTHSRF(JPIGC)

      IF(KXUP.LT.0.OR.KXUP.GT.1) THEN
         WRITE(6,6000) KXUP
6000     FORMAT(/' ***ABORT IN INTERT: KXUP = ',I3,' NOT ALLOWED')
         CALL ABORT
      ENDIF
      IF(KXDN.LT.1.OR.KXDN.GT.1) THEN
         WRITE(6,6010) KXDN
6010     FORMAT(/' ***ABORT IN INTERT: KXDN = ',I3,' NOT ALLOWED')
         CALL ABORT
      ENDIF
      IF((KNLOUT.GT.JPNL).AND.(KOW.EQ.1)) THEN
         WRITE(6,6020)KNLOUT,JPNL
6020     FORMAT(/' *** ABORT IN INTERT; KNLOUT>JPNL ',2I5)
         CALL ABORT
      ENDIF

**    Now compute output array
      DO 300 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP

**    First perform interpolation and implied extrapolation using
**    default factors.
      DO 5 JN=1,KNLOUT
      DO 5 JI=1,JPMG
      II=JI+IOF
      ILM=KINTRL(II,JN)
5     POUT(II,JN)=PIN(II,ILM)+PFINTR(II,JN)*(PIN(II,ILM+1)-PIN(II,ILM))

**    Now flag points below the lower model surface with values suitable
**    for plotting
      DO 10 JN=1,KNLOUT
      DO 10 JI=1,JPMG
      II=JI+IOF
      IF(SFCOUT(JN).LT.PTHSRF(II)) POUT(II,JN)=PFILL
10    CONTINUE

      IF(KXUP.EQ.0) THEN
         DO 1000 JN=1,KNLOUT
         DO 1000 JI=1,JPMG
         II=JI+IOF
         IF(SFCOUT(JN).GT.PTHG(II,1)) POUT(II,JN)=PIN(II,1)
1000     CONTINUE
      ENDIF

**    Copy to overwrite the input array if requested.
      IF(KOW.EQ.1) THEN
         DO 210 JN=1,KNLOUT
         DO 210 JI=1,JPMG
         II=JI+IOF
         PIN(II,JN)=POUT(II,JN)
210      CONTINUE
      ENDIF
300   CONTINUE

      RETURN
      END
      SUBROUTINE INTPR(KJL,LPTR)
**    Function - interpolate from model levels to isobaric levels.
**    Args in -
**               KJL     - Second dimension counter for orography
**               LPTR    - .TRUE. if tracers to be interpolated
**    Args out - none
**    Args for work - none
**    Com used - /LVDIAG/SFCOUT,/INVAR/REFP0,AKAP,/GRIDP/APSFCG,
**          /COMTRV/NTRCRS
**    Com changed - /COMGRM/NINTRL,/GRIDP/VOG,DG,GHG,OMG,UG,VG,TG,
**          QG,HG,FUG,FVG,APG,EPVG,THG,CHIG,AIRG,AMSFG,
**          /INVAR/AKAP,REFP0,GA,CPD,/TRPTR/TRCRG
**    Params used - /PARAM1/JPNHEM,JPMG,JPNL,JPTRUP,JPTRDN,
**          /PARAM2/JPMGPP,JPNLM
**    Called by - SGFLUX
**    Calls - INTERP
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UMAP (SMAP version0

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LPTR
      DIMENSION ZFINTR(JPIGC,JPNL),ZWKINT(JPIGC,JPNL)
      DIMENSION ZPSG(JPIGC,JPNL)
      EQUIVALENCE (ZPSG(1,1),APG(1))

      DO 200 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP

**    First set up array NINTRL containing model level directly above
**    required pressure level.
      DO 30 JI=1,JPMG
      II=JI+IOF
      ILM=1
      DO 30 JN=1,JPNL
      ILMIN=ILM+1
      DO 10 IL=ILMIN,JPNLM
      IF (SFCOUT(JN).LE.ZPSG(II,IL)) GOTO 20
10    ILM=ILM+1
20    NINTRL(II,JN)=ILM
30    CONTINUE

**    Set up interpolation factors in array ZFINTR for linear
**    interpolation in ln(p).
      DO 40 JN=1,JPNL
      DO 40 JI=1,JPMG
      II=JI+IOF
      ILM=NINTRL(II,JN)
      ILP=ILM+1
      ZFINTR(II,JN)=ALOG(SFCOUT(JN)/ZPSG(II,ILM))/
     -      ALOG(ZPSG(II,ILP)/ZPSG(II,ILM))
40    CONTINUE

200   CONTINUE

**    Now interpolate and extrapolate fields.
**    Vorticity and divergence no longer interpolated - now computed
**          from UG and VG
CC      CALL INTERP(VOG,ZWKINT,JPNL,NINTRL,ZFINTR,1,1,0,ZPSG,KJL,
CC     -      APSFCG)
CC      CALL INTERP(DG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,0,ZPSG,KJL,
CC     -      APSFCG)
      CALL INTERP(GHG,ZWKINT,JPNL,NINTRL,ZFINTR,1,1,4,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(OMG,ZWKINT,JPNL,NINTRL,ZFINTR,1,2,2,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(UG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,1,5,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(VG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,1,5,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(TG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,3,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(QG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,0,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(HG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,5,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(FUG,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,5,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(FVG,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,5,ZPSG,KJL,
     -      APSFCG)
      CALL INTERP(EPVG,ZWKINT,JPNL,NINTRL,ZFINTR,1,0,5,ZPSG,KJL,
     -      APSFCG)

**    Interpolated pressure values given by SFCOUT
**    Interpolated potential temperature from pressure and temperature
**    Montgomery streamfunction from temperature and geopotential
**          height
      DO 400 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 405 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 410 JI=1,JPMG
      IK=JI+IOFL+IOF
      APG(IK)=SFCOUT(JL)
      ZMKG=(APG(IK)/REFP0)**(-AKAP)
      THG(IK)=TG(IK)*ZMKG
      AMSFG(IK)=GA*GHG(IK)+CPD*TG(IK)
410   CONTINUE
405   CONTINUE
400   CONTINUE

**    Compute air/land mask array (1 above ground, 0 below ground)
      DO 500 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 500 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 500 JI=1,JPMG
      IK=JI+IOFL+IOF
      IF(APG(IK).LE.APSFCG(JI+IOF)) THEN
         AIRG(IK)=1.0
      ELSE
         AIRG(IK)=0.0
      ENDIF
500   CONTINUE

      RETURN
      END
      SUBROUTINE INTTH(KJL,LPTR)
**    Function - to interpolate from model levels to theta levels
**    Args in -
**               KJL     - Second dimension counter for orography
**               LPTR    - .TRUE. if tracers to be processed
**    Args out - none
**    Args for work - none
**    Com used - /LVDIAG/SFCOUT,/COMPRL/THSRF,/COMMSK/AMSKV,AMSKVC,
**          /INVAR/CPD,GA,REFP0,AKAP,/CWORK/WORKM,/COMTRV/NTRCRS
**    Com changed - /GRIDP/VOG,DG,GHG,OMG,UG,VG,TG,QG,HG,FUG,
**          FVG,EPVG,APG,THG,AMSFG,AIRG,/COMGRM/NINTRL,/TRPTR/TRCRG
**    Params used - /PARAM1/JPMG,JPNHEM,JPNL,JPTRUP,JPTRDN,
**          /PARAM2/JPIGC,JPMGPP,JPJGG,JPNLP
**    Called by - SGFLUX
**    Calls - INTERT,DPDTHG,INTTH2
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code written by
**          D Lucic in UFLUX2H (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LPTR
      DIMENSION ZFINTR(JPIGC,JPNL),ZWKINT(JPIGC,JPNL)
      DIMENSION ZTHG(JPIGC,JPNL),ZHTH(JPIGC,JPNLM)
      EQUIVALENCE (ZTHG(1,1),THG(1))
      EQUIVALENCE (ZHTH(1,1),WORKM(1,1))
      DIMENSION ZTHMIN(JPIGC)

**    Compute the minimum potential temperature in each column
      DO 2000 JH=1,JPNHEM
      IOF=(JH-1)*JPMGPP
      DO 2000 JI=1,JPMG
      II=JI+IOF
C*****hack:limit on exponent for single prec ifc
C     ZTHMIN(II)=10.0E40
      ZTHMIN(II)=10.0E35
      DO 2100 JL=1,JPNL
      ZTHMIN(II)=AMIN1(ZTHMIN(II),ZTHG(II,JL))
2100  CONTINUE
2000  CONTINUE


**    Compute -(1/g)dP/d(theta and store, temporarily, in AIRG
**    ZHTH contains theta at locations where AIRG is filled
      CALL DPDTHG(GA,APG,THG,AIRG,ZHTH)

**    Interpolate contents of AIRG to SFCOUT levels
      DO 1200 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP

**    First set up array NINTRL containing model level directly above
**    required theta level.
      DO 130 JI=1,JPMG
      II=JI+IOF
      ILM=1
      DO 130 JN=1,JPNL
      ILMIN=ILM+1
      DO 110 IL=ILMIN,JPNLM-1
      IF (SFCOUT(JN).GT.ZHTH(II,IL)) GOTO 120
110   ILM=ILM+1
120   NINTRL(II,JN)=ILM
130   CONTINUE

**    Set up interpolation factors in array ZFINTR for linear
**    interpolation in theta.
      DO 140 JN=1,JPNL
      DO 140 JI=1,JPMG
      II=JI+IOF
      ILM=NINTRL(II,JN)
      ILP=ILM+1
      ZFINTR(II,JN)=(SFCOUT(JN)-ZHTH(II,ILM))/
     -      (ZHTH(II,ILP)-ZHTH(II,ILM))
140   CONTINUE
1200  CONTINUE

**    Now interpolate and extrapolate contents of AIRG
      CALL INTTH2(AIRG,JPNL,JPNLM,ZWKINT,JPNL,NINTRL,ZFINTR,
     -      1,1,1,ZTHMIN,0.0,ZHTH)

**    Interpolate fields to SFCOUT output levels
      DO 200 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP

**    First set up array NINTRL containing model level directly above
**    required theta level.
      DO 30 JI=1,JPMG
      II=JI+IOF
      ILM=1
      DO 30 JN=1,JPNL
      ILMIN=ILM+1
      DO 10 IL=ILMIN,JPNLM
      IF (SFCOUT(JN).GT.ZTHG(II,IL)) GOTO 20
10    ILM=ILM+1
20    NINTRL(II,JN)=ILM
30    CONTINUE

**    Set up interpolation factors in array ZFINTR for linear
**    interpolation in theta.
      DO 40 JN=1,JPNL
      DO 40 JI=1,JPMG
      II=JI+IOF
      ILM=NINTRL(II,JN)
      ILP=ILM+1
      ZFINTR(II,JN)=(SFCOUT(JN)-ZTHG(II,ILM))/
     -      (ZTHG(II,ILP)-ZTHG(II,ILM))
40    CONTINUE
200   CONTINUE

**    Now interpolate and extrapolate fields.
**    Vorticity and divergence no longer interpolated - now computed
**          from UG and VG
CC      CALL INTERT(VOG,ZWKINT,JPNL,NINTRL,ZFINTR,1,THSRF,0.0,ZTHG,1,1)
CC      CALL INTERT(DG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,THSRF,0.0,ZTHG,1,1)
      CALL INTERT(GHG,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,AMSKV,
     -      ZTHG,1,1)
      CALL INTERT(OMG,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,AMSKV,
     -      ZTHG,1,1)
      CALL INTERT(UG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,0.0,
     -      ZTHG,1,1)
      CALL INTERT(VG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,0.0,
     -      ZTHG,1,1)
      CALL INTERT(TG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,AMSKV,
     -      ZTHG,0,1)
      CALL INTERT(QG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,AMSKV,
     -      ZTHG,1,1)
      CALL INTERT(HG ,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,AMSKV,
     -      ZTHG,1,1)
      CALL INTERT(FUG,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,0.0,
     -      ZTHG,1,1)
      CALL INTERT(FVG,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,0.0,
     -      ZTHG,1,1)
      CALL INTERT(EPVG,ZWKINT,JPNL,NINTRL,ZFINTR,1,ZTHMIN,AMSKV,
     -      ZTHG,1,1)
CC      CALL INTERT(APG,ZWKINT,JPNL,NINTRL,ZFINTR,1,THSRF,REFP0,
CC     -      ZTHG,1,1)

**    Compute air/land mask array (1 above ground, 0 below ground)
**    Montgomery streamfunction obtained from temperature and
**          geopotential height
**    Copy contents of AIRG into THG, and then compute AIRG mask
**    Compute pressure from temperature and potential temperature.
      ZRAKAP=1.0/AKAP
      DO 400 JL=1,JPNL
      ZTHETA=SFCOUT(JL)
      IOFL=(JL-1)*JPIGC
      DO 405 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 410 JI=1,JPMG
      IK=JI+IOFL+IOF
      THG(IK)=AIRG(IK)
      IF(ZTHETA.GT.ZTHMIN(JI+IOF)) THEN
CC         ZMKG=(APG(IK)/REFP0)**(AKAP)
CC         TG(IK)=ZTHETA*ZMKG
         APG(IK)=REFP0*(TG(IK)/ZTHETA)**ZRAKAP
         AMSFG(IK)=GA*GHG(IK)+CPD*TG(IK)
         AIRG(IK)=1.0
      ELSE
         APG(IK)=AMSKV
         AMSFG(IK)=AMSKV
         AIRG(IK)=0.0
      ENDIF
410   CONTINUE
405   CONTINUE
400   CONTINUE

      RETURN
      END
      SUBROUTINE INTTH2(PIN,KDIM,KDATA,POUT,KNLOUT,KINTRL,PFINTR,KOW,
     -      KXUP,KXDN,PTHSRF,PFILL,PHTH)
**    Function - Interpolate vertically from input array PIN(..,KDIM)
**          to output array POUT(..,KNLOUT), using
**          pre-determined factors PFINTR and levels KINTRL(..,L) and
**          KINTRL(..,L+1) in input data for level L in output data.
**    Args in -
**               PIN     - Input array
**               KDIM    - Vertical dimension of PIN
**               KDATA   - Number of levels of PIN that contain data
**                         upon entry
**               KNLOUT  - Number of levels of output data
**               KINTRL  - Array containing level information for
**                         interpolation
**               PFINTR  - Interpolation factor
**               KOW     - If set to 1, then PIN will be overwritten
**                         with interpolated data
**               KXUP    - Upward  ) extrapolation
**               KXDN    - Downward) options
**                         Current extrapolation options are:
**                         Upward  : KXUP=1: constant value above
**                                           PHTH(,1)
**                                        0: same as interpolation
**                         Downward: KXDN=0: same as interpolation
**                                        1: constant down to surface,
**                                           PFILL below
**               PTHSRF  - Surface theta
**               PFILL   - Value to apply below ground, dependent upon
**                         KXDN value
**               PHTH    - Theta values at locations where PIN is
**                         defined upon entry
**    Args out -
**               PIN     - If KOW=1, interpolated data is overwritten on
**                         first KNLOUT levels
**               POUT    - Interpolated data
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /LVDIAG/SFCOUT
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNHEM,/PARAM2/JPIGC,JPMGPP
**    Called by - INTTH
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      DIMENSION KINTRL(JPIGC,KNLOUT)
      DIMENSION PIN(JPIGC,KDIM),POUT(JPIGC,KNLOUT),PHTH(JPIGC,KDIM),
     -      PFINTR(JPIGC,KNLOUT),PTHSRF(JPIGC)

**    Set extrapolation switches.  Override input options if no extrap.
      IXUP=KXUP
      IXDN=KXDN

      IF(IXUP.LT.0.OR.IXUP.GT.1) THEN
         WRITE(6,6000) IXUP
6000     FORMAT(/' ***ABORT IN INTTH2: IXUP = ',I3,' NOT ALLOWED')
         CALL ABORT
      ENDIF
      IF(IXDN.LT.0.OR.IXDN.GT.1) THEN
         WRITE(6,6010) IXDN
6010     FORMAT(/' ***ABORT IN INTTH2: IXDN = ',I3,' NOT ALLOWED')
         CALL ABORT
      ENDIF
      IF((KNLOUT.GT.JPNL).AND.(KOW.EQ.1)) THEN
         WRITE(6,6020)KNLOUT,JPNL
6020     FORMAT(/' *** ABORT IN INTERT; KNLOUT>JPNL ',2I5)
         CALL ABORT
      ENDIF

**    Now compute output array
      DO 300 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP

**    First perform interpolation and implied extrapolation using
**    default factors.
      DO 5 JN=1,KNLOUT
      DO 5 JI=1,JPMG
      II=JI+IOF
      ILM=KINTRL(II,JN)
5     POUT(II,JN)=PIN(II,ILM)+PFINTR(II,JN)*(PIN(II,ILM+1)-PIN(II,ILM))

**    Upward extrapolation
      IF(IXUP.EQ.1) THEN
         DO 1000 JN=1,KNLOUT
         DO 1000 JI=1,JPMG
         II=JI+IOF
         IF(SFCOUT(JN).GT.PHTH(II,1)) POUT(II,JN)=PIN(II,1)
1000     CONTINUE
      ENDIF

**    Downward extrapolation
      IF(IXDN.EQ.1) THEN
         DO 2000 JN=1,KNLOUT
         DO 2000 JI=1,JPMG
         II=JI+IOF
         IF(SFCOUT(JN).LT.PTHSRF(II)) THEN
            POUT(II,JN)=PFILL
         ELSE IF(SFCOUT(JN).LT.PHTH(II,KDATA)) THEN
            POUT(II,JN)=PIN(II,KDATA)
         ENDIF
2000     CONTINUE
      ENDIF

**    Copy to overwrite the input array if requested.
      IF(KOW.EQ.1) THEN
         DO 210 JN=1,KNLOUT
         DO 210 JI=1,JPMG
         II=JI+IOF
         PIN(II,JN)=POUT(II,JN)
210      CONTINUE
      ENDIF
300   CONTINUE

      RETURN
      END
      SUBROUTINE MSSFAC(LPTR)
**    Function - to create mass-weighted fields on isentropic surfaces
**          by multiplying together the basic field and the mass-
**          weighting function (-1/g)d(P)/d(theta)
**    Args in -
**               LPTR    - .TRUE. if tracers are to be mass-weighted
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/THG,/COMTRV/NTRCRS,JPITRG
**    Com changed - /GRIDP/UG,VG,OMG,TG,GHG,QG,HG,EPVG,FUG,FVG,AMSFG,
**          /TRPTR/TRCRG
**    Params used - /PARAM1/JPNL,JPNHEM.JPMG,/PARAM2/JPMGPP,JPIGC
**    Called by - SGFLUX
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      LOGICAL LPTR
      DIMENSION ZTHG(JPIGC,JPNL),ZUG(JPIGC,JPNL),ZVG(JPIGC,JPNL),
     -      ZOMG(JPIGC,JPNL),ZTG(JPIGC,JPNL),ZGHG(JPIGC,JPNL),
     -      ZQG(JPIGC,JPNL),ZHG(JPIGC,JPNL),ZEPVG(JPIGC,JPNL),
     -      ZFUG(JPIGC,JPNL),ZFVG(JPIGC,JPNL),ZAMSFG(JPIGC,JPNL)
      EQUIVALENCE(ZTHG(1,1),THG(1)),(ZUG(1,1),UG(1)),(ZVG(1,1),VG(1)),
     -      (ZOMG(1,1),OMG(1)),(ZTG(1,1),TG(1)),(ZGHG(1,1),GHG(1)),
     -      (ZQG(1,1),QG(1)),(ZHG(1,1),HG(1)),(ZEPVG(1,1),EPVG(1)),
     -      (ZFUG(1,1),FUG(1)),(ZFVG(1,1),FVG(1)),(ZAMSFG(1,1),AMSFG(1))

**    Only the following fields are mass-weighted:
**       Zonal wind
**       Meridional wind
**           The above two effectively ensure that the streamfunction,
**           relative vorticity, divergence and velocity potential are
**           also mass-weighted.
**       Omega (vertical velocity)
**       Temperature
**       Geopotential height
**       Specific humidity
**       Diabatic heating
**       Potential vorticity
**       Non-linear momentum tendencies (both components)
**       Montgomery streamfunction,
**    along with tracers if LPTR is .TRUE.

**    Note that ZTHG contains the mass-weighting function

      IF(JPNHEM.EQ.1) THEN
         DO 100 JL=1,JPNL
         DO 100 JI=1,JPMG
         ZUG(JI,JL)=ZUG(JI,JL)*ZTHG(JI,JL)
         ZVG(JI,JL)=ZVG(JI,JL)*ZTHG(JI,JL)
         ZOMG(JI,JL)=ZOMG(JI,JL)*ZTHG(JI,JL)
         ZTG(JI,JL)=ZTG(JI,JL)*ZTHG(JI,JL)
         ZGHG(JI,JL)=ZGHG(JI,JL)*ZTHG(JI,JL)
         ZQG(JI,JL)=ZQG(JI,JL)*ZTHG(JI,JL)
         ZHG(JI,JL)=ZHG(JI,JL)*ZTHG(JI,JL)
         ZEPVG(JI,JL)=ZEPVG(JI,JL)*ZTHG(JI,JL)
         ZFUG(JI,JL)=ZFUG(JI,JL)*ZTHG(JI,JL)
         ZFVG(JI,JL)=ZFVG(JI,JL)*ZTHG(JI,JL)
         ZAMSFG(JI,JL)=ZAMSFG(JI,JL)*ZTHG(JI,JL)
100      CONTINUE
      ELSE
         DO 1100 JL=1,JPNL
         DO 1100 JI=1,JPMG
         JIP=JI+JPMGPP
         ZUG(JI,JL)=ZUG(JI,JL)*ZTHG(JI,JL)
         ZVG(JI,JL)=ZVG(JI,JL)*ZTHG(JI,JL)
         ZOMG(JI,JL)=ZOMG(JI,JL)*ZTHG(JI,JL)
         ZTG(JI,JL)=ZTG(JI,JL)*ZTHG(JI,JL)
         ZGHG(JI,JL)=ZGHG(JI,JL)*ZTHG(JI,JL)
         ZQG(JI,JL)=ZQG(JI,JL)*ZTHG(JI,JL)
         ZHG(JI,JL)=ZHG(JI,JL)*ZTHG(JI,JL)
         ZEPVG(JI,JL)=ZEPVG(JI,JL)*ZTHG(JI,JL)
         ZFUG(JI,JL)=ZFUG(JI,JL)*ZTHG(JI,JL)
         ZFVG(JI,JL)=ZFVG(JI,JL)*ZTHG(JI,JL)
         ZAMSFG(JI,JL)=ZAMSFG(JI,JL)*ZTHG(JI,JL)
         ZUG(JIP,JL)=ZUG(JIP,JL)*ZTHG(JIP,JL)
         ZVG(JIP,JL)=ZVG(JIP,JL)*ZTHG(JIP,JL)
         ZOMG(JIP,JL)=ZOMG(JIP,JL)*ZTHG(JIP,JL)
         ZTG(JIP,JL)=ZTG(JIP,JL)*ZTHG(JIP,JL)
         ZGHG(JIP,JL)=ZGHG(JIP,JL)*ZTHG(JIP,JL)
         ZQG(JIP,JL)=ZQG(JIP,JL)*ZTHG(JIP,JL)
         ZHG(JIP,JL)=ZHG(JIP,JL)*ZTHG(JIP,JL)
         ZEPVG(JIP,JL)=ZEPVG(JIP,JL)*ZTHG(JIP,JL)
         ZFUG(JIP,JL)=ZFUG(JIP,JL)*ZTHG(JIP,JL)
         ZFVG(JIP,JL)=ZFVG(JIP,JL)*ZTHG(JIP,JL)
         ZAMSFG(JIP,JL)=ZAMSFG(JIP,JL)*ZTHG(JIP,JL)
1100     CONTINUE
1200     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE NTEND(KJH)
**    Function - calculates non-linear momentum tendencies from
**          boundary layer and vertical diffusion schemes
**    Args in -
**               KJH     - Current latitude
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/UG,VG,TG,/MODELC/BEGDYP,LBL,LVD,CD,AKVV,
**          /VERTCL/SIGMA,SIGMAH,DSIGMA,/COMTIM/TSPD,/VARTIM/
**          NSTEPT,/INVAR/GA,RD,BLVAD,/PHYSC/TSTAR,/LEGAU/SECSQ,CS
**    Com changed - /GRIDP/FUG,FVG
**    Params used - /PARAM1/JPMG,JPNHEM,JPNL,/PARAM2/JPIGD,JPIGC,
**          JPNLM,JPMGPP
**    Called by - GRMULT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          BGFLUX (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LHISPH,LHISXP,LDRY,LDIABH,LBL,LVD
      COMMON /MODELC/TMEAN(JPNL),LHISPH,LHISXP,LDRY,LDIABH,BEGDYP,LBL,
     -      LVD,AKVV,CD
      COMMON /PHYSC/TSTAR(JPJG,JPNHEM),QSTAR(JPJG,JPNHEM)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      DIMENSION ZFACU(JPMG),ZFACL(JPMG)
      LOGICAL LOCALL,LOCALB,LOCALV
      SAVE LOCALL,LOCALB,LOCALV
      DATA LOCALL/.TRUE./,LOCALB/.TRUE./,LOCALV/.TRUE./

**    FUG and FVG set to zero if no parameterisations switched on
**          at current analysis time.
      DO 100 J=1,JPIGD
      FUG(J)=0.0
      FVG(J)=0.0
100   CONTINUE

      IPBEG=BEGDYP*TSPD
      IF(NSTEPT.LE.IPBEG.AND.LOCALL) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***NTEND : WARNING : FUG AND FVG CURRENTLY SET'
     -         ,' TO ZERO')
         LOCALL=.FALSE.
         RETURN
      ENDIF

**    Boundary layer scheme.
**    Momentum tendencies at lowest model level associated with surface
**    fluxes.  Bulk aerodynamic formula without stability dependence.
      IF(LBL) THEN
         ZFACT=(GA*CD)/(CS(KJH)*RD*DSIGMA(JPNL))
         DO 30 JH=1,JPNHEM
         IOF=JPNLM*JPIGC+(JH-1)*JPMGPP
         DO 20 JI=1,JPMG
         II=IOF+JI
**       ZVM - velocity amplitude
         ZVM=SQRT(SECSQ(KJH)*(UG(II)*UG(II)+VG(II)*VG(II)))+BLVAD
         FUG(II)=FUG(II)-UG(II)*ZVM*ZFACT/TSTAR(KJH,JH)
         FVG(II)=FVG(II)-VG(II)*ZVM*ZFACT/TSTAR(KJH,JH)
20       CONTINUE
30       CONTINUE
         IF(LOCALB) THEN
            WRITE(6,6010)
6010        FORMAT(1X,'***NTEND : NOTE : FUG AND FVG CURRENTLY '
     -            ,' INCLUDE BOUNDARY LAYER EFFECTS')
            LOCALB=.FALSE.
         ENDIF
      ENDIF

**    Vertical diffusion scheme.
**    Linear diffusive flux throughout model depth with constant coeff.
      IF (LVD) THEN
         ZFACT=(GA*GA)/(RD*RD*CS(KJH))
         DO 140 JH=1,JPNHEM
         IOFM=(JH-1)*JPMGPP

**       Zero flux condition across the upper boundary
         ZDENOM=1.0/DSIGMA(1)
         DO 110 JI=1,JPMG
         II=JI+IOFM
         IJP=II+JPIGC
         ZFACL(JI)=SIGMAH(1)*SIGMAH(1)*AKVV*4.0/
     -         ((TG(IJP)+TG(II))*(TG(IJP)+TG(II)))
         ZFACL(JI)=ZFACL(JI)/(SIGMA(2)-SIGMA(1))
         FUG(II)=FUG(II)+ZFACT*ZDENOM*ZFACL(JI)*(UG(IJP)-UG(II))
         FVG(II)=FVG(II)+ZFACT*ZDENOM*ZFACL(JI)*(VG(IJP)-VG(II))
110      CONTINUE

         DO 120 JL=2,JPNLM
         ZDENOM=1.0/DSIGMA(JL)
         IOF=(JL-1)*JPIGC+IOFM
         DO 120 JI=1,JPMG
         II=IOF+JI
         IJP=II+JPIGC
         IJM=II-JPIGC
         ZFACU(JI)=ZFACL(JI)
         ZFACL(JI)=SIGMAH(JL)*SIGMAH(JL)*AKVV*4.0/
     -         ((TG(IJP)+TG(II))*(TG(IJP)+TG(II)))
         ZFACL(JI)=ZFACL(JI)/(SIGMA(JL+1)-SIGMA(JL))
         FUG(II)=FUG(II)+ZFACT*ZDENOM*
     -         (ZFACL(JI)*(UG(IJP)-UG(II))-ZFACU(JI)*(UG(II)-UG(IJM)))
         FVG(II)=FVG(II)+ZFACT*ZDENOM*
     -         (ZFACL(JI)*(VG(IJP)-VG(II))-ZFACU(JI)*(VG(II)-VG(IJM)))
120      CONTINUE

**       Zero flux condition across the lower boundary
         ZDENOM=1.0/DSIGMA(JPNL)
         IOF=JPNLM*JPIGC+IOFM
         DO 130 JI=1,JPMG
         II=IOF+JI
         IJM=II-JPIGC
         FUG(II)=FUG(II)-ZFACT*ZDENOM*ZFACL(JI)*(UG(II)-UG(IJM))
         FVG(II)=FVG(II)-ZFACT*ZDENOM*ZFACL(JI)*(VG(II)-VG(IJM))
130      CONTINUE
140      CONTINUE
         IF(LOCALV) THEN
            WRITE(6,6020)
6020        FORMAT(1X,'***NTEND : NOTE : FUG AND FVG CURRENTLY '
     -            ,' INCLUDE VERTICAL DIFFUSION EFFECTS')
            LOCALV=.FALSE.
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE OMGCR(KJH)
**    Function - Calculate omega on full model levels
**    Args in -
**               KJH     - Current latitude
**    Args out - none
**    Args for work - none
**    Com used - /COMPRL/NCKPRL,/VARTIM/NSTEPT,/GRIDP/DG,UG,VG,APG,
**          APJG,APMG,/COMGRM/C,/LEGAU/SECSQ
**    Com changed - /GRIDP/OMG
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM/PARAM2/JPIGD,JPMGPP,
**          JPIGC,JPNLP
**    Called by - GRMULT
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          BGFLUX (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION ZAPG(JPIGC,JPNL),ZTPTB(JPNL),ZVGPG(JPNL)
      EQUIVALENCE (ZAPG(1,1),APG(1))

      IF(NCKPRL.NE.NSTEPT) THEN
         WRITE(6,6010) NSTEPT,NCKPRL
6010     FORMAT(1X,'***OMGCR: NSTEPT.NE.NCKPRL :2I10')
         WRITE(6,6020)
6020     FORMAT(1X,'PCNST SHOULD BE CALLED BEFORE OMGCR')
         CALL ABORT
      ENDIF

**    Initialise omega (OMG) to zero
      DO 10 JI=1,JPIGD
      OMG(JI)=0.0
10    CONTINUE

**    Integrate continuity equation in sigma co-ordinates.
      DO 100 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 90 JI=1,JPMG

      DO 20 JL=1,JPNL
      ZTPTB(JL)=0.0
20    CONTINUE

      II=JI+IOF
      IK=II
      IL=-JPNL

      DO 40 JL=1,JPNL
      ZVGP=SECSQ(KJH)*(UG(IK)*APMG(II)+VG(IK)*APJG(II))
      ZVGPG(JL)=ZVGP
      IL=IL+JPNLP
      ILL=IL
      DO 30 J=JL,JPNL
      ZTPTB(J)=ZTPTB(J)+C(ILL)*(ZVGP+DG(IK))
      ILL=ILL+JPNL
30    CONTINUE

      IK=IK+JPIGC
40    CONTINUE
      IK=II

      DO 50 JL=1,JPNL
      OMG(IK)=ZAPG(II,JL)*(ZVGPG(JL)-ZTPTB(JL))
50    IK=IK+JPIGC

90    CONTINUE
100   CONTINUE

      RETURN
      END
      SUBROUTINE PCNST
**    Function - Calculate various pressure-related arrays for
**          gridpoint calculations at current latitude
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMPRL/APSGH,/VARTIM/NSTEPT
**    Com changed - /COMPRL/ALNPSH,ALPH,DELTP,NCKPRL
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM,/PARAM2/JPMGPP,JPIGC
**    Called by - GRMULT
**    Calls - PSGCE
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)

      ZALN2=ALOG(2.0)

**    NCKPRL is checked in the routines that use ALNPSH, DEN,
**          DELTP or ALPH
      NCKPRL=NSTEPT

**    Model full and half-level pressures
      CALL PSGCE

C     THE FOLLOWING ARE HANGOVERS FROM THE UGCM - MAY NOT BE REQUIRED
**    Calculate ln(P(,L+1)/P(,L)), 1.0/(P(,L+1)-P(,L)) and
**    Delta-p for use in vertical integrals.
      DO 300 JI=1,JPMG
      ALNPSH(JI,1)=0.0
      DELTP(JI,1)=APSGH(JI,2)-APSGH(JI,1)
      ALPH(JI,1)=ZALN2
300   CONTINUE
      DO 305 JL=2,JPNL
      DO 305 JI=1,JPMG
      ALNPSH(JI,JL)=ALOG(APSGH(JI,JL+1)/APSGH(JI,JL))
      DELTP(JI,JL)=APSGH(JI,JL+1)-APSGH(JI,JL)
      ALPH(JI,JL)=1.0-APSGH(JI,JL)*ALNPSH(JI,JL)/DELTP(JI,JL)
305   CONTINUE
      IF(JPNHEM.EQ.2) THEN
         DO 310 JI=JPMGPP+1,JPIGC-2
         ALNPSH(JI,1)=0.0
         DELTP(JI,1)=APSGH(JI,2)-APSGH(JI,1)
         ALPH(JI,1)=ZALN2
310      CONTINUE
         DO 320 JL=2,JPNL
         DO 320 JI=JPMGPP+1,JPIGC-2
         ALNPSH(JI,JL)=ALOG(APSGH(JI,JL+1)/APSGH(JI,JL))
         DELTP(JI,JL)=APSGH(JI,JL+1)-APSGH(JI,JL)
         ALPH(JI,JL)=1.0-APSGH(JI,JL)*ALNPSH(JI,JL)/DELTP(JI,JL)
320      CONTINUE
      ENDIF
C     END OF HANGOVERS

C     THE FOLLOWING WERE DETERMINED IN UMAP; OMIT FOR NOW
C**    Half-level values
C
C**    APX : (1/a).d(P)/d(lamda)
C**    APY : (cos(lat)/a).d(P)/d(lat)
C      DO 1105 JI=1,JPIGC
C      APX(JI,1)=0.0
C      APY(JI,1)=0.0
C      APX(JI,JPNLP)=APSFCG(JI)*APMG(JI)
C      APY(JI,JPNLP)=APSFCG(JI)*APJG(JI)
C1105  CONTINUE
C
C**    Full level values
C
C**    GLNPX : (1/a).d(log P)/d(lamda)
C**    GLNPY : (cos(lat)/a).d(log P)/d(lat)
C      DO 1300 JL=1,JPNL
C      IJLP=JL+1
C      DO 1305 JHEM=1,JPNHEM
C      DO 1310 JI=1,JPMG
C      II=JI+(JHEM-1)*JPMGPP
C      GLNPX(II,JL)=(ALNPSH(II,JL)*APX(II,JL)+ALPH(II,JL)*
C     -      (APX(II,IJLP)-APX(II,JL)))/DELTP(II,JL)
C      GLNPY(II,JL)=(ALNPSH(II,JL)*APY(II,JL)+ALPH(II,JL)*
C     -      (APY(II,IJLP)-APY(II,JL)))/DELTP(II,JL)
C1310  CONTINUE
C1305  CONTINUE
C1300  CONTINUE

      RETURN
      END
      SUBROUTINE PSGCE
**    Function - to compute model level pressures (full and half
**          levels), and to find max and min pressures on full levels
**          for each latitude row.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/APSFCG,/VARTIM/NSTEPT,/COMPRL/NCKPRL,
**          /VERTCL/SIGMA,SIGMAH
**    Com changed - /COMPRL/APSGMX,APSGMN,APSGH,/GRIDP/APG
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPIGC,JPNLP,JPMGPP
**    Called by - PCNST
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      DIMENSION ZAPG(JPIGC,JPNL)
      EQUIVALENCE (ZAPG(1,1),APG(1))

      IF(NCKPRL.NE.NSTEPT) THEN
         WRITE(6,6010) NSTEPT,NCKPRL
6010     FORMAT(1X,'***PSGCE: NSTEPT.NE.NCKPRL :2I10')
         WRITE(6,6020)
6020     FORMAT(1X,'PCNST SHOULD BE CALLED BEFORE PSGCE')
         CALL ABORT
      ENDIF

**    ZAPG - full-level pressure
      DO 100 JL=1,JPNL
      DO 100 JI=1,JPIGC
      ZAPG(JI,JL)=SIGMA(JL)*APSFCG(JI)
100   CONTINUE

**    APSGH - half-level pressure
      DO 110 JI=1,JPIGC
      APSGH(JI,1)=0.0
      APSGH(JI,JPNLP)=APSFCG(JI)
110   CONTINUE
      DO 200 JL=2,JPNL
      IJLM=JL-1
      DO 200 JI=1,JPIGC
      APSGH(JI,JL)=SIGMAH(IJLM)*APSFCG(JI)
200   CONTINUE

**    APSGMX, APSGMN - max and min pressure on each level in each
**    hemisphere at current latitude
      DO 400 JL=1,JPNL
      DO 420 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      IM=ISMAX(JPMG,ZAPG(1+IOF,JL),1)
      APSGMX(JL,JHEM)=ZAPG(IOF+IM,JL)
      IN=ISMIN(JPMG,ZAPG(IOF+1,JL),1)
      APSGMN(JL,JHEM)=ZAPG(IOF+IN,JL)
420   CONTINUE
400   CONTINUE

      RETURN
      END
      SUBROUTINE PVCR(KJH)
**    Function - Calculate potential temperature and Ertel potential
**          vorticity on model levels. Generalised formula using array
**          of model level pressures is used to calculate potential
**          temperature.
**    Args in -
**               KJH     - Current latitude
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/APG,TG,TXG,TYG,VOG,APMG,APJG,/INVAR/REFP0,AKAP,
**          GA,/COMPRL/NCKPRL,
**          /LEGAU/SECSQ,/VARTIM/NSTEPT,/COMGRM/DUDLSG,DVDLSG,DTDLSG
**    Com changed - /GRIDP/THG,EPVG
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM,/PARAM2/JPIGC,JPMGPP,
**          JPIGD,JPMGP
**    Called by - GRMULT
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          BGFLUX (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP),
     -      G(JPNL2),T01S2(JPNLM),ALPHA(JPNL),TKP(JPNL),TAU(JPNL2),
     -      C(JPNL2)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)

      IF(NCKPRL.NE.NSTEPT) THEN
         WRITE(6,6010) NSTEPT,NCKPRL
6010     FORMAT(1X,'***PVCR: NSTEPT.NE.NCKPRL :2I10')
         WRITE(6,6020)
6020     FORMAT(1X,'PCNST SHOULD BE CALLED BEFORE PVCR')
         CALL ABORT
      ENDIF

      DO 300 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 200 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 100 JI=1,JPMG
      II=JI+IOF
      IK=IOF+IOFL+JI
      ZMKG=(APG(IK)/REFP0)**(-AKAP)
      ZM1KG=GA*ZMKG/APG(IK)
      ZAKT=AKAP*TG(IK)
      ZTXP=TXG(IK)-ZAKT*APMG(II)
      ZTYP=TYG(IK)-ZAKT*APJG(II)

**    Theta
      THG(IK)=TG(IK)*ZMKG
**    EPV
      EPVG(IK)=ZM1KG*(VOG(IK)*(-DTDLSG(II,JL)+ZAKT)+SECSQ(KJH)*
     -      (-DUDLSG(II,JL)*ZTYP+DVDLSG(II,JL)*ZTXP))
100   CONTINUE
200   CONTINUE
300   CONTINUE

**    Fill remaining elements with zero
      DO 1000 J=JPMGP,JPIGD,JPMGPP
      THG(J)=0.0
      THG(J+1)=0.0
      EPVG(J)=0.0
      EPVG(J+1)=0.0
1000  CONTINUE

      RETURN
      END
      SUBROUTINE SFCHDV
**    Function - Obtain gridpoint streamfunction, velocity potential,
**          divergence and vorticity on non-model surfaces, deriving
**          them directly from the velocity fields on non-model
**          surfaces.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMNGP/NR1U,NR1V,/COMIOC/NCLEG,NCGP,/INVAR/EZ,
**          /COMFFT/WORK,TRIG,MFAX,/POLYNO/CMPA,/LEGAU/CSSQ,
**          /CURSGF/all elements
**    Com changed - /GRIDP/UG,VG,SFG,CHIG,/SPECTR/Q,T,H,/LEGAU/ALP,
**          DALP,RLP,RDLP
**    Params used - /PARAM1/JPNHEM,JPNL,JPJG,JPJGL,JPNWJ2,JPMG,JPCRAY,
**          /PARAM2/JPIGD,JPIGK,JPIGB,JPMGPP,JPIGL,JPIGA,/PARAM3/JPTRMX
**    Called by - SGFLUX
**    Calls - FFT991,HANAL,HEXP,WRITSG
**    Files read - NCLEG,NCGP(1)
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          in UFLUX2H (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMPLEX CMPA
      COMMON /POLYNO/POLY(JPNWJ2,JPNHEM),CMPA(JPIGL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      DIMENSION ZVELG(2*JPIGD),ZUIMG(JPIGD),ZVIMG(JPIGD),ZVELIM(2*JPIGD)
      EQUIVALENCE (ZVELG(1),UG(1)),(ZUIMG(1),SFG(1)),(ZVIMG(1),CHIG(1)),
     -      (ZVELIM(1),SFG(1))
      COMPLEX ZCUIMG(JPIGK),ZCVIMG(JPIGK)
      EQUIVALENCE (ZCUIMG(1),ZUIMG(1)),(ZCVIMG(1),ZVIMG(1))
      COMPLEX ZU(JPIGB),ZV(JPIGB),ZTOT(JPIGB)
      EQUIVALENCE (ZU(1),Q(1)),(ZV(1),T(1)),(ZTOT(1),H(1))

**    Equivalencing implied through the above statements
**    ZVELG(1)         : UG(1)
**    ZVELG(1+JPIGD)   : VG(1)
**    ZUIMG(1)         : SFG(1)   : ZVELIM(1)        : ZCUIMG(1)
**    ZVIMG(1)         : CHIG(1)  : ZVELIM(JPIGD+1)  : ZCVIMG(1)

**    Preset spectral arrays to zero.
      DO 100 I=1,JPIGB
      ZV(I)=CMPLX(0.0,0.0)
      ZU(I)=CMPLX(0.0,0.0)
      VO(I)=CMPLX(0.0,0.0)
      D(I)=CMPLX(0.0,0.0)
100   CONTINUE

      INTRNL=JPNL*2*JPNHEM
      ITRV=(INTRNL-1)/JPCRAY
      IRSTNL=INTRNL-JPCRAY*ITRV

      IL=1
      IF (JPJGL.EQ.1) REWIND NCLEG

      DO 200 JIH=1,JPJG
      IF (JPJGL.EQ.1) READ(NCLEG) ALP,DALP
      READ(NCGP(1),REC=NR1U+JIH-1)UG
      READ(NCGP(1),REC=NR1V+JIH-1)VG

**    VELG now contains gridpoint u.cos(lat) and v.cos(lat). Remove
**    cos**2(latitude) factor from velocities; ZVIMG then contains
**    (1/cos**2(lat)).u.cos(lat) and
**    (1/cos**2(lat)).v.cos(lat).
      DO 300 JI=1,JPIGD
      ZUIMG(JI)=UG(JI)/CSSQ(JIH)
300   ZVIMG(JI)=VG(JI)/CSSQ(JIH)

      IF (ITRV.NE.0) THEN
         DO 400 I=1,ITRV
         CALL FFT991(ZVELG(1+(I-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -        ,1,JPMGPP,JPMG,JPCRAY,-1)
         CALL FFT991(ZVELIM(1+(I-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -        ,1,JPMGPP,JPMG,JPCRAY,-1)
400      CONTINUE
      ENDIF
      CALL FFT991(ZVELG(1+ITRV*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,IRSTNL,-1)
      CALL FFT991(ZVELIM(1+ITRV*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,IRSTNL,-1)

**    Now differentiate such that ZCUIMG contains
**    (1/a.cos**2(lat)).d(u.cos(lat))/d(lamda) and
**    (1/a.cos**2(lat)).d(v.cos(lat))/d(lamda).
      II=0
      DO 500 JL=1,JPNL
      DO 500 JJI=1,JPIGL
      II=II+1
      ZCUIMG(II)=ZCUIMG(II)*CMPA(JJI)
      ZCVIMG(II)=ZCVIMG(II)*CMPA(JJI)
500   CONTINUE

      IJH=JIH
**    Transform to spectral space
      CALL HANAL(UG,ZU,JPNL,3,IJH,IL)
      CALL HANAL(ZUIMG,D,JPNL,2,IJH,IL)
      CALL HANAL(VG,ZV,JPNL,4,IJH,IL)
      CALL HANAL(ZVIMG,VO,JPNL,1,IJH,IL)
200   IL=IL+JINC

**    Array contents  U: (1/a).d/d(mu)u.cos(lat)
**                    D: (1/a.cos**2(lat)).d(u.cos(lat))/d(lamda)
**                    V: (1/a).d/d(mu)v.cos(lat)
**                   VO: (1/a.cos**2(lat)).d(v.cos(lat))/d(lamda)

**    Combine arrays in spectral space to form relative vorticity (VO)
**    and divergence (D)
      DO 600 JI=1,JPIGB
      VO(JI)=VO(JI)-ZU(JI)
      D(JI)=D(JI)+ZV(JI)
600   CONTINUE

**    Set (m=0,n=0) coefficients to zero, and create absolute vorticity
**    (ZTOT) by using EZ.
      DO 700 JI=1,JPIGB,JPIGA
      D(JI)=CMPLX(0.0,0.0)
700   CONTINUE
      IF(JPNHEM.EQ.2) THEN
         DO 800 JPI=JPNWJ2+1,JPIGB,JPIGA
800      VO(JI)=CMPLX(0.0,0.0)
      ENDIF
      DO 900 JI=1,JPIGB
900   ZTOT(JI)=VO(JI)
      DO 1000 JI=1,JPIGB,JPIGA
1000  ZTOT(JI)=ZTOT(JI)+EZ

      IL=1
      IF (JPJGL.EQ.1) REWIND NCLEG

      DO 1200 JIH=1,JPJG
      IF (JPJGL.EQ.1) READ(NCLEG) ALP,DALP,RLP,RDLP

**    Compute divergence, streamfunction, velocity potential and
**    absolute vorticity in spectral (then gridpoint) space using
**    inverse Legendre transforms and FFTs.
      CALL HEXP(D,DG,JPNL,2,IL)
      CALL HEXP(VO,SFG,JPNL,5,IL)
      CALL HEXP(D,CHIG,JPNL,6,IL)
      CALL HEXP(ZTOT,VOG,JPNL,1,IL)

      IF (NTNL.NE.0) THEN
         DO 1100 I=1,NTNL
         CALL FFT991(VOG(1+(I-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -         ,1,JPMGPP,JPMG,JPCRAY,1)
         CALL FFT991(DG(1+(I-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -         ,1,JPMGPP,JPMG,JPCRAY,1)
         CALL FFT991(SFG(1+(I-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -         ,1,JPMGPP,JPMG,JPCRAY,1)
         CALL FFT991(CHIG(1+(I-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -         ,1,JPMGPP,JPMG,JPCRAY,1)
1100     CONTINUE
      ENDIF
      CALL FFT991(VOG(1+NTNL*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,NRSTNL,1)
      CALL FFT991(DG(1+NTNL*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,NRSTNL,1)
      CALL FFT991(SFG(1+NTNL*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,NRSTNL,1)
      CALL FFT991(CHIG(1+NTNL*JPCRAY*JPMGPP),WORK,TRIG,MFAX
     -      ,1,JPMGPP,JPMG,NRSTNL,1)

**    Finally, write the results to scratch.
      IJH=JIH
      CALL WRITSG(.TRUE.,.TRUE.,.TRUE.,.TRUE.,.FALSE.,IJH)
      IL=IL+JINC
1200  CONTINUE

      RETURN
      END
      SUBROUTINE SRFCR(KJH,KJL)
**    Function - Calculate various surface and low level fields for
**          extrapolation below lowest model level (based on constant
**          lapse rate). Also calculate msl pressure.
**    Args in -
**               KJH     - Current latitude
**               KJL     - Second dimension counter for orography
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/UG,VG,APMG,APJG,TG,APG,APSFCG,DG,
**          /COMDAT/LROGR,/COMPRL/XLAPSE,/LEGAU/SECSQ,
**          /INVAR/GA,RD,AKAP,REFP0/COMROG/GSG,/VERTCL/DSIGMA
**    Com changed - /COMPRL/OMSRF,TSRF,THSRF,THSFCG,/GRIDP/APMSLG
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPMGPP,JPIGC,JPNLM
**    Called by - GRMULT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          BGFLUX (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /COMROG/GSG(JPIGC,JPJGL)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)

**    Default settings for no orography.  Surface temperature
**    extrapolated from lowest model level using XLAPSE constant lapse
**    rate. MSL pressure just a copy of surface value.
      IOF=JPNLM*JPIGC
      DO 100 JH=1,JPNHEM
      DO 10 JI=1,JPMG
      I1=IOF+JI+JPMGPP*(JH-1)
      II=JI+JPMGPP*(JH-1)
      SIGFAC=(APG(I1)/APSFCG(II))**(-XLAPSE)
      TSRF(II)=TG(I1)*SIGFAC
      APMSLG(II)=APSFCG(II)
      ZMKG=(APSFCG(II)/REFP0)**(-AKAP)
      THSRF(II)=TSRF(II)*ZMKG
      THSFCG(II)=THSRF(II)
10    CONTINUE
100   CONTINUE

**    Surface omega from integral of continuity equation.
      DO 20 JI=1,JPIGC
      OMSRF(JI)=0.0
20    CONTINUE

      DO 30 JL=1,JPNL
      JLP1=JL+1
      IOF=(JL-1)*JPIGC
      DO 30 JH=1,JPNHEM
      DO 30 JI=1,JPMG
      IJ=JI+(JH-1)*JPMGPP
      IK=IOF+IJ
      ZVGP=SECSQ(KJH)*(UG(IK)*APMG(IJ)+VG(IK)*APJG(IJ))
      OMSRF(IJ)=OMSRF(IJ)-(ZVGP+DG(IK))*DSIGMA(JL)
30    CONTINUE
      DO 40 JH=1,JPNHEM
      DO 40 JI=1,JPMG
      II=JI+JPMGPP*(JH-1)
      OMSRF(II)=OMSRF(II)*APSFCG(II)
40    CONTINUE

**    Extrapolation to msl if orography present.
      IF(LROGR) THEN
         ZRLAPS=1.0/XLAPSE
         ZLAP=XLAPSE*GA/RD
         DO 50 JHEM=1,JPNHEM
         IOF=(JHEM-1)*JPMGPP
         DO 50 JI=1,JPMG
         II=JI+IOF
         APMSLG(II)=APSFCG(II)*((1.0+ZLAP*GSG(II,KJL)/TSRF(II))**ZRLAPS)
50       CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE ENDSG
**    Function - to terminate the SG diagnostics
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /SGDIAG/LDSGTD,LDG3,LDSGTS,/COMDAT/BEGDAY,ENDDAY,
**          YTYPSF,/VARTIM/LTASCI,/COMTIM/NSTART,NEND,NFREQP,
**          NFREQA,/COMIOC/NCGPAV,
**          /ORDIAG/LMSKH,LMSKNS,LMSKWE
**    Com changed - none
**    Params used - /PARAM1/JPNL
**    Called by - ENDOP
**    Calls - TIMAVG,OPSG,OPSG3D,OPSGTS,INIMSK,LLAIR
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT

      IF(LDSGTD) THEN
**       Time averages: accumulations converted to averages
         CALL TIMAVG

**       Compute horizontal logical land/air masks
         CALL LLAIR(.FALSE.)

**       Create orographic masks for lat-long, zonal mean and
**       meridional mean fields
         IF((YTYPSF.EQ.'IS').AND.(LMSKH.OR.LMSKNS.OR.LMSKWE))
     -         CALL INIMSK(NCGPAV(2),NSTART,NEND,BEGDAY,ENDDAY)

**       Now output the averages
         CALL OPSG(BEGDAY,ENDDAY)

**       Output 3D fields
         IF(LDG3.AND.LTASCI) CALL OPSG3D(.FALSE.)
      ENDIF

**    Construct time-series
      IF(LDSGTS) THEN
         IF(NFREQA.EQ.0) THEN
            ISTEPA=1
         ELSE
            ISTEPA=(NEND-NSTART)/NFREQA+1
         ENDIF
         IF(NFREQP.EQ.0) THEN
            ISTEPP=1
         ELSE
            ISTEPP=(NEND-NSTART)/NFREQP+1
         ENDIF
         CALL OPSGTS(ISTEPA,ISTEPP)
      ENDIF

      RETURN
      END
      SUBROUTINE GMOUT(PDAY1,PDAY2,KF,PX,KLEV,LPMMPR,LPMMPL,LPLAPR,
     -            LPLAPL,LPLMPR,LPLMPL,LPMMTS)
**    Function - to control meridional SG output and to save  results
**          for (later) time-series output. One model field is handled
**          for each call to this subroutine.
**    Args in -
**               PDAY1   - Day number of the diagnostics, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**               KF      - Number of the SG field to be processed
**               PX      - Array containing data in meteorological
**                         output units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPMMPR  - .TRUE. if meridional means to be printed
**               LPMMPL  - .TRUE. if meridional means to be plotted
**               LPLAPR  - .TRUE. for west-east latitude slice
**                         printouts
**               LPLAPL  - .TRUE. for west-east latitude slice plots
**               LPLMPR  - .TRUE. for limited latitude-range 'meridional
**                         mean' printout
**               LPLMPL  - .TRUE. for limited latitude-range 'meridional
**                         mean' plots
**               LPMMTS  - .TRUE. to create meridional mean time-series
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,NSIGFG,LUTF14,/COMIOC/NCGMTS,
**          NCAIRM,/SGCNST/YNAMSG,LSGLEV,/SGDIAG/NCSG,/GMCNST/CIGM,
**          /GMDIAG/VGMEW,VGMEWA,/LEGAU/ALAT,ALATBY,ALONBY,
**          /VARTIM/NSTEPT,/ORDIAG/LMSKWE
**          /COMMSK/AMSKV
**    Com changed - /CWORK/WORKM,/COMMSK/AIRLL
**    Params used - /PARAM1/JPMG,JPNL,/PARAM2/JPJGG,JPMGP,JPJGGP,JPSGMX,
**          /COMMSK/JPNLL
**    Called by - SGINST
**    Calls - MERMN3,ZSECTN,G14OUT,GMMOUT,WELATR,BOXAV,BOXAVS
**    Files read - NCAIRM
**    Files written - NCGMTS
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDGMPR,LDGMPL,LDGMWV
      COMMON /GMCNST/LDGMPR(JPSGMX),LDGMPL(JPSGMX),LDGMWV(JPSGMX),
     -      CIGM(JPSGMX)
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION PX(JPMG,JPJGG,JPNL)
      LOGICAL LPMMPR,LPMMPL,LPLAPR,LPLAPL,LPLMPR,LPLMPL,LPMMTS,LOINST
      CHARACTER*50 YONAME
      CHARACTER*1 YOT
      DIMENSION ZMERID(JPMG,JPNL),ZLONI(JPMGP),ZLONO(JPMGP),
     -      ZLATO(JPJGGP)
      DIMENSION ZMASK(JPMG,JPJGG)
      EQUIVALENCE (ZMERID(1,1),WORKM(1,1))

      IF(LPMMPR.OR.LPMMPL.OR.LPLAPR.OR.LPLAPL.OR.LPLMPR.OR.LPLMPL) THEN
         YONAME=YNAMSG(KF)
         IF(YTYPSF.EQ.'ET') THEN
            YONAME(21:40)='SIGMA               '
            ILVTYP=0
         ELSE IF(YTYPSF.EQ.'IS') THEN
            YONAME(21:40)='PRESS               '
            ILVTYP=2
         ELSE IF(YTYPSF.EQ.'TH') THEN
            YONAME(21:40)='THETA               '
            ILVTYP=3
         ENDIF
      ENDIF

      IF(PDAY1.GT.PDAY2) THEN
         ITFLAG=0
         LOINST=.TRUE.
      ELSE
         ITFLAG=1
         LOINST=.FALSE.
      ENDIF

      IF(LMSKWE) THEN
         IMSK=1
      ELSE
         IMSK=0
      ENDIF

      IF(KLEV.EQ.1) THEN
         YOT='S'
         DO 200 J=1,JPJGG
         DO 200 JI=1,JPMG
         ZMASK(JI,J)=1.0
200      CONTINUE
      ELSE
         YOT='F'
         IF(KF.EQ.21) YOT='M'
         IF(KF.EQ.13.AND.YTYPSF.EQ.'TH') YOT='M'
         DO 201 J=1,JPJGG
         DO 201 JI=1,JPMG
         ZMASK(JI,J)=1.0
201      CONTINUE
      ENDIF

**    Create meridional means
      IF(LPMMPR.OR.LPMMPL.OR.LPMMTS) THEN
         CALL MERMN3(PX,JPMG,JPJGG,KLEV,ZMERID,JPMG,YOT,LOINST)
      ENDIF

**    Print out the meridional means, and pass them to the UTF file
      IF(LPMMPR.OR.LPMMPL) THEN
         YONAME(27:40)=' MERID. MEAN  '
         IF(KLEV.EQ.JPNL) THEN
            CALL ZSECTN(ZMERID,JPMG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -            NCSG,1,JPMG,1,JPNL,PDAY1,PDAY2,CIGM(KF),LPMMPR,
     -            LPMMPL,1,0,0.0,0,ITFLAG,12,IMSK,0,ILVTYP,ZMERID,
     -            ZMERID,' ',' ',1,1)
         ELSE
**          Surface meridional means
            IF(LUTF14.AND.LPMMPL) THEN
               CALL G14OUT(WGP2D4,ZMERID,JPMG,1,31,0,0,1,1,0.0,
     -               360.0,YONAME,'Longitude (deg)','Meridional mean',
     -               ' ',PDAY1,PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LPMMPR) THEN
               CALL GMMOUT(JPMG,1,ZMERID,0.0,NSIGFG,-1,-1,NCSG,
     -               1,JPMG,1,1,YONAME,PDAY1,PDAY2)
            ENDIF
         ENDIF
      ENDIF

**    Create meridional mean time-series fields
      IF(LPMMTS) THEN
         IF(KLEV.EQ.1) THEN
            WRITE(NCGMTS)'GMTS',KF,NSTEPT,KLEV,(ZMERID(JI,1),JI=1,JPMG)
         ELSE
            DO 100 JL=1,KLEV
            IF(LSGLEV(JL)) WRITE(NCGMTS)'GMTS',KF,NSTEPT,
     -            JL,(ZMERID(JI,JL),JI=1,JPMG)
100         CONTINUE
         ENDIF
      ENDIF

**    Calculate a slice at the single latitude VGMEW; assume
**    d(field)/d(sin(latitude)) is constant
      IF(LPLAPR.OR.LPLAPL) THEN
         CALL WELATR(VGMEW,ALAT,PX,JPMG,JPJGG,KLEV,ZMERID)
CHACK***********
C        WRITE(YONAME(27:40),'(''  LAT. '',F5.1,2X)')VGMEW
      YONAME(27:40)=' LAT 40.0     '
C***************
         IF(KLEV.EQ.JPNL) THEN
            CALL ZSECTN(ZMERID,JPMG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -            NCSG,1,JPMG,1,JPNL,PDAY1,PDAY2,CIGM(KF),LPLAPR,
     -            LPLAPL,1,0,0.0,0,ITFLAG,12,0,0,ILVTYP,ZMERID,
     -            ZMERID,' ',' ',1,1)
         ELSE
**          Surface west-east slice
            IF(LUTF14.AND.LPLAPL) THEN
               CALL G14OUT(ZMERID,ZMERID,JPMG,1,31,0,0,1,1,0.0,
     -               360.0,YONAME,'Longitude (deg)','Value',
     -               ' ',PDAY1,PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LPLAPR) THEN
               CALL GMMOUT(JPMG,1,ZMERID,0.0,NSIGFG,-1,-1,NCSG,
     -               1,JPMG,1,1,YONAME,PDAY1,PDAY2)
            ENDIF
         ENDIF
      ENDIF

**    West-east slice of area-averaged values between two specified
**          latitudes (VGMEWA(1) and VGMEWA(2))
      IF(LPLMPR.OR.LPLMPL) THEN
         IF(YTYPSF.EQ.'ET'.OR.KLEV.EQ.1) THEN
            DO 1000 JL=1,KLEV
            CALL AWIL(PX(1,1,JL),JPMG,JPJGG,ALATBY,ALONBY,1,
     -            ZMERID(1,JL),JPMG,.FALSE.,ZMASK,AMSKV,
     -            ALONBY(1),ALONBY(JPMGP),VGMEWA(1),VGMEWA(2))
1000        CONTINUE
         ELSE
            IF(JPNLL.EQ.1) THEN
               ILINC=0
               REWIND NCAIRM
            ELSE
               ILINC=1
            ENDIF
            JLEV=1
            DO 1001 JL=1,KLEV
            IF(JPNLL.EQ.1) READ(NCAIRM)((AIRLL(JI,JLAT,JLEV),
     -            JI=1,JPMG),JLAT=1,JPJGG)
            CALL AWIL(PX(1,1,JL),JPMG,JPJGG,ALATBY,ALONBY,1,
     -            ZMERID(1,JL),JPMG,.FALSE.,AIRLL(1,1,JLEV),AMSKV,
     -            ALONBY(1),ALONBY(JPMGP),VGMEWA(1),VGMEWA(2))
            JLEV=JLEV+ILINC
1001        CONTINUE
         ENDIF
CHACK
C        WRITE(YONAME(27:40),'(''AVER'',I4,''/'',I4,''N'')')
C    -         NINT(VGMEWA(1)),NINT(VGMEWA(2))
         IF(KLEV.EQ.JPNL) THEN
            CALL ZSECTN(ZMERID,JPMG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -            NCSG,1,JPMG,1,JPNL,PDAY1,PDAY2,CIGM(KF),LPLMPR,
     -            LPLMPL,1,0,0.0,0,ITFLAG,12,0,0,ILVTYP,ZMERID,
     -            ZMERID,' ',' ',1,1)
         ELSE
**          Surface north-south slice
            IF(LUTF14.AND.LPLMPL) THEN
               CALL G14OUT(ZMERID,ZMERID,JPMG,1,31,0,0,1,1,0.0,
     -               360.0,YONAME,'Longitude (deg)','Value',' ',
     -               PDAY1,PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LPLMPR) THEN
               CALL GMMOUT(JPMG,1,ZMERID,0.0,NSIGFG,-1,-1,NCSG,
     -               1,JPMG,1,1,YONAME,PDAY1,PDAY2)
            ENDIF
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE GPOUT(PDAY1,PDAY2,KF,PX,KLEV,LPCPPR,LPCPPL,
     -      LPCPTS,LPCTPR,LPCTPL,LPCTTS)
**    Function - to determine SG vertical profile (and mass-weighted
**          column totals) at selected latitude-longtitude coordinates,
**          to output the profiles and to save the results for (later)
**          time-series output. One model field is handled for each call
**          to this subroutine, the field is assumed to be a 3D (non
**          -surface) field.
**    Args in -
**               PDAY1   - Day number of the diagnostics, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**               KF      - Number of the SG field to be processed
**               PX      - Array containing data in meteorological
**                         output units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPCPPR  - .TRUE. for column profile printout,
**               LPCPPL  - .TRUE. for column profile UTFs,
**               LPCPTS  - .TRUE. if column profile time series to be
**                         built
**               LPCTPR  - .TRUE. for column total printout,
**               LPCTPL  - .TRUE. for column total UTFs,
**               LPCTTS  - .TRUE. if column total time series to be
**                         built;
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGPTS,/SGDIAG/NCSG,/COMDAT/YTYPSF,
**          /VARTIM/NSTEPT,/GPDIAG/NGPPF,VGPPF,/SGCNST/YNAMSG,
**          /VERTCL/SIGMA,/LVDIAG/SFCOUT
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNL,JPJG,JPNHEM,/PARAM2/JPNLM,
**          /PARAM3/JPGPPF
**    Called by - SGINST,OPSG
**    Calls - PROFIL,PCOLOP,COLTOT
**    Files read - none
**    Files written - NCGPTS,NCSG
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      DIMENSION PX(JPMG,JPJGG,JPNL)
      DIMENSION ZPF(JPNL,JPGPPF),ZTOT(JPGPPF),ZPAD(JPNLM*JPGPPF),
     -      ZOUTLV(JPNL),ZWORK(JPNLP,JPGPPF)
      LOGICAL LPCPPR,LPCPPL,LPCPTS,LPCTPR,LPCTPL,LPCTTS,LONOW
      CHARACTER*50 YONAME,YOX,YOY

**    Return if column totals and profiles not required
      IF((.NOT.LDGPCP).AND.(.NOT.LDGPCT)) RETURN

      IF(KLEV.NE.JPNL) THEN
         WRITE(6,6000) KLEV
6000     FORMAT(1X,'***GPOUT: WARNING - NO PROFILES COMPUTED, ONLY ',
     -         I5,' LEVELS OF DATA')
         RETURN
      ENDIF

      LONOW=PDAY1.GT.PDAY2

**    Compute profiles at the specified coordinates; these are also
**    needed even if only the column totals are to be output
      CALL PROFIL(PX,JPMG,ZPF,NGPPF,VGPPF,KLEV)

**    Output the profiles
      IF(LPCPPR.OR.LPCPPL) THEN
         YONAME=YNAMSG(KF)
         IF(YTYPSF.EQ.'ET') THEN
            YONAME(21:40)='SIG                 '
            ILVTYP=0
            DO 300 J=1,JPNL
            ZOUTLV(J)=SIGMA(J)
300         CONTINUE
         ELSE IF(YTYPSF.EQ.'IS') THEN
            YONAME(21:40)='MB                  '
            ILVTYP=2
            DO 301 J=1,JPNL
            ZOUTLV(J)=SFCOUT(J)
301         CONTINUE
         ELSE IF(YTYPSF.EQ.'TH') THEN
            YONAME(21:40)='DEGK                '
            ILVTYP=3
            DO 302 J=1,JPNL
            ZOUTLV(J)=SFCOUT(J)
302         CONTINUE
         ENDIF
         YOY=YONAME(41:50)
         YOX=' '
         CALL PCOLOP(ZPF,JPNL,NGPPF,PDAY1,PDAY2,YONAME,0,
     -         LPCPPR,LPCPPL,NCSG,VGPPF,ZOUTLV,ILVTYP,YOX,YOY)
      ENDIF

**    Save the profiles for time-series on scratch file NCGPTS
      IF(LPCPTS) THEN
         WRITE(NCGPTS)'PROFILE',KF,NSTEPT,ZPF
      ENDIF

**    Compute column totals if output is on sigma levels.
**    Note that array PX will be overwritten with the model half-level
**    pressures in COLTOT.
      IF((YTYPSF.EQ.'ET').AND.(LPCTPR.OR.LPCTTS)) THEN
         CALL COLTOT(ZPF,NGPPF,ZTOT,VGPPF,LONOW,ZWORK)
      ELSE
         RETURN
      ENDIF

**    Output the column totals; only printed output is available - since
**    each column total contains just 1 value
      IF(LPCTPR) THEN
         WRITE(NCSG,6005)
6005     FORMAT(1X,/' COLUMN TOTALS AT SELECTED LATITUDE-LONGITUDE',
     -        ' LOCATIONS: UNITS ARE FIELD UNITS TIMES KG/M**2')
         IF(PDAY2.LT.PDAY1) THEN
            WRITE(NCSG,6010)PDAY1,YONAME
6010        FORMAT(1X,' DAY ',F10.3,2X,A)
         ELSE
            WRITE(NCSG,6020)PDAY1,PDAY2,YONAME
6020        FORMAT(1X,' DAY ',F10.3,' - ',F10.3,2X,A)
         ENDIF
         DO 100 JF=1,NGPPF
         WRITE(NCSG,6100)VGPPF(1,JF),VGPPF(2,JF),ZTOT(JF)
6100     FORMAT(1X,'LAT. ',F6.1,' LONG. ',F6.1,' COL. TOTAL ',E12.5)
100      CONTINUE
      ENDIF

**    Save the column totals for time-series; ZPAD is a padding array so
**    that all records on NCGPTS are the same length.
      DO 200 J=1,JPNLM*JPGPPF
      ZPAD(J)=0.0
200   CONTINUE
      IF(LPCTTS) THEN
         WRITE(NCGPTS)'C TOTAL',KF,NSTEPT,ZTOT,ZPAD
      ENDIF

      RETURN
      END
      SUBROUTINE GZOUT(PDAY1,PDAY2,KF,PX,KLEV,LPZMPR,LPZMPL,LPLSPR,
     -      LPLSPL,LPLRPR,LPLRPL,LPZMTS)
**    Function - to control zonal SG output and to save  results
**          for (later) time-series output. One model field is handled
**          for each call to this subroutine.
**    Args in -
**               PDAY1   - Day number of the diagnostics, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**               KF      - Number of the SG field to be processed
**               PX      - Array containing data in meteorological
**                         output units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPZMPR  - .TRUE. if zonal means to be printed
**               LPZMPL  - .TRUE. if zonal means to be plotted
**               LPLSPR  - .TRUE. for north-south longitude slice
**                         printouts
**               LPLSPL  - .TRUE. for north-south longitude slice plots
**               LPLRPR  - .TRUE. for limited longitude-range 'zonal
**                         mean' printout
**               LPLRPL  - .TRUE. for limited longitude-range 'zonal
**                         mean' plots
**               LPZMTS  - .TRUE. to create zonal mean time-series
**    Args out - none
**    Args for work - none
**    Com used - /SGCNST/YNAMSG,LSGLEV,/SGDIAG/NCSG,/COMDAT/YTYPSF,
**          LUTF14,NSIGFG,/COMIOC/NCGZTS,NCAIRM,/GZCNST/CIGZ,
**          /GZDIAG/VGZNS,VGZNSA,/LEGAU/ALAT,ALATBY,ALONBY,
**          /VARTIM/NSTEPT,/ORDIAG/LMSKNS,
**          /COMMSK/AMSKV
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNL,/PARAM2/JPJGG,JPMGP,JPJGGP,JPIGG,
**          /PARAM3/JPXP2,JPSGMX,/COMMSK/JPNLL
**    Called by - SGINST,OPSG
**    Calls - ZMEAN3,ZSECTE,G14OUT,GZMOUT,NSLONR,BOXAV,BOXAVS
**    Files read - NCAIRM
**    Files written - NCGZTS
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      LOGICAL LDGZPR,LDGZPL,LDGZWV
      COMMON /GZCNST/LDGZPR(JPSGMX),LDGZPL(JPSGMX),LDGZWV(JPSGMX),
     -      CIGZ(JPSGMX)
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      DIMENSION PX(JPMG,JPJGG,JPNL)
      LOGICAL LPZMPR,LPZMPL,LPLSPR,LPLSPL,LPLRPR,LPLRPL,LPZMTS,LOINST
      CHARACTER*50 YONAME
      CHARACTER*1 YOT
      DIMENSION ZZONAL(JPJGG,JPNL),ZLONI(JPMGP),ZLONO(JPMGP),
     -      ZLATO(JPJGGP)
      DIMENSION ZMASK(JPMG,JPJGG)

      IF(LPZMPR.OR.LPZMPL.OR.LPLSPR.OR.LPLSPL.OR.LPLRPR.OR.LPLRPL) THEN
         YONAME=YNAMSG(KF)
         IF(YTYPSF.EQ.'ET') THEN
            YONAME(21:40)='SIGMA               '
            ILVTYP=0
         ELSE IF(YTYPSF.EQ.'IS') THEN
            YONAME(21:40)='PRESS               '
            ILVTYP=2
         ELSE IF(YTYPSF.EQ.'TH') THEN
            YONAME(21:40)='THETA               '
            ILVTYP=3
         ENDIF
      ENDIF

      IF(PDAY1.GT.PDAY2) THEN
         ITFLAG=0
         LOINST=.TRUE.
      ELSE
         ITFLAG=1
         LOINST=.FALSE.
      ENDIF

      IF(LMSKNS) THEN
         IMSK=1
      ELSE
         IMSK=0
      ENDIF

      IF(KLEV.EQ.1) THEN
         YOT='S'
         DO 200 J=1,JPJGG
         DO 200 JI=1,JPMG
         ZMASK(JI,J)=1.0
200      CONTINUE
      ELSE
         YOT='F'
         IF(KF.EQ.21) YOT='M'
         IF(KF.EQ.13.AND.YTYPSF.EQ.'TH') YOT='M'
         DO 201 J=1,JPJGG
         DO 201 JI=1,JPMG
         ZMASK(JI,J)=1.0
201      CONTINUE
      ENDIF

**    Create zonal means
      IF(LPZMPR.OR.LPZMPL.OR.LPZMTS) THEN
         CALL ZMEAN3(PX,JPMG,JPJGG,KLEV,ZZONAL,JPMG,YOT,LOINST)
      ENDIF

**    Print out the zonal means, and pass them to the UTF file
      IF(LPZMPR.OR.LPZMPL) THEN
         YONAME(27:40)='  ZONAL MEAN  '
         IF(KLEV.EQ.JPNL) THEN
            CALL ZSECTE(ZZONAL,JPJGG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -            NCSG,1,JPJGG,1,JPNL,PDAY1,PDAY2,CIGZ(KF),LPZMPR,
     -            LPZMPL,1,0,0.0,0,ITFLAG,11,IMSK,0,ILVTYP,ZZONAL,
     -            ZZONAL,' ',' ',1,1)
         ELSE
**          Surface zonal means
            IF(LUTF14.AND.LPZMPL) THEN
               CALL G14OUT(ALAT,ZZONAL,JPJGG,1,31,0,0,1,2,-90.0,
     -               90.0,YONAME,'Latitude (deg)','Zonal mean',' ',
     -               PDAY1,PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LPZMPR) THEN
               CALL GZMOUT(JPJGG,1,ZZONAL,0.0,NSIGFG,-1,-1,NCSG,
     -               1,JPJGG,1,1,YONAME,PDAY1,PDAY2,'SURFACE FIELD')
            ENDIF
         ENDIF
      ENDIF

**    Create zonal mean time-series fields
      IF(LPZMTS) THEN
         IF(KLEV.EQ.1) THEN
            WRITE(NCGZTS)'GZTS',KF,NSTEPT,KLEV,(ZZONAL(JI,1),JI=1,JPJGG)
         ELSE
            DO 100 JL=1,KLEV
            IF(LSGLEV(JL)) WRITE(NCGZTS)'GZTS',KF,NSTEPT,
     -            JL,(ZZONAL(JI,JL),JI=1,JPJGG)
100         CONTINUE
         ENDIF
      ENDIF

**    Calculate a slice at the single longitude VGZNS; assume
**    d(field)/d(longitude) is constant
      IF(LPLSPR.OR.LPLSPL) THEN
         CALL NSLONR(VGZNS,JPMG,PX,JPMG,JPJGG,KLEV,ZZONAL)
         WRITE(YONAME(27:40),'(''  LON. '',F5.1,2X)')VGZNS
         IF(KLEV.EQ.JPNL) THEN
            CALL ZSECTE(ZZONAL,JPJGG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -            NCSG,1,JPJGG,1,JPNL,PDAY1,PDAY2,CIGZ(KF),LPLSPR,
     -            LPLSPL,1,0,0.0,0,ITFLAG,11,0,0,ILVTYP,ZZONAL,
     -            ZZONAL,' ',' ',1,1)
         ELSE
**          Surface north-south slice
            IF(LUTF14.AND.LPLSPL) THEN
               CALL G14OUT(ALAT,ZZONAL,JPJGG,1,31,0,0,1,2,-90.0,
     -               90.0,YONAME,'Latitude (deg)','Zonal mean',' ',
     -               PDAY1,PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LPLSPR) THEN
               CALL GZMOUT(JPJGG,1,ZZONAL,0.0,NSIGFG,-1,-1,NCSG,
     -               1,JPJGG,1,1,YONAME,PDAY1,PDAY2,'SURFACE FIELD')
            ENDIF
         ENDIF
      ENDIF

**    North-south slice of area-averaged values between two specified
**          longitudes (VGZNSA(1) and VGZNSA(2))
      IF(LPLRPR.OR.LPLRPL) THEN
         IF(YTYPSF.EQ.'ET'.OR.KLEV.EQ.1) THEN
            DO 1000 JL=1,KLEV
            CALL AWIL(PX(1,1,JL),JPMG,JPJGG,ALATBY,ALONBY,2,
     -            ZZONAL(1,JL),JPJGG,.FALSE.,ZMASK,AMSKV,
     -            VGZNSA(1),VGZNSA(2),ALATBY(1),ALATBY(JPJGGP))
1000        CONTINUE
         ELSE
            IF(JPNLL.EQ.1) THEN
               ILINC=0
               REWIND NCAIRM
            ELSE
               ILINC=1
            ENDIF
            JLEV=1
            DO 1001 JL=1,KLEV
            IF(JPNLL.EQ.1) READ(NCAIRM)((AIRLL(JI,JLAT,JLEV),
     -            JI=1,JPMG),JLAT=1,JPJGG)
            CALL AWIL(PX(1,1,JL),JPMG,JPJGG,ALATBY,ALONBY,2,
     -            ZZONAL(1,JL),JPJGG,.FALSE.,AIRLL(1,1,JLEV),AMSKV,
     -            VGZNSA(1),VGZNSA(2),ALATBY(1),ALATBY(JPJGGP))
            JLEV=JLEV+ILINC
1001        CONTINUE
         ENDIF
         WRITE(YONAME(27:40),'(''AVER'',I4,''/'',I4,''E'')')
     -         NINT(VGZNSA(1)),NINT(VGZNSA(2))
         IF(KLEV.EQ.JPNL) THEN
            CALL ZSECTE(ZZONAL,JPJGG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -            NCSG,1,JPJGG,1,JPNL,PDAY1,PDAY2,CIGZ(KF),LPLRPR,
     -            LPLRPL,1,0,0.0,0,ITFLAG,11,0,0,ILVTYP,ZZONAL,
     -            ZZONAL,' ',' ',1,1)
         ELSE
**          Surface north-south slice
            IF(LUTF14.AND.LPLRPL) THEN
               CALL G14OUT(ALAT,ZZONAL,JPJGG,1,31,0,0,1,2,-90.0,
     -               90.0,YONAME,'Latitude (deg)','Value',' ',
     -               PDAY1,PDAY2,IFAIL,ITFLAG)
            ENDIF
            IF(LPLRPR) THEN
               CALL GZMOUT(JPJGG,1,ZZONAL,0.0,NSIGFG,-1,-1,NCSG,
     -               1,JPJGG,1,1,YONAME,PDAY1,PDAY2,'SURFACE FIELD')
            ENDIF
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE HROUT(PDAY1,PDAY2,KF,PX,KLEV,LPGHPR,LPGHPL,LPWC,LPWCPR,
     -      LPWCPL,LPGHTS)
**    Function - to control SG horizontal surface (and mass-weighted
**          column totals over whole globe) output and to save  results
**          for (later) time-series output. One model field is handled
**          for each call to this subroutine.
**    Args in -
**               PDAY1   - Day number of the diagnostics, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**               KF      - Number of the SG field to be processed
**               PX      - Array containing data in meteorological
**                         output units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPGHPR  - .TRUE. if horizontal slices to be printed
**               LPGHPL  - .TRUE. if horizontal slices to be plotted
**               LPWC    - .TRUE. if column totals throughout the
**                         atmosphere to be computed
**               LPWCPR  - .TRUE. if column totals throughout the
**                         atmosphere to be printed
**               LPWCPL  - .TRUE. if column totals throughout the
**                         atmosphere to be plotted
**               LPGHTS  - .TRUE. if information to be saved for later
**                         use with time-series output
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,NSIGFG,NASCII,/SGCNST/YNAMSG,
**          LSGLEV,YNAMSG,/SGDIAG/NCSG,/VERTCL/SIGMA,

**          /LEGAU/ALATBY,ALONBY,/GHCNST/CIGH,/GHDIAG/LDGHED,VGHTS,
**          /VARTIM/NSTEPT,/COMIOC/NCUTF,NCGHTS,NCAIRM,/LVDIAG/SFCOUT,
**          /ORDIAG/LMSKH,/COMMSK/AMSKV
**    Com changed - /CWORK/WGP2D1,WGP2D2,WGP2D3,WGP2D4,/COMMSK/AIRLL
**    Params used - /PARAM1/JPMG,JPNHEM,JPNL,/PARAM2/JPJGG,JPMGP,JPJGGP,
**          /PARAM3/JPSGMX,/COMMSK/JPNLL
**    Called by - SGINST,OPSG
**    Calls - AWIL,COLSUM,GLLOUT,U14OUT,ZMEAN3
**    Files read - NCAIRM
**    Files written - NCGHTS
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDGHPR,LDGHPL,LDGHWV
      COMMON /GHCNST/LDGHPR(JPSGMX),LDGHPL(JPSGMX),LDGHWV(JPSGMX),
     -      CIGH(JPSGMX)
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      LOGICAL LPGHPR,LPGHPL,LPWC,LPWCPR,LPWCPL,LPGHTS,LOINST
      DIMENSION PX(JPMG,JPJGG,JPNL)
      DIMENSION ZMERID(JPMG),ZCOLSM(JPMG,JPJGG),ZUTF14(JPMG,JPJGG)
      DIMENSION ZLONI(JPMGP),ZLONO(JPMGP),ZLATO(JPJGGP),
     -      ZZONM(JPJGG)
      DIMENSION ZMASK(JPMG,JPJGG)
      EQUIVALENCE (ZMERID(1),WGP2D1(1,1)),(ZCOLSM(1,1),WGP2D2(1,1)),
     -      (ZUTF14(1,1),WGP2D3(1,1)),
     -      (ZZONM(1),WGP2D1(1,1))
      CHARACTER*50 YONAME
      CHARACTER*1 YOT

      write(4,*)'hrout1'
      IF(LPGHPR.OR.LPGHPL.OR.LPWCPR.OR.LPWCPL) THEN
         YONAME=YNAMSG(KF)
         IF(YTYPSF.EQ.'ET') THEN
            YONAME(21:40)='SIGMA               '
            ILVTYP=0
         ELSE IF(YTYPSF.EQ.'IS') THEN
            YONAME(21:40)='P(PA)               '
            ILVTYP=2
         ELSE IF(YTYPSF.EQ.'TH') THEN
            YONAME(21:40)='THETA               '
            ILVTYP=3
         ENDIF
         IF(JPMOCT.EQ.1) THEN
            ISGTYP=1
         ELSE
            ISGTYP=3
         ENDIF
      ENDIF
      write(4,*)'hrout2'

      IF(PDAY1.GT.PDAY2) THEN
         ITFLAG=0
         LOINST=.TRUE.
      ELSE
         ITFLAG=1
         LOINST=.FALSE.
      ENDIF

      IF(LMSKH) THEN
         IMSK=1
      ELSE
         IMSK=0
      ENDIF
      write(4,*)'hrout3'

      IF(KLEV.EQ.1) THEN
         YOT='S'
         DO 200 J=1,JPJGG
         DO 200 JI=1,JPMG
         ZMASK(JI,J)=1.0
200      CONTINUE
      ELSE
         YOT='F'
         IF(KF.EQ.21) YOT='M'
         IF(KF.EQ.13.AND.YTYPSF.EQ.'TH') YOT='M'
         DO 201 J=1,JPJGG
         DO 201 JI=1,JPMG
         ZMASK(JI,J)=1.0
201      CONTINUE
      ENDIF
      write(4,*)'hrout4'

      IF(LPGHTS) THEN
**       Save data for Hofmoeller timeseries output; this consists of
**       north-south averaged meridional slices between VGHTS(1) and
**       VGHTS(2), on either surface levels or on levels where
**       LSGLEV=.TRUE.
      write(4,*)'hrout5'

         IF(KLEV.EQ.1) THEN
**          Save data from surface field
            CALL AWIL(PX(1,1,1),JPMG,JPJGG,ALATBY,ALONBY,1,ZMERID,
     -            JPMG,.FALSE.,ZMASK,AMSKV,
     -            ALONBY(1),ALONBY(JPMGP),VGHTS(1),VGHTS(2))
            WRITE(NCGHTS)'GHTS',KF,NSTEPT,KLEV,ZMERID
         ELSE
**          Select data from levels corresponding to LSGLEV
            IF(YTYPSF.EQ.'ET') THEN
               DO 100 JL=1,JPNL
               IF(LSGLEV(JL)) THEN
                  CALL AWIL(PX(1,1,JL),JPMG,JPJGG,ALATBY,ALONBY,1,
     -                  ZMERID,JPMG,.FALSE.,ZMASK,AMSKV,
     -                  ALONBY(1),ALONBY(JPMGP),VGHTS(1),VGHTS(2))
                  WRITE(NCGHTS)'GHTS',KF,NSTEPT,JL,ZMERID
               ENDIF
100            CONTINUE
            ELSE
               IF(JPNLL.EQ.1) THEN
                  ILINC=0
                  REWIND NCAIRM
               ELSE
                  ILINC=1
               ENDIF
               JLEV=1
               DO 1001 JL=1,JPNL
               IF(JPNLL.EQ.1) READ(NCAIRM)((AIRLL(JI,JLAT,JLEV),
     -               JI=1,JPMG),JLAT=1,JPJGG)
               CALL AWIL(PX(1,1,JL),JPMG,JPJGG,ALATBY,ALONBY,1,
     -               ZMERID,JPMG,.FALSE.,AIRLL(1,1,JLEV),AMSKV,
     -               ALONBY(1),ALONBY(JPMGP),VGHTS(1),VGHTS(2))
               WRITE(NCGHTS)'GHTS',KF,NSTEPT,JL,ZMERID
               JLEV=JLEV+ILINC
1001           CONTINUE
            ENDIF
         ENDIF
      ENDIF
      write(4,*)'hrout6'

      IF(LPWC) THEN
**       Compute column totals throughout the atmosphere for longitudes
**       1-JPMG; LPWC should not be .TRUE. for single level fields.
         CALL COLSUM(PX,ZCOLSM,JPMG,JPMG,WORKM,LOINST,1,JPNL)
         YONAME(27:40)='FULL COL.SUMS '
         YONAME(41:46)='KG/M2.'
**       Output these column totals
         IF(LPWCPR)
     -      CALL GLLOUT(JPMG,JPJGG,ZCOLSM,0.0,NSIGFG,-1,-1,NCSG,
     -            1,JPMG,1,JPJGG,YONAME,PDAY1,PDAY2)
         IF(LPWCPL) THEN
**          Specify a normalised contour interval for column-integrated
**          quantities
            ZCISUM=-0.1
            IF(LUTF14) THEN
**             UTF14
               CALL U14OUT(ZCOLSM,JPMG,JPJGG,JPMG,ISGTYP,1,0,ILVTYP,1,0,
     -               ZCISUM,JPNHEM,YONAME,50,NCUTF,NASCII,IFAIL,
     -               PDAY1,PDAY2,ZCOLSM,ZCOLSM,' ',' ',1,1,ITFLAG,
     -               ZUTF14)
            ENDIF
         ENDIF
      ENDIF
      write(4,*)'hrout7'

      IF((LPGHPR.OR.LPGHPL).AND.(KLEV.EQ.JPNL)) THEN
         DO 1000 JL=1,KLEV
         IF(LSGLEV(JL)) THEN
**          Determine zonal mean and subtract from the gridpoint field,
**          if LDGHED is .TRUE.
            IF(LDGHED) THEN
               CALL ZMEAN3(PX(1,1,JL),JPMG,JPJGG,1,ZZONM,JPMG,YOT,
     -               LOINST)
               DO 1100 J=1,JPJGG
               DO 1100 JI=1,JPMG
               PX(JI,J,JL)=PX(JI,J,JL)-ZZONM(J)
1100           CONTINUE
               YONAME(41:46)=' EDDY '
            ELSE
               YONAME(41:46)='      '
            ENDIF
**          Output the field
            IF(YTYPSF.NE.'ET') THEN
               IF(SFCOUT(JL).GE.10.0) THEN
CHACK
C*****dirty hack: get rid of internal writes
C                 WRITE(YONAME(27:40),'(''= '',F12.2)')SFCOUT(JL)
      if (jl.eq.1) YONAME(27:40)='=      5000.00'
      if (jl.eq.2) YONAME(27:40)='=     15000.00'
      if (jl.eq.3) YONAME(27:40)='=     25000.00'
      if (jl.eq.4) YONAME(27:40)='=     35000.00'
      if (jl.eq.5) YONAME(27:40)='=     45000.00'
      if (jl.eq.6) YONAME(27:40)='=     55000.00'
      if (jl.eq.7) YONAME(27:40)='=     65000.00'
      if (jl.eq.8) YONAME(27:40)='=     75000.00'
      if (jl.eq.9) YONAME(27:40)='=     85000.00'
      if (jl.eq.10) YONAME(27:40)='=     95000.00'
C***********
               ELSE IF(SFCOUT(JL).GT.0.01) THEN
                  WRITE(YONAME(27:40),'(''= '',F12.4)')SFCOUT(JL)
               ELSE IF(SFCOUT(JL).GT.0.0001) THEN
                  WRITE(YONAME(27:40),'(''= '',F12.6)')SFCOUT(JL)
               ELSE
                  WRITE(YONAME(27:40),'(''= '',E12.4)')SFCOUT(JL)
               ENDIF
            ELSE
               IF(SIGMA(JL).LT.0.001) THEN
                  WRITE(YONAME(27:40),'('' = '',E11.4)')SIGMA(JL)
               ELSE
                  WRITE(YONAME(27:40),'('' = '',F11.5)')SIGMA(JL)
               ENDIF
            ENDIF
            IF(LPGHPR) CALL GLLOUT(JPMG,JPJGG,PX(1,1,JL),0.0,NSIGFG,
     -            -1,-1,NCSG,1,JPMG,1,JPJGG,YONAME,PDAY1,PDAY2)
            IF(LPGHPL) THEN
               IF(LUTF14) THEN
                  CALL U14OUT(PX(1,1,JL),JPMG,JPJGG,JPMG,ISGTYP,1,0,
     -                  ILVTYP,1,IMSK,CIGH(KF),JPNHEM,YONAME,50,NCUTF,
     -                  NASCII,IFAIL,PDAY1,PDAY2,PX(1,1,JL),
     -                  PX(1,1,JL),' ',' ',1,1,ITFLAG,ZUTF14)
               ENDIF
            ENDIF
            IF(LDGHED) THEN
**             Add zonal mean back in case field needed later
               DO 1150 J=1,JPJGG
               DO 1150 JI=1,JPMG
               PX(JI,J,JL)=PX(JI,J,JL)+ZZONM(J)
1150           CONTINUE
            ENDIF
         ENDIF
1000     CONTINUE
      ENDIF
      write(4,*)'hrout8'

      IF((LPGHPR.OR.LPGHPL).AND.(KLEV.EQ.1)) THEN
**       Surface field
         IF(LDGHED) THEN
            CALL ZMEAN3(PX(1,1,1),JPMG,JPJGG,1,ZZONM,JPMG,YOT,LOINST)
            DO 2000 J=1,JPJGG
            DO 2000 JI=1,JPMG
            PX(JI,J,KLEV)=PX(JI,J,KLEV)-ZZONM(J)
            YONAME(41:46)=' EDDY '
2000        CONTINUE
         ELSE
            YONAME(41:46)='      '
         ENDIF
**       Output the field
         YONAME(27:40)=' SURFACE LEVEL'
C     write(4,*)'field printed out'
C     write(4,*)px(1,1,1)
         IF(LPGHPR) CALL GLLOUT(JPMG,JPJGG,PX(1,1,KLEV),0.0,NSIGFG,
     -         -1,-1,NCSG,1,JPMG,1,JPJGG,YONAME,PDAY1,PDAY2)
         IF(LPGHPL) THEN
            IF(LUTF14) THEN
               CALL U14OUT(PX(1,1,1),JPMG,JPJGG,JPMG,ISGTYP,1,0,ILVTYP,
     -               1,0,CIGH(KF),JPNHEM,YONAME,50,NCUTF,NASCII,IFAIL,
     -               PDAY1,PDAY2,PX(1,1,1),PX(1,1,1),' ',' ',1,1,ITFLAG,
     -               ZUTF14)
            ENDIF
         ENDIF
         IF(LDGHED) THEN
**          Add zonal mean back in case field needed later
            DO 2050 J=1,JPJGG
            DO 2050 JI=1,JPMG
            PX(JI,J,KLEV)=PX(JI,J,KLEV)+ZZONM(J)
2050        CONTINUE
         ENDIF
      ENDIF
      write(4,*)'hrout9'

      RETURN
      END
      SUBROUTINE LLAIR(LOINST)
**    Function - set up logical land/air masks on horizontal surfaces.
**          If JPNLL=1, then the masks are written to a scratch file.
**          Note that when output is on isobaric surfaces, the mask is
**          always set to .TRUE.; no account of 'underground' data
**          is taken into consideration when averaging such output.
**    Args in -
**               LOINST  - .TRUE. if land/air mask data to be read from
**                          instantaneous data file, else read from
**                          time-average data file
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGP,NCGPAV,NCAIRM,/COMDAT/YTYPSF,
**          /COMNGP/NR1ALM,/CURSGF/all elements
**    Com changed - /SPECTR/VO...SPAD,/COMMSK/AIRLL
**    Params used - /PARAM1/JPJG,JPNHEM,JPMG,JPNL,JPJGG,/PARAM2/JPMGPP,
**          JPIGD,/COMMSK/JPNLL,/PARAM3/JPTRMX
**    Called by - SGFLUX,ENDSG,ENDTR
**    Calls - none
**    Files read - NCGP,NCGPAV
**    Files written - NCAIRM
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      DIMENSION ZMASK(JPIGD,JPJG),ZZMASK(JPMGPP,JPNHEM,JPNL,JPJG)
      EQUIVALENCE (ZMASK(1,1),VO(1)),(ZZMASK(1,1,1,1),VO(1))
      LOGICAL LOINST

      IF(JPNLL.EQ.1) THEN
         ILINC=0
         REWIND NCAIRM
      ENDIF
      IF(JPNLL.EQ.JPNL) ILINC=1
      JLEV=1

**    If output is on sigma levels then...
**    Mask always takes the value 1.0
      IF(YTYPSF.EQ.'ET') THEN
**       Assign 1.0 to AIRLL
         DO 2000 JL=1,1
         DO 2100 JLAT=1,JPJGG
         DO 2100 JI=1,JPMG
         AIRLL(JI,JLAT,JL)=1.0
2100     CONTINUE
2000     CONTINUE
         IF(JPNLL.EQ.1) THEN
            DO 2200 JL=1,JPNL
            WRITE(NCAIRM)((AIRLL(JI,JLAT,1),
     -            JI=1,JPMG),JLAT=1,JPJGG)
2200        CONTINUE
            REWIND NCAIRM
         ELSE
            DO 2300 JL=2,JPNL
            DO 2300 JLAT=1,JPJGG
            DO 2300 JI=1,JPMG
            AIRLL(JI,JLAT,JL)=1.0
2300        CONTINUE
         ENDIF
         RETURN
      ENDIF

**    If output is on pressure levels then...
**    Mask currently takes the value 1.0 always (this must be related
**    to the value of LAVMSK when output on pressure surfaces)
      IF(YTYPSF.EQ.'IS') THEN
**       Assign 1.0 to AIRLL
         DO 3000 JL=1,1
         DO 3100 JLAT=1,JPJGG
         DO 3100 JI=1,JPMG
         AIRLL(JI,JLAT,JL)=1.0
3100     CONTINUE
3000     CONTINUE
         IF(JPNLL.EQ.1) THEN
            DO 3200 JL=1,JPNL
            WRITE(NCAIRM)((AIRLL(JI,JLAT,1),
     -            JI=1,JPMG),JLAT=1,JPJGG)
3200        CONTINUE
            REWIND NCAIRM
         ELSE
            DO 3300 JL=2,JPNL
            DO 3300 JLAT=1,JPJGG
            DO 3300 JI=1,JPMG
            AIRLL(JI,JLAT,JL)=1.0
3300        CONTINUE
         ENDIF
         RETURN
      ENDIF

**    If output is on isentropic levels then...
**    Read land/air mask (decimal values) from direct access file (where
**    it is stored in latitude slices)
      IF(YTYPSF.EQ.'TH') THEN
         IF(LOINST) THEN
            ICHAN=NCGP(1)
         ELSE
            ICHAN=NCGPAV(1)
         ENDIF
         INIREC=NR1ALM
         DO 1000 J=1,JPJG
         READ(ICHAN,REC=INIREC-1+J)(ZMASK(JI,J),JI=1,JPIGD)
1000     CONTINUE
**       Now convert ZMASK values into AIRLL values
         DO 1100 JL=1,JPNL
         DO 1200 J=1,JPJG
         DO 1200 JH=1,JPNHEM
         JLAT=(2-JH)*J+(JH-1)*(JPJGG-J+1)
         DO 1200 JI=1,JPMG
         AIRLL(JI,JLAT,JLEV)=ZZMASK(JI,JH,JL,J)
1200     CONTINUE
         IF(JPNLL.EQ.1) WRITE(NCAIRM)((AIRLL(JI,JLAT,JLEV),
     -         JI=1,JPMG),JLAT=1,JPJGG)
         JLEV=JLEV+ILINC
1100     CONTINUE
         IF(JPNLL.EQ.1) REWIND NCAIRM
         RETURN
      ENDIF

      END
      SUBROUTINE OPSG
**    Function - to control output of time-averaged SG diagnostics
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /GHCNST/LDGHPR,LDGHPL,LDGHWV,/GHDIAG/LDGHSL,LDGHCT,
**          /GMCNST/LDGMPR,LDGMPL,LDGMWV,/GMDIAG/LDGMMM,
**          VGMEW,VGMEWA,/GPCNST/LDGPPR,LDGPPL,/GPDIAG/LDGPCT,
**          LDGPCP,/GZCNST/LDGZPR,LDGZPL,LDGZWV,/GZDIAG/LDGZZM,
**          VGZNS,VGZNSA,/SGCNST/LSGLEV,NGPIND,NSEQGP,
**          /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDSGTD,/ORDIAG/LMSKH,
**          LMSKNS,LMSKWE,/VARTIM/LTOUT,LTPRNT,LTASCI,
**          /COMDAT/BEGDAY,ENDDAY,YTYPSF,/COMIOC/NCGPAV,NCSGSW
**          /COMTIM/NSTART,NEND,NSDATE,NEDATE,/DIAGTP/LDSG,
**          /CURSGF/all elements,/CURSGS/all elements
**    Com changed - /SPECTR/VO...SPAD,/CWORK/WORK3D
**    Params used - /PARAM1/JPNL,JPMG,JPJG,JPNHEM,
**          /PARAM2/JPJGG,JPIGD,JPIGC,JPMGPP/PARAM3/JPSGMX
**    Called by - ENDSG
**    Calls - SGCONV,LLCNVS,MSKPL,SGVEC,HROUT,GZOUT,GMOUT,GPOUT
**    Files read - NCGPAV(1),NCGPAV(2)
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDGHPR,LDGHPL,LDGHWV
      COMMON /GHCNST/LDGHPR(JPSGMX),LDGHPL(JPSGMX),LDGHWV(JPSGMX),
     -      CIGH(JPSGMX)
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      LOGICAL LDGMPR,LDGMPL,LDGMWV
      COMMON /GMCNST/LDGMPR(JPSGMX),LDGMPL(JPSGMX),LDGMWV(JPSGMX),
     -      CIGM(JPSGMX)
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      LOGICAL LDGPPR,LDGPPL
      COMMON /GPCNST/LDGPPR(JPSGMX),LDGPPL(JPSGMX),CIGP(JPSGMX)
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      LOGICAL LDGZPR,LDGZPL,LDGZWV
      COMMON /GZCNST/LDGZPR(JPSGMX),LDGZPL(JPSGMX),LDGZWV(JPSGMX),
     -      CIGZ(JPSGMX)
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LOFLD,LOGP,LOGH,LOGZ,LOGM
      LOGICAL LOCPPR,LOCPPL,LOCTPR,LOCTPL
      LOGICAL LOGHPR,LOGHPL,LOWC,LOWCPR,LOWCPL
      LOGICAL LOZMPR,LOZMPL,LOLSPR,LOLSPL,LOLRPR,LOLRPL
      LOGICAL LOMMPR,LOMMPL,LOLAPR,LOLAPL,LOLMPR,LOLMPL
      LOGICAL LOHVEC,LOHMSK,LOSVEC,LOZVEC,LOZMSK,LOMVEC,LOMMSK,
     -      LODUMY(JPNL)
      DIMENSION Z(JPMG,JPJGG,JPNL),ZR(JPIGD,JPJG)
      EQUIVALENCE (Z(1,1,1),VO(1)),(ZR(1,1),VO(1))
      SAVE LOHMSK,LOHVEC,LOSVEC,LOZVEC,LOZMSK,LOMVEC,LOMMSK,LODUMY
      DATA LOHMSK/.FALSE./,LOHVEC/.FALSE./,LOSVEC/.FALSE./,
     -      LOZVEC/.FALSE./,LOZMSK/.FALSE./,LOMVEC/.FALSE./,
     -      LOMMSK/.FALSE./,LODUMY/JPNL*.FALSE./

      IF((.NOT.LDSG).AND.(.NOT.LDSGTD)) RETURN
C      IF(.NOT.LECANL) THEN
         ZDAY1=BEGDAY
         ZDAY2=ENDDAY
C      ELSE
C         ZDAY1=FLOAT(NSDATE)/100.0
C         ZDAY2=FLOAT(NEDATE)/100.0
C      ENDIF

**    Wind vectors and orographic masks may be required for
**    incorporation into the UTF file, depending upon the value of
**    certain user-specified switches. Set up a set of default flags
**    here, and if a requirement for vectors or masks is detected later,
**    then modify the flags and undertake the output if not already
**    done.
**    NB. It is up to the user to combine the appropriate fields at the
**    plotting stage.
**    LOHVEC - Flag to indicate that vectors for multi-level fields have
**          been produced.
**    LOSVEC - Flag to indicate that vectors for surface fields (ie
**          vectors at the lowest level) have been produced.
**    LOHMSK - Flag to indicate that latitude-longitude horizontal
**          orographic masks have been sent to the UTF file.
**    LOZVEC - Flag to indicate that vectors for zonal fields have
**          been produced.
**    LOZMSK - Flag to indicate that zonal mean orographic masks
**          have been sent to the UTF file.
**    LOMVEC - Flag to indicate that vectors for meridional fields have
**          been produced.
**    LOMMSK - Flag to indicate that meridional mean orographic masks
**          have been sent to the UTF file.
      LOHVEC=.FALSE.
      LOSVEC=.FALSE.
      LOHMSK=.FALSE.
      LOZVEC=.FALSE.
      LOZMSK=.FALSE.
      LOMVEC=.FALSE.
      LOMMSK=.FALSE.

**    Outer loop is over all possible SG output fields. This means that
**    any required field is read once-only off the scratch files when
**    computing the instantaneous diagnostics.

      DO 100 JF=1,JPSGMX
      LOGP=.FALSE.
      LOGH=.FALSE.
      LOGZ=.FALSE.
      LOGM=.FALSE.
**    First determine if field number JF is required

**    Vertical profile diagnostics
      IF(LDGP) THEN
**       Vertical profiles inappropriate for single level surface fields
         IF((JF.NE.15).AND.(JF.NE.16).AND.(JF.NE.20)) THEN
            IF(LDGPPR(JF).OR.LDGPPL(JF)) LOGP=.TRUE.
         ENDIF
      ENDIF

**    Horizontal level diagnostics
      IF(LDGH.AND.(LDGHPR(JF).OR.LDGHPL(JF))) LOGH=.TRUE.

**    Zonal slice diagnostics
      IF(LDGZ.AND.(LDGZPR(JF).OR.LDGZPL(JF))) LOGZ=.TRUE.

**    Meridional slice diagnostics
      IF(LDGM.AND.(LDGMPR(JF).OR.LDGMPL(JF))) LOGM=.TRUE.

**    LOFLD set to .TRUE. if present field required
      LOFLD=LOGP.OR.LOGH.OR.LOGZ.OR.LOGM

      IF(LOFLD) THEN
**       Read field from scratch files
         ICHAN=NCGPAV(NGPIND(JF))
         INIREC=NSEQGP(JF)
         IF(NGPIND(JF).EQ.2) THEN
**          Read surface/single level field. Note that although the
**          array ZR has JPIGD elements as its first dimension, only the
**          first JPIGC elements contain values read from scratch.
**          Likewise, Z only contains data for elements (1:1) in the
**          third dimension.
            ILEV=1
            DO 1000 J=1,JPJG
            READ(ICHAN,REC=INIREC-1+J)(ZR(JI,J),JI=1,JPIGC)
1000        CONTINUE
         ELSE
**          Read 3D field
            ILEV=JPNL
            DO 1100 J=1,JPJG
            READ(ICHAN,REC=INIREC-1+J)(ZR(JI,J),JI=1,JPIGD)
1100        CONTINUE
         ENDIF
**       Convert fields to meteorological units required for output
**       and/or interpolation.
         CALL SGCONV(ZR,JPNL,ILEV,JF)

**       Convert to 'standard' indexing format
         CALL LLCNVS(ZR,JPMGPP,JPNHEM,JPNL,JPJG,Z,JPMG,JPJGG,
     -         JPNL,ILEV,.TRUE.,WORK3D,JPMGPP,JPNHEM,JPNL,JPJG,
     -         .TRUE.,NCSGSW)

**       Now perform diagnostics
**       SG horizontal diagnostics
         IF(LOGH) THEN
**          LOGHPR is .TRUE. for horizontal level printout
**          LOGHPL is .TRUE. for horizontal level plots
**          LOWC is .TRUE if column totals through the whole atmosphere
**                to be calculated
**          LOWCPR is .TRUE. if column totals to be printed
**          LOWCPL is .TRUE. if column totals to be plotted
            LOGHPR=LTPRNT.AND.LDGHSL.AND.LDGHPR(JF)
            LOGHPL=LTASCI.AND.LDGHSL.AND.LDGHPL(JF)
            LOWC  =LTOUT .AND.LDGHCT.AND.(YTYPSF.EQ.'ET')
     -            .AND.(ILEV.EQ.JPNL)
            LOWCPR=LOWC  .AND.LTPRNT.AND.LDGHPR(JF)
            LOWCPL=LOWC  .AND.LTASCI.AND.LDGHPL(JF)

**          Pass orographic mask to UTF if appropriate
            IF(LOGHPL.AND.(.NOT.LOHMSK).AND.LMSKH.AND.(ILEV.EQ.JPNL)
     -            .AND.YTYPSF.EQ.'IS') THEN
               CALL MSKPL('H',NSTART,NEND,ZDAY1,ZDAY2)
               LOHMSK=.TRUE.
            ENDIF

**          Output the horizontal wind vectors if appropriate
**          Firstly, multi-level fields
            IF(LOGHPL.AND.(.NOT.LOHVEC).AND.LDGHWV(JF)) THEN
               IF(ILEV.EQ.JPNL) THEN
                  CALL SGVEC(ZDAY1,ZDAY2,'H',LSGLEV,.FALSE.)
                  LOHVEC=.TRUE.
**                The next line supposes that surface fields are plotted
**                with level JPNL wind vectors
                  IF(LSGLEV(JPNL)) LOSVEC=.TRUE.
               ENDIF
            ENDIF
**          Secondly, wind vectors for surface fields; the exact level
**          used for these wind vectors is defined in SGVEC
            IF(LOGHPL.AND.(.NOT.LOSVEC).AND.LDGHWV(JF)) THEN
               IF(ILEV.EQ.1) THEN
                  CALL SGVEC(ZDAY1,ZDAY2,'H',LODUMY,.TRUE.)
                  LOSVEC=.TRUE.
               ENDIF
            ENDIF

            CALL HROUT(ZDAY1,ZDAY2,JF,Z,ILEV,LOGHPR,LOGHPL,LOWC,
     -            LOWCPR,LOWCPL,.FALSE.)
         ENDIF

**       SG zonal diagnostics
         IF(LOGZ) THEN
**          LOZMPR is .TRUE. for zonal mean printout
**          LOZMPL is .TRUE. for zonal mean plots
**          LOLSPR is .TRUE. for north-south longitude slice printout
**          LOLSPL is .TRUE. for north-south longitude slice plots
**          LOLRPR is .TRUE. for limited longitude-range mean (printout)
**          LOLRPL is .TRUE. for limited longitude-range mean (plot)
            LOZMPR=LDGZPR(JF).AND.LTPRNT.AND.LDGZZM
            LOZMPL=LDGZPL(JF).AND.LTASCI.AND.LDGZZM
            LOLSPR=LDGZPR(JF).AND.LTPRNT.AND.(VGZNS.GT.-990.0)
            LOLSPL=LDGZPL(JF).AND.LTASCI.AND.(VGZNS.GT.-990.0)
            LOLRPR=LDGZPR(JF).AND.LTPRNT.AND.(VGZNSA(1).GT.-990.0)
            LOLRPL=LDGZPL(JF).AND.LTASCI.AND.(VGZNSA(1).GT.-990.0)

**          Pass orographic mask to UTF if appropriate
            IF(LOZMPL.AND.(.NOT.LOZMSK).AND.LMSKNS.AND.(ILEV.EQ.JPNL)
     -            .AND.YTYPSF.EQ.'IS') THEN
               CALL MSKPL('ZM',NSTART,NEND,ZDAY1,ZDAY2)
               LOZMSK=.TRUE.
            ENDIF

**          Output the wind vectors on vertical slices if appropriate
**          Multi-level fields
            IF(LOZMPL.AND.(.NOT.LOZVEC).AND.LDGZWV(JF)) THEN
               IF(ILEV.EQ.JPNL) THEN
                  CALL SGVEC(ZDAY1,ZDAY2,'ZM',LSGLEV,.FALSE.)
                  LOZVEC=.TRUE.
               ENDIF
            ENDIF

            CALL GZOUT(ZDAY1,ZDAY2,JF,Z,ILEV,LOZMPR,LOZMPL,LOLSPR,
     -            LOLSPL,LOLRPR,LOLRPL,.FALSE.)
         ENDIF

**       SG meridional diagnostics
         IF(LOGM) THEN
**          LOMMPR is .TRUE. for meridional mean printout
**          LOMMPL is .TRUE. for meridional mean plots
**          LOLAPR is .TRUE. for north-south latitude slice printout
**          LOLAPL is .TRUE. for north-south latitude slice plots
**          LOLMPR is .TRUE. for limited latitude-range mean (printout)
**          LOLMPL is .TRUE. for limited latitude-range mean (plot)
            LOMMPR=LDGMPR(JF).AND.LTPRNT.AND.LDGMMM
            LOMMPL=LDGMPL(JF).AND.LTASCI.AND.LDGMMM
            LOLAPR=LDGMPR(JF).AND.LTPRNT.AND.(VGMEW.GT.-990.0)
            LOLAPL=LDGMPL(JF).AND.LTASCI.AND.(VGMEW.GT.-990.0)
            LOLMPR=LDGMPR(JF).AND.LTPRNT.AND.(VGMEWA(1).GT.-990.0)
            LOLMPL=LDGMPL(JF).AND.LTASCI.AND.(VGMEWA(1).GT.-990.0)

**          Pass orographic mask to UTF if appropriate
            IF(LOMMPL.AND.(.NOT.LOMMSK).AND.LMSKWE.AND.(ILEV.EQ.JPNL)
     -            .AND.YTYPSF.EQ.'IS') THEN
               CALL MSKPL('MM',NSTART,NEND,ZDAY1,ZDAY2)
               LOMMSK=.TRUE.
            ENDIF

**          Output the wind vectors on vertical slices if appropriate
**          Multi-level fields
            IF(LOMMPL.AND.(.NOT.LOMVEC).AND.LDGMWV(JF)) THEN
               IF(ILEV.EQ.JPNL) THEN
                  CALL SGVEC(ZDAY1,ZDAY2,'MM',LSGLEV,.FALSE.)
                  LOMVEC=.TRUE.
               ENDIF
            ENDIF

            CALL GMOUT(ZDAY1,ZDAY2,JF,Z,ILEV,LOMMPR,LOMMPL,LOLAPR,
     -            LOLAPL,LOLMPR,LOLMPL,.FALSE.)
         ENDIF

**       SG profile diagnostics
         IF(LOGP) THEN
**          LOCPPR is .TRUE. for column profile printout,
**          LOCPPL is .TRUE. for column profile UTFs,
**          LOCTPR is .TRUE. for column total printout,
**          LOCTPL is .TRUE. for column total UTFs,
            LOCPPR=LDGPCP.AND.LTPRNT.AND.LDGPPR(JF)
            LOCPPL=LDGPCP.AND.LTASCI.AND.LDGPPL(JF)
            LOCTPR=LDGPCT.AND.LTPRNT.AND.LDGPPR(JF)
            LOCTPL=LDGPCT.AND.LTASCI.AND.LDGPPL(JF)
**          Note: GPOUT will cause field Z(JF) to be overwitten if
**                column total amounts are required; this is because the
**                model half-level pressures (a 3D array) need to be
**                read in from the relevant scratch file. CONSEQUENTLY
**                GPOUT SHOULD BE THE LAST ROUTINE CALLED FROM OPSG.
            CALL GPOUT(ZDAY1,ZDAY2,JF,Z,ILEV,LOCPPR,LOCPPL,
     -            .FALSE.,LOCTPR,LOCTPL,.FALSE.)
         ENDIF

      ENDIF
100   CONTINUE
      RETURN
      END
      SUBROUTINE OPSG3D(LPNOW)
**    Function - to copy user-selected 3D gridpoint fields to output
**          file. The user should alter the code in this routine if (for
**          example) a different output format is required, or if a
**          subset of each field is required.
**    Args in -
**               LPNOW   - .TRUE. if instantaneous fields to be output,
**                         otherwise time-averages will be output
**    Args out - none
**    Args for work - none
**    Com used - /SGCNST/YNAMSG,NGPIND,NSEQGP,/VARTIM/DAYT,
**          /LVDIAG/SFCOUT,/G3CNST/LDG3PL,/COMDAT/BEGDAY,ENDDAY,YTYPSF,
**          /G3DIAG/NCG3,/COMIOC/NCGP,NCGPAV,/CURSGF/all elements,
**          /CURSGS/all elements
**    Com changed - /SPECTR/VO...SPAD
**    Params used - /PARAM1/JPMG,JPNHEM,JPNL,JPJG,JPMOCT,/PARAM2/JPIGD,
**          JPMGPP,/PARAM3/JPSGMX
**    Called by - SGCALC,ENDSG
**    Calls - SGCONV
**    Files read - NCGP(1),NCGP(2),NCGPAV(1),NCGPAV(2)
**    Files written - NCG3
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      LOGICAL LDG3PL
      COMMON /G3CNST/LDG3PL(JPSGMX)
      COMMON /G3DIAG/NCG3,NG3PL(JPSGMX),NG3
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LPNOW
      CHARACTER*50 YONAME,YOTIME
      DIMENSION Z(JPMGPP,JPNHEM,JPNL,JPJG),ZR(JPIGD,JPJG)
      EQUIVALENCE (Z(1,1,1,1),VO(1)),(ZR(1,1),VO(1))
**    ZR and Z are the same array; using ZR minimises the number of
**    implied do loops when the array is read.

**    The following code writes the fields to NCG3 with the following
**    structure:
**    Record 1: number of records containing level values (=IRECLV) and
**              number of data records (=IRECDT), in the format 2I10.
**    Record 2: character*50 field title
**    Record 3: character*50 time description
**    Record 4: array dimensions (JPMG,JPNHEM,JPNL,JPJG,JPMOCT) in
**              format 4I10
**    Record 5: vertical model level type in format character*2
**    Records 6 to IRECLV+5 : vertical level values in format 8E10.3 (a
**              value of -999E30 corresponds to the surface)
**    Records IRECLV+6 to IRECLV+IRECDT+5 : array values in format
**              8E10.3
**    Note that only JPMG values per latitude are written out.

      DO 100 JF=1,JPSGMX
      IF(LDG3PL(JF)) THEN
         ILEV=JPNL
         IF((JF.EQ.15).OR.(JF.EQ.16).OR.(JF.EQ.20)) ILEV=1

         IRECLV=ILEV/8
         IF(IRECLV*8.LT.ILEV)IRECLV=IRECLV+1

         IRECDT=(JPMG*JPNHEM*JPJG*ILEV)/8
         IF(IRECDT*8.LT.JPMG*JPNHEM*JPJG*ILEV)IRECDT=IRECDT+1
         YONAME=YNAMSG(JF)
         YONAME(21:21)='('
         YONAME(22:23)=YTYPSF
         YONAME(24:24)=')'
         IF(LPNOW) THEN
            WRITE(YOTIME,'(''DAY '',F15.4,31X)')DAYT
         ELSE
            WRITE(YOTIME,'(''DAY '',F15.4,'' - DAY '',F15.4,
     -            '' AVERAGE '')')BEGDAY,ENDDAY
         ENDIF

**       Write header records
         WRITE(NCG3,6000)IRECLV,IRECDT
6000     FORMAT(2I10)
         WRITE(NCG3,6010)YONAME
6010     FORMAT(A50)
         WRITE(NCG3,6010)YOTIME
         WRITE(NCG3,6020)JPMG,JPNHEM,ILEV,JPJG,JPMOCT
6020     FORMAT(5I10)
         WRITE(NCG3,6030)YTYPSF
6030     FORMAT(A2)
         IF(ILEV.EQ.JPNL) THEN
            IF(YTYPSF.EQ.'ET') THEN
               WRITE(NCG3,6040)(FLOAT(JL),JL=1,JPNL)
6040           FORMAT(8E10.3)
            ELSE
               WRITE(NCG3,6040)(SFCOUT(JL),JL=1,JPNL)
            ENDIF
         ELSE IF(ILEV.EQ.1) THEN
            ZSFC=-999E30
            WRITE(NCG3,6040)ZSFC
         ENDIF

**       Read data, latitude by latitude, convert to output units,
**       and write out to NCG3
         INIREC=NSEQGP(JF)
         IF(LPNOW) THEN
            ICHAN=NCGP(NGPIND(JF))
         ELSE
            ICHAN=NCGPAV(NGPIND(JF))
         ENDIF
         IF(ILEV.EQ.JPNL) THEN
            DO 1000 JL=1,JPJG
            READ(ICHAN,REC=INIREC+JL-1)(ZR(JI,JL),JI=1,JPIGD)
1000        CONTINUE
         ELSE
            DO 1010 JL=1,JPJG
            READ(ICHAN,REC=INIREC+JL-1)(ZR(JI,JL),JI=1,JPIGC)
1010        CONTINUE
         ENDIF
         CALL SGCONV(ZR,JPNL,ILEV,JF)
         WRITE(NCG3,6040)((((Z(IMG,IH,ILV,IJ),IMG=1,JPMG),
     -         IH=1,JPNHEM),ILV=1,ILEV),IJ=1,JPJG)
      ENDIF
100   CONTINUE

      RETURN
      END
      SUBROUTINE OPSGTS(KSTEPU,KSTEPP)
**    Function - To generate time-series SG output
**    Args in -
**               KSTEPU  - number of timesteps for which data
**                         will be written to the UTF
**               KSTEPP  - number of timesteps for which data
**                         will be printed
**    Args out - none
**    Args for work - none
**    Com used - /SGDIAG/LDSGTS,LDGH,NCSG,LDGZ,LDGM,LDGP,
**          /COMDAT/LUTF13,LUTF14,YTYPSF,NASCII,NSIGFG,
**          /VARTIM/LTPRNT,LTASCI,/SGCNST/YNAMSG,LSGLEV,/VERTCL/
**          SIGMA,/GHDIAG/LDGHSL,VGHTS,/GHCNST/LDGHPR,LDGHPL,CIGH,
**          /LVDIAG/SFCOUT,/COMTIM/NFREQA,NFREQP,TSPD,
**          /COMIOC/NCUTF,NCGPTS,NCGHTS,NCGZTS,NCGMTS,
**          /GMCNST/LDGMPR,LDGMPL,CIGM,/GMDIAG/LDGMTS,LDGMMM,
**          /GPCNST/LDGPPR,LDGPPL,CIGP,/GPDIAG/LDGPCT,LDGPCP,VGPPF,
**          /GZCNST/LDGZPR,LDGZPL,CIGZ,/GZDIAG/LDGZZM,LDGZTS,/LEGAU/ALAT
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNL,/PARAM2/JPJGG,/PARAM3/JPSGMX
**    Called by - ENDSG
**    Calls - ALLCHP,RDSGTS,TLABEL,MLABEL,U14OUT,GMTOUT,DEHEAP,
**          ATRUNC,GTZOUT,RDGPTS,GTPOUT,G14OUT,GTSOUT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDGHPR,LDGHPL,LDGHWV
      COMMON /GHCNST/LDGHPR(JPSGMX),LDGHPL(JPSGMX),LDGHWV(JPSGMX),
     -      CIGH(JPSGMX)
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      LOGICAL LDGMPR,LDGMPL,LDGMWV
      COMMON /GMCNST/LDGMPR(JPSGMX),LDGMPL(JPSGMX),LDGMWV(JPSGMX),
     -      CIGM(JPSGMX)
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      LOGICAL LDGPPR,LDGPPL
      COMMON /GPCNST/LDGPPR(JPSGMX),LDGPPL(JPSGMX),CIGP(JPSGMX)
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      LOGICAL LDGZPR,LDGZPL,LDGZWV
      COMMON /GZCNST/LDGZPR(JPSGMX),LDGZPL(JPSGMX),LDGZWV(JPSGMX),
     -      CIGZ(JPSGMX)
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      POINTER(IPPM,ZXPM(JPMG,KSTEPP)),(IPUM,ZXUM(JPMG,KSTEPU))
      POINTER(IPPZ,ZXPZ(KSTEPP,JPJGG)),(IPUZ,ZXUZ(KSTEPU,JPJGG))
      POINTER(IPPP,ZXPP(KSTEPP,JPNL,JPGPPF)),
     -      (IPUP,ZXUP(KSTEPU,JPNL,JPGPPF))
      POINTER(IPPC,ZXPC(KSTEPP,1,JPGPPF)),
     -      (IPUC,ZXUC(KSTEPU,1,JPGPPF))
      POINTER(IPUT,ZXUT(KSTEPU))
      DIMENSION ZLONG(JPMG),ZDATA(JPNL*JPGPPF),ZDATAP(JPNL*JPGPPF)
      LOGICAL LOUTF,LOPR,LOUT
      CHARACTER*4 YOCH4
      CHARACTER*7 YOCP,YOCT
      CHARACTER*50 YONAME

      IF(.NOT.LDSGTS) RETURN

      LOPR=LTPRNT
      LOUTF=LUTF14.AND.LTASCI
      LOUT=LOPR.OR.LOUTF

      IF(.NOT.LOUT) RETURN

      ITFLAG=2
      CALL ALLCHP(IPUT,KSTEPU,KERR)

**    Loop over all the SG output files
      DO 100 JF=1,JPSGMX

      YONAME=YNAMSG(JF)
      IF((JF.EQ.15).OR.(JF.EQ.16).OR.(JF.EQ.20)) THEN
         ILEV=1
         YONAME(21:40)='SURFACE             '
         ILVTYP=1
      ELSE
         ILEV=JPNL
         IF(YTYPSF.EQ.'ET') THEN
            YONAME(21:40)='SIGM                 '
            ILVTYP=0
         ELSE IF(YTYPSF.EQ.'IS') THEN
            YONAME(21:40)='(PA)                '
            ILVTYP=2
         ELSE IF(YTYPSF.EQ.'TH') THEN
            YONAME(21:40)='DEGK                '
            ILVTYP=3
         ENDIF
      ENDIF

**    Horizontal level timeseries output
      IF(LDGH.AND.LDGHSL.AND.LOUT.AND.(VGHTS(1).GT.-990.0).AND.
     -      (LDGHPR(JF).OR.LDGHPL(JF))) THEN
         CALL ALLCHP(IPPM,JPMG*KSTEPP,KERR)
         CALL ALLCHP(IPUM,JPMG*KSTEPU,KERR)
         YOCH4='GHTS'

**       Loop over levels
         DO 200 JL=1,ILEV
         IF(ILEV.EQ.1.OR.LSGLEV(JL)) THEN
            CALL RDSGTS(YOCH4,JF,JL,ZXPM,JPMG,KSTEPP,ZXUM,JPMG,KSTEPU,
     -            KLPR,KLUTF,2,K1PR,K1UTF,NCGHTS,JPMG)
            IF(ILEV.EQ.JPNL) THEN
               IF(YTYPSF.NE.'ET') THEN
                  IF(SFCOUT(JL).GE.100000.0) THEN
                     WRITE(YONAME(26:31),'(I6)')NINT(SFCOUT(JL))
                  ELSE IF(SFCOUT(JL).GE.100.0) THEN
                     WRITE(YONAME(26:31),'(F6.0)')SFCOUT(JL)
                  ELSE IF(SFCOUT(JL).GE.1.0) THEN
                     WRITE(YONAME(26:31),'(F6.3)')SFCOUT(JL)
                  ELSE
                     WRITE(YONAME(26:31),'(F6.5)')SFCOUT(JL)
                  ENDIF
               ELSE
                  WRITE(YONAME(26:31),'(F6.5)')SIGMA(JL)
               ENDIF
            ENDIF
            WRITE(YONAME(33:44),'(F4.0,''/'',F4.0,''N-T'')')
     -         VGHTS(1),VGHTS(2)
            IF(LOUTF.AND.LDGHPL(JF).AND.KLUTF.GE.1) THEN
               ZDAY1=FLOAT(K1UTF)/TSPD
               ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
               IPTYP=24
               IF(KLUTF.NE.KSTEPU) THEN
                  IPTYP=0
                  CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
                  CALL MLABEL(ZLONG,JPMG)
               ENDIF
               CALL U14OUT(ZXUM,JPMG,KLUTF,JPMG,IPTYP,0,0,ILVTYP,1,0,
     -               CIGH(JF),2,YONAME,50,NCUTF,NASCII,IFAIL,
     -               ZDAY1,ZDAY2,ZLONG,ZXUT,'Longitude','Time',
     -               9,4,ITFLAG,ZXUM)
            ENDIF
            IF(LOPR.AND.LDGHPR(JF).AND.KLPR.GE.1) THEN
               ZDAY1=FLOAT(K1PR)/TSPD
               ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
               CALL GMTOUT(JPMG,KLPR,ZXPM,0.0,NSIGFG,-1,1,
     -            NCSG,1,JPMG,1,KLPR,YONAME,ZDAY1,ZDAY2)
            ENDIF
         ENDIF
200      CONTINUE
         CALL DEHEAP(IPPM,KERR)
         CALL DEHEAP(IPUM,KERR)
      ENDIF

**    Zonal means timeseries output
      IF(LDGZ.AND.LDGZZM.AND.LOUT.AND.LDGZTS.AND.
     -      (LDGZPR(JF).OR.LDGZPL(JF))) THEN
         CALL ALLCHP(IPPZ,JPJGG*KSTEPP,KERR)
         CALL ALLCHP(IPUZ,JPJGG*KSTEPU,KERR)
         YOCH4='GZTS'

**       Loop over levels
         DO 1200 JL=1,ILEV
         IF(ILEV.EQ.1.OR.LSGLEV(JL)) THEN
            CALL RDSGTS(YOCH4,JF,JL,ZXPZ,KSTEPP,JPJGG,ZXUZ,KSTEPU,JPJGG,
     -            KLPR,KLUTF,1,K1PR,K1UTF,NCGZTS,JPJGG)
            IF(ILEV.EQ.JPNL) THEN
               IF(YTYPSF.NE.'ET') THEN
                  IF(SFCOUT(JL).GE.100000.0) THEN
                     WRITE(YONAME(26:31),'(I6)')NINT(SFCOUT(JL))
                  ELSE IF(SFCOUT(JL).GE.100.0) THEN
                     WRITE(YONAME(26:31),'(F6.0)')SFCOUT(JL)
                  ELSE IF(SFCOUT(JL).GE.1.0) THEN
                     WRITE(YONAME(26:31),'(F6.3)')SFCOUT(JL)
                  ELSE
                     WRITE(YONAME(26:31),'(F6.5)')SFCOUT(JL)
                  ENDIF
               ELSE
                  WRITE(YONAME(26:31),'(F6.5)')SIGMA(JL)
               ENDIF
            ENDIF
            YONAME(33:44)='T-ZONAL MEAN'
            IF(LOUTF.AND.LDGZPL(JF).AND.KLUTF.GE.1) THEN
               ZDAY1=FLOAT(K1UTF)/TSPD
               ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
               IPTYP=21
               IF(KLUTF.NE.KSTEPU) THEN
                  CALL ATRUNC(ZXUZ,KSTEPU,JPJGG,KLUTF,JPJGG)
                  IPTYP=0
                  CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
               ENDIF
               CALL U14OUT(ZXUZ,KLUTF,JPJGG,KLUTF,IPTYP,0,0,ILVTYP,1,0,
     -               CIGZ(JF),2,YONAME,50,NCUTF,NASCII,IFAIL,
     -               ZDAY1,ZDAY2,ZXUT,ALAT,'Time','Latitude',
     -               4,8,ITFLAG,ZXUZ)
            ENDIF
            IF(LOPR.AND.LDGZPR(JF).AND.KLPR.GE.1) THEN
               ZDAY1=FLOAT(K1PR)/TSPD
               ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
               CALL GTZOUT(KSTEPP,JPJGG,ZXPZ,0.0,NSIGFG,-1,1,
     -            NCSG,1,KLPR,1,JPJGG,YONAME,ZDAY1,ZDAY2)
            ENDIF
         ENDIF
1200     CONTINUE
         CALL DEHEAP(IPPZ,KERR)
         CALL DEHEAP(IPUZ,KERR)
      ENDIF

**    Meridional mean timeseries output
      IF(LDGM.AND.LDGMMM.AND.LOUT.AND.LDGMTS.AND.
     -      (LDGMPR(JF).OR.LDGMPL(JF))) THEN
         CALL ALLCHP(IPPM,JPMG*KSTEPP,KERR)
         CALL ALLCHP(IPUM,JPMG*KSTEPU,KERR)
         YOCH4='GMTS'

**       Loop over levels
         DO 1300 JL=1,ILEV
         IF(ILEV.EQ.1.OR.LSGLEV(JL)) THEN
            CALL RDSGTS(YOCH4,JF,JL,ZXPM,JPMG,KSTEPP,ZXUM,JPMG,KSTEPU,
     -            KLPR,KLUTF,2,K1PR,K1UTF,NCGMTS,JPMG)
            IF(ILEV.EQ.JPNL) THEN
               IF(YTYPSF.NE.'ET') THEN
                  IF(SFCOUT(JL).GE.100000.0) THEN
                     WRITE(YONAME(26:31),'(I6)')NINT(SFCOUT(JL))
                  ELSE IF(SFCOUT(JL).GE.100.0) THEN
                     WRITE(YONAME(26:31),'(F6.0)')SFCOUT(JL)
                  ELSE IF(SFCOUT(JL).GE.1.0) THEN
                     WRITE(YONAME(26:31),'(F6.3)')SFCOUT(JL)
                  ELSE
                     WRITE(YONAME(26:31),'(F6.5)')SFCOUT(JL)
                  ENDIF
               ELSE
                  WRITE(YONAME(26:31),'(F6.5)')SIGMA(JL)
               ENDIF
            ENDIF
            YONAME(33:44)='MERID.MEAN-T'
            IF(LOUTF.AND.LDGMPL(JF).AND.KLUTF.GE.1) THEN
               ZDAY1=FLOAT(K1UTF)/TSPD
               ZDAY2=ZDAY1+FLOAT((KLUTF-1)*NFREQA)/TSPD
               IPTYP=24
               IF(KLUTF.NE.KSTEPU) THEN
                  IPTYP=0
                  CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KLUTF)
                  CALL MLABEL(ZLONG,JPMG)
               ENDIF
               CALL U14OUT(ZXUM,JPMG,KLUTF,JPMG,IPTYP,0,0,ILVTYP,1,0,
     -               CIGM(JF),2,YONAME,50,NCUTF,NASCII,IFAIL,
     -               ZDAY1,ZDAY2,ZLONG,ZXUT,'Longitude','Time',
     -               9,4,ITFLAG,ZXUM)
            ENDIF
            IF(LOPR.AND.LDGMPR(JF).AND.KLPR.GE.1) THEN
               ZDAY1=FLOAT(K1PR)/TSPD
               ZDAY2=ZDAY1+FLOAT((KLPR-1)*NFREQP)/TSPD
               CALL GMTOUT(JPMG,KLPR,ZXPM,0.0,NSIGFG,-1,1,
     -            NCSG,1,JPMG,1,KLPR,YONAME,ZDAY1,ZDAY2)
            ENDIF
         ENDIF
1300     CONTINUE
         CALL DEHEAP(IPPM,KERR)
         CALL DEHEAP(IPUM,KERR)
      ENDIF

**    Column profile and column-total/mean output
      IF(LDGP.AND.(LDGPCT.OR.LDGPCP).AND.LOUT.AND.
     -      (LDGPPR(JF).OR.LDGPPL(JF)).AND.
     -      (JF.NE.15).AND.(JF.NE.16).AND.(JF.NE.20)) THEN
         CALL ALLCHP(IPPP,KSTEPP*JPNL*JPGPPF,KERR)
         CALL ALLCHP(IPUP,KSTEPU*JPNL*JPGPPF,KERR)
         CALL ALLCHP(IPPC,KSTEPP*JPGPPF,KERR)
         CALL ALLCHP(IPUC,KSTEPU*JPGPPF,KERR)
         YOCP='PROFILE'
         YOCT='C TOTAL'
         CALL RDGPTS(YOCP,YOCT,JF,ZXPP,KSTEPP,JPNL,NGPPF,
     -         ZXUP,KSTEPU,JPNL,NGPPF,ZXPC,KSTEPP,NGPPF,
     -         ZXUC,KSTEPU,NGPPF,KPPR,KPUTF,KCPR,KCUTF,1,
     -         K1PPR,K1PUTF,K1CPR,K1CUTF,NCGPTS,JPGPPF,
     -         ZDATA,ZDATAP)

**    Output column profile time-series
         YONAME(33:44)='T - PROFILE '
         IF(LOUTF.AND.LDGPCP.AND.LDGPPL(JF).AND.KPUTF.GE.1) THEN
            ZDAY1=FLOAT(K1PUTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KPUTF-1)*NFREQA)/TSPD
            IPTYP=23
            IF(KPUTF.NE.KSTEPU) THEN
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KPUTF)
            ENDIF
            DO 5100 JP=1,NGPPF
            WRITE(YONAME(21:31),'(2I5)') NINT(VGPPF(1,JP)),
     -            NINT(VGPPF(2,JP))
            IF(KPUTF.NE.KSTEPU) THEN
               CALL ATRUNC(ZXUP(1,1,JP),KSTEPU,JPNL,KPUTF,JPNL)
               IPTYP=0
            ENDIF
            CALL U14OUT(ZXUP(1,1,JP),KPUTF,JPNL,KPUTF,IPTYP,0,0,ILVTYP,
     -            1,0,CIGP(JF),2,YONAME,50,NCUTF,NASCII,IFAIL,
     -            ZDAY1,ZDAY2,ZXUT,ALAT,'Time','Sigma',
     -            4,5,ITFLAG,ZXUP(1,1,JP))
5100        CONTINUE
         ENDIF
         IF(LOPR.AND.LDGPCP.AND.LDGPPR(JF).AND.KPPR.GE.1) THEN
            ZDAY1=FLOAT(K1PPR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KPPR-1)*NFREQP)/TSPD
            DO 5110 JP=1,NGPPF
            WRITE(YONAME(21:31),'(2I5)') NINT(VGPPF(1,JP)),
     -            NINT(VGPPF(2,JP))
            CALL GTPOUT(KSTEPP,JPNL,ZXPP(1,1,JP),0.0,NSIGFG,-1,1,
     -            NCSG,1,KPPR,1,JPNL,YONAME,ZDAY1,ZDAY2)
5110        CONTINUE
         ENDIF

**    Output column total time-series
         YONAME(33:44)=' T - TOTALS '
         IF(LOUTF.AND.LDGPCT.AND.LDGPPL(JF).AND.KCUTF.GE.1) THEN
            ZDAY1=FLOAT(K1CUTF)/TSPD
            ZDAY2=ZDAY1+FLOAT((KCUTF-1)*NFREQA)/TSPD
            IPTYP=31
            IXTYP=4
            IF(KCUTF.NE.KSTEPU) THEN
               IXTYP=0
               CALL TLABEL(ZDAY1,ZDAY2,ZXUT,KCUTF)
            ENDIF
            DO 5200 JP=1,NGPPF
            IFAIL=0
            WRITE(YONAME(21:31),'(2I5)') NINT(VGPPF(1,JP)),
     -            NINT(VGPPF(2,JP))
            CALL G14OUT(ZXUT,ZXUC(1,1,JP),KCUTF,1,IPTYP,0,ILVTYP,1,
     -            IXTYP,ZDAY1,ZDAY2,YONAME,'Time (days)',
     -            'Column total',' ',ZDAY1,ZDAY2,IFAIL,ITFLAG)
5200        CONTINUE
         ENDIF
         IF(LOPR.AND.LDGPCT.AND.LDGPPR(JF).AND.KCPR.GE.1) THEN
            ZDAY1=FLOAT(K1CPR)/TSPD
            ZDAY2=ZDAY1+FLOAT((KCPR-1)*NFREQP)/TSPD
            DO 5210 JP=1,NGPPF
            WRITE(YONAME(21:31),'(2I5)') NINT(VGPPF(1,JP)),
     -            NINT(VGPPF(2,JP))
            CALL GTSOUT(KCPR,ZXPC(1,1,JP),0.0,NSIGFG,1,
     -            NCSG,YONAME,ZDAY1,ZDAY2)
5210        CONTINUE
         ENDIF

         CALL DEHEAP(IPPP,KERR)
         CALL DEHEAP(IPUP,KERR)
         CALL DEHEAP(IPPC,KERR)
         CALL DEHEAP(IPUC,KERR)
      ENDIF

100   CONTINUE

      CALL DEHEAP(IPUT,KERR)

      RETURN
      END
      SUBROUTINE SGCALC
**    Function - to control SG diagnostics at each timestep
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /VARTIM/LTOUT,LTASCI/SGDIAG/LDG3,LDSGIN,LDSGTD,LDSGTS
**    Com changed - none
**    Params used - /PARAM1/JPNL
**    Called by - ANALYS
**    Calls - SGINST,TIMACC,OPSG3D
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT

**    Instantaneous fields output and time-series created
      IF(LTOUT.AND.(LDSGIN.OR.LDSGTS)) CALL SGINST

**    Time averages: accumulations
      IF(LDSGTD) CALL TIMACC

**    Output 3D fields
      IF(LTOUT.AND.LDG3.AND.LTASCI.AND.LDSGIN) CALL OPSG3D(.TRUE.)

      RETURN
      END
      SUBROUTINE SGCONV(PX,KDIM3,KDATLV,KF)
**    Function - to convert SG fields into output units
**    Args in -
**               PX      - Input field
**               KDIM3   - Third dimension of PX (corresponds to number
**                         of levels)
**               KDATLV  - Number of levels of data stored in PX
**               KF      - Output field number in the range 1 to JPSGMX
**    Args out -
**               PX      - Modified field (in the first JPMG elements of
**                         each latitude row only)
**    Args for work - none
**    Com used - /LEGAU/SI,CS,/INVAR/WROTAT,/COMDAT/YTYPSF,/COMIOC/
**          NCGP,/COMNGP/NR1TH,/COMAVG/LMASSW,/CURSGF/all elements
**    Com changed - /CWORK/WORKM
**    Params used - /PARAM1/JPMG,JPNHEM,JPJG,JPNL,/PARAM2/JPMGPP,
**          /PARAM3/JPSGMX
**    Called by - OPSG3D,OPSG,SGINST
**    Calls - ABORT
**    Files read - NCGP(1)
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMPLEX EZ
      COMMON /INVAR/GPI,PI2,REFP0,GA,RD,RV,CPD,CPV,AKAP,CLATNT,CTT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR,
     -      BLVAD
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      DIMENSION PX(JPMGPP,JPNHEM,KDIM3,JPJG)
      DIMENSION ZDPDTH(JPMGPP,JPNHEM,JPNL)
      EQUIVALENCE (ZDPDTH(1,1,1),WORKM(1,1))

      IF(KF.LT.1.OR.KF.GT.JPSGMX) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***SGCONV: ERROR IN VALUE OF KF. ABORT CALLED')
         CALL ABORT
      ENDIF

**    If fields are mass-weighted on isentropic surfaces, then output
**    units are MKS values - so just need to remove planetary vorticity
**    component from total vorticity
      IF(YTYPSF.EQ.'TH'.AND.LMASSW) THEN
         IF(KF.EQ.2) THEN
            IF(KDATLV.NE.JPNL) THEN
               WRITE(6,6010)
6010           FORMAT(1X,'***SGCONV: KDATLV INVALID. ABORT CALLED')
               CALL ABORT
            ENDIF
            DO 1200 JL=1,JPJG
            READ(NCGP(1),REC=NR1TH+JPJG-1)ZDPDTH
            DO 1200 JV=1,JPNL
            DO 1200 JH=1,JPNHEM
            ZOFF=-2.0*SI(JL)*WROTAT*FLOAT(3-2*JH)
            DO 1200 J=1,JPMG
            PX(J,JH,JV,JL)=PX(J,JH,JV,JL)+ZOFF*ZDPDTH(J,JH,JV)
1200        CONTINUE
            RETURN
         ELSE
            RETURN
         ENDIF
      ENDIF

**    For non-isentropic output, or non-mass-weighted isentropic o/p...
      IF(KF.EQ.2) THEN
**       Remove planetary vorticity to obtain relative vorticity
         DO 200 JL=1,JPJG
         DO 200 JV=1,KDATLV
         DO 200 JH=1,JPNHEM
         ZOFF=-2.0*SI(JL)*WROTAT*FLOAT(3-2*JH)
         DO 200 J=1,JPMG
         PX(J,JH,JV,JL)=PX(J,JH,JV,JL)+ZOFF
200      CONTINUE
         RETURN
      ELSE IF(KF.EQ.4) THEN
**       Omega - convert from MKS to mb/hr (*3600*0.01)
         ZFAC=36.0
         ZOFF=0.0
      ELSE IF((KF.EQ.5).OR.(KF.EQ.6)) THEN
**       Zonal and meridional wind - remove cos(latitude) factor
         DO 500 JL=1,JPJG
         ZFAC=1.0/CS(JL)
         DO 500 JV=1,KDATLV
         DO 500 JH=1,JPNHEM
         DO 500 J=1,JPMG
         PX(J,JH,JV,JL)=PX(J,JH,JV,JL)*ZFAC
500      CONTINUE
         RETURN
      ELSE IF(KF.EQ.7) THEN
**       Subtract 273.15K to obtain values in Celcius
         ZFAC=1.0
         ZOFF=-273.15
      ELSE IF(KF.EQ.9) THEN
**       Convert moisture to g/kg
         ZFAC=1000.0
         ZOFF=0.0
      ELSE IF(KF.EQ.10) THEN
**       Convert diabatic heating to K/day
         ZFAC=86400.0
         ZOFF=0.0
      ELSE IF((KF.EQ.12).OR.(KF.EQ.15).OR.(KF.EQ.16)) THEN
**       Convert pressure to mb
         ZFAC=0.01
         ZOFF=0.0
      ELSE IF(KF.EQ.14) THEN
**       Convert potential vorticity units from MKS to pvu
         ZFAC=1.0E6
         ZOFF=0.0
      ELSE
**       No offsets or factors to be applied
         RETURN
      ENDIF

      DO 4000 JL=1,JPJG
      DO 4000 JV=1,KDATLV
      DO 4000 JH=1,JPNHEM
      DO 4000 J=1,JPMG
      PX(J,JH,JV,JL)=PX(J,JH,JV,JL)*ZFAC+ZOFF
4000  CONTINUE

      RETURN
      END
      SUBROUTINE SGFLUX(LPSG,LPTR,LPTF,LPOD,LPZF)
**    Function - to control the step-by-step gridpoint field
**          production, including tracers.
**          The spectral data is converted to gridpoint data on model
**          levels, one latitude at a time. The data is interpolated
**          to pressure or theta surfaces dependent upon the type of
**          output levels requested by the user. Transient flux
**          calculations are then performed on the current latitude,
**          as are the zonal-mean flux calculations.
**    Args in -
**               LPSG    - .TRUE. if SG diagnostics requested.
**               LPTR    - .TRUE. if TR diagnostics requested or if
**                         tracers are needed for other calculations
**               LPTF    - .TRUE. if TF calculations are required
**               LPOD    - .TRUE. if OD calculations are required
**               LPZF    - .TRUE. if ZF calculations are required
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCLEG,NCROGG,NCETWK,/COMDAT/LROGR,YTYPSF,
**          /COMFFT/NTWG,WORK,TRIG,MFAX,NRSTWG,/LEGAU/JINC,
**          /COMAVG/LMASSW,/COMTRV/NTRCRS,/TFCNST/LTFGLB,
**          /COMPRL/APX,APY,/ZFCNST/LZFGLB
**    Com changed - /GRIDP/UG...CHIG,/LEGAU/ALP,DALP,RLP,RDLP,
**          /COMROG/GSG
**    Params used - JPDAG,/PARAM1/JPJG,JPJGL,JPCRAY,JPMG,/PARAM2/JPMGPP
**          ,/PARAM3/JPTFMX,JPZFMX
**    Called by - ANALYS
**    Calls - LTI,FFT991,FFTTR,GRMULT,WRITSG,INTPR,INTTH,MSSFAC,SFCHDV,
**          WRITTR,TFCONT,ODFLXL,ODFLXG,ZFCONT
**    Files read - NCLEG,NCROGG
**    Files written - NCETWK
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      PARAMETER(JPDAG=JPIGC*JPNLWG)
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /COMROG/GSG(JPIGC,JPJGL)
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LZFTRC,LDZFPR,LDZFPL,LZFGLB,LZFLEV
      CHARACTER*50 YNAMZF
      COMMON /ZFCNST/LZFTRC,LDZFPR(JPZFMX),LDZFPL(JPZFMX),LZFGLB,
     -      CIZF(JPZFMX),LZFLEV(JPNL),YNAMZF(2,JPZFMX)
      LOGICAL LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      COMMON /ZFDIAG/NCZF,NZFPR(JPZFMX),NZFPL(JPZFMX),
     -      CINTZF(JPZFMX),NVZFHR(JPNL),
     -      NZF,FACTZF(2,JPZFMX),NFLDZF(4,JPZFMX),VZFSFC(JPNL),
     -      LZFEDF,LZFMNF,LDZFIN,LDZFTD,LDZFTS,LDZFZM,LDZFLM
      LOGICAL LPSG,LPTR,LPTF,LPOD,LPZF
      DIMENSION ZDAG(JPDAG)
      EQUIVALENCE(ZDAG(1),UG(1))

      REWIND NCETWK
      IF(JPJGL.EQ.1) THEN
**       Orography and Legendre functions will be read off scratch
         REWIND NCLEG
         IF(LROGR) REWIND NCROGG
      ENDIF

**    IL: second dimension index of Legendre functions and orography
      IL=1
      DO 100 JIH=1,JPJG
**    IJH: current latitude counter
      IJH=JIH
      IF(JPJGL.EQ.1) THEN
         READ(NCLEG)ALP,DALP,RLP,RDLP
         IF(LROGR) READ(NCROGG) GSG
      ENDIF

**    Spectral to Fourier space transforms
      CALL LTI(IL,LPTR)

**    The first 14 arrays of /GRIDP/ now contain fourier coefficients,
**    as do the TRCRG arrays.
**    FFT991 now converts these to gridpoint values in blocks of NCRAY
**    values for optimal efficiency.
      IF(NTWG.GT.0) THEN
         DO 50 J=1,NTWG
         IINIT=1+(J-1)*JPCRAY*JPMGPP
         CALL FFT991(ZDAG(IINIT),WORK,TRIG,MFAX,1,JPMGPP,JPMG,JPCRAY,1)
50       CONTINUE
      ENDIF
      IINIT=1+NTWG*JPCRAY*JPMGPP
      CALL FFT991(ZDAG(IINIT),WORK,TRIG,MFAX,1,JPMGPP,JPMG,NRSTWG,1)
C     WRITE(4,*)'BACK FROM FFT991 IN SGFLUX, REMAINDER'
C     WRITE(4,*)'PLG = ',APSFCG(1),APSFCG(3)
**    Arrays UG - CHIG now contain gridpoint values

**    Now compute remaining gridpoint fields on model levels
      CALL GRMULT(IJH,IL)
C     WRITE(4,*)'PLG = ',APSFCG(1),APSFCG(3)

**    If output on sigma surfaces, copy **G files to scratch
      IF(YTYPSF.EQ.'ET') THEN
         CALL WRITSG(.TRUE.,.TRUE.,.TRUE.,.TRUE.,.TRUE.,IJH)
**    else if output on isobaric surfaces
**          interpolate fields to pressure levels, and copy all fields
**          (except for streamfunction, velocity potential,
**          divergence and vorticity) to scratch
      ELSE IF(YTYPSF.EQ.'IS') THEN
CC       CALL DVPCOR(IJH)
         CALL INTPR(IL,LPTR)
         CALL WRITSG(.FALSE.,.FALSE.,.FALSE.,.FALSE.,.TRUE.,IJH)
**    else if output on theta surfaces
**          interpolate fields to theta levels, multiply appropriate
**          fields by (-1/g)d(p)/d(theta) and copy all fields
**          (except for streamfunction, velocity potential,
**          divergence and vorticity) to scratch
      ELSE IF(YTYPSF.EQ.'TH') THEN
CC       CALL DVTCOR(IJH)
         CALL INTTH(IL,LPTR)
         IF(LMASSW) CALL MSSFAC(LPTR)
         CALL WRITSG(.FALSE.,.FALSE.,.FALSE.,.FALSE.,.TRUE.,IJH)
      ENDIF

**    Now determine contributions to the transient fluxes for the
**    current latitude
      IF(LPTF.AND.(.NOT.LTFGLB)) CALL TFCONT(IJH,.TRUE.)

**    JINC=1 if Legendre functions and orography stored in COMMON for
**    all latitudes; JINC=0 if they are read off scratch.
      IL=IL+JINC
100   CONTINUE

**    /SPECTR/ can now be used as work space - sigma-level spectral
**    information no longer required

**    For output on non-sigma surfaces, the streamfunction and velocity
**    potential, vorticity and divergence are computed from the
**    interpolated gridpoint velocity fields. SFCHDV also writes
**    these four resulting fields to scratch.
      IF(YTYPSF.NE.'ET') THEN
         CALL SFCHDV
      ENDIF

**    Now determine contributions to the transient fluxes for all
**    the latitudes
      IF(LPTF.AND.LTFGLB) THEN
         DO 150 JIH=1,JPJG
         IJH=JIH
         CALL TFCONT(IJH,.FALSE.)
150      CONTINUE
      ENDIF

**    Compute horizontal logical land/air masks
      CALL LLAIR(.TRUE.)

      RETURN
      END
      SUBROUTINE SGINIT(LPSG)
**    Function - to initialise the arrays and constants required by the
**          SG diagnostics
**    Args in -
**               LPSG    - .TRUE. if SG diagnostics are required
**    Args out -
**               LPSG    - may be set to false if SG diagnostics are
**                         inappropriate
**    Args for work - none
**    Com used - /COMDAT/LWRITE,LASCII,YTYPSF,/SGDIAG/LDSGIN,
**          LDSGTD,LDSGTS,NVSGHR,VSGSFC,/LVDIAG/NLEVEL,SFCOUT,
**          /GPDIAG/NGPPR,NGPPL,CINTGP,/GHDIAG/NGHPR,NGHPL,CINTGH,
**          NGHVEC,/GMDIAG/NGMPR,NGMPL,CINTGM,NGMVEC,/GZDIAG/NGZPR,
**          NGZPL,CINTGZ,NGZVEC,/COMNGP/all elements,/G3DIAG/NG3PL,
**          /COMAVG/LMASSW
**    Com changed - /SGCNST/all elements,/G3CNST/all elements,
**          /GPCNST/all elements,/GHCNST/all elements,/GZCNST/all
**          elements,/GMCNST/all elements
**    Params used - /PARAM1/JPNL,/PARAM3/JPSGMX
**    Called by - DINIT
**    Calls - TIMINI
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LDG3PL
      COMMON /G3CNST/LDG3PL(JPSGMX)
      COMMON /G3DIAG/NCG3,NG3PL(JPSGMX),NG3
      LOGICAL LDGHPR,LDGHPL,LDGHWV
      COMMON /GHCNST/LDGHPR(JPSGMX),LDGHPL(JPSGMX),LDGHWV(JPSGMX),
     -      CIGH(JPSGMX)
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      LOGICAL LDGMPR,LDGMPL,LDGMWV
      COMMON /GMCNST/LDGMPR(JPSGMX),LDGMPL(JPSGMX),LDGMWV(JPSGMX),
     -      CIGM(JPSGMX)
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      LOGICAL LDGPPR,LDGPPL
      COMMON /GPCNST/LDGPPR(JPSGMX),LDGPPL(JPSGMX),CIGP(JPSGMX)
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      LOGICAL LDGZPR,LDGZPL,LDGZWV
      COMMON /GZCNST/LDGZPR(JPSGMX),LDGZPL(JPSGMX),LDGZWV(JPSGMX),
     -      CIGZ(JPSGMX)
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      DIMENSION ZCISG(JPSGMX),ZOUT(JPNL)
      LOGICAL LPSG,LOFLG1,LOFLG2
      CHARACTER*50 YONAME(JPSGMX),YONTHG,YOWNAM(JPSGMX)
      DATA (YONAME(J),J=1,10)/
     -       'STREAM FUNCTION                               M2/S'
     -      ,'RELATIVE VORTICITY                             S-1'
     -      ,'DIVERGENCE                                     S-1'
     -      ,'OMEGA                                         MB/H'
     -      ,'ZONAL WIND                                     M/S'
     -      ,'MERIDIONAL WIND                                M/S'
     -      ,'TEMPERATURE                                   DEGC'
     -      ,'GEOPOTENTIAL HEIGHT                              M'
     -      ,'SPECIFIC HUMIDITY                             G/KG'
     -      ,'DIABATIC HEATING                              K/DY'/

      DATA (YONAME(J),J=11,JPSGMX)/
     -       'VELOCITY POTENTIAL                            M2/S'
     -      ,'PRESSURE                                        MB'
     -      ,'POT. TEMPERATURE                              DEGK'
     -      ,'POT. VORTICITY                                 PVU'
     -      ,'SURFACE PRESSURE                                MB'
     -      ,'MSL PRESSURE                                    MB'
     -      ,'ZONAL NON-LIN MOM T                           M/S2'
     -      ,'MERID NON-LIN MOM T                           M/S2'
     -      ,'G.Z + CP.T                                    J/KG'
     -      ,'SURFACE THETA                                 DEGK'
     -      ,'AIR(1),LAND(0)                                    '/

      DATA YONTHG/
     -       '-(1/G).DP/D(TH)                                MKS'/

      DATA (YOWNAM(J),J=1,10)/
     -       '(SIGMAxPSI)*                                   MKS'
     -      ,'(SIGMAxREL VORT)*                              MKS'
     -      ,'(SIGMA x DIV)*                                 MKS'
     -      ,'SIGMA x OMEGA                                  MKS'
     -      ,'SIGMA x ZONAL WIND                             MKS'
     -      ,'SIGMA x MERID WIND                             MKS'
     -      ,'SIGMA x TEMPERATURE                            MKS'
     -      ,'SIGMA x GEOP HEIGHT                            MKS'
     -      ,'SIGMA x SPEC HUMID                             MKS'
     -      ,'SIGMA x DIAB HEATG                             MKS'/

      DATA (YOWNAM(J),J=11,JPSGMX)/
     -       '(SIGMAxVEL POTNTL)*                            MKS'
     -      ,'PRESSURE                                       MKS'
     -      ,'POT. TEMPERATURE                               MKS'
     -      ,'SIGMAxPOT. VORTICI                             MKS'
     -      ,'SURFACE PRESSURE                               MKS'
     -      ,'MSL PRESSURE                                   MKS'
     -      ,'SIGxZONAL N-L MOM T                            MKS'
     -      ,'SIGxMERID N-L MOM T                            MKS'
     -      ,'SIGMAx(G.Z + CP.T)                             MKS'
     -      ,'SURFACE THETA                                  MKS'
     -      ,'AIR(1),LAND(0)                                    '/

      DATA (ZCISG(J),J=1,JPSGMX)/1.0E7,  1.0E-5,  1.0E-6,  1.0,
     -      10.0,  10.0,  4.0,  200.0,  1.0,  1.0,  1.0E6,  20.0,
     -      4.0,  1.0,  5.0,  1.0,  1.0,  1.0,  10.0, 1000.0, 0.1/

      write(4,*)'WIERD BUGFIX'
**    To facilitate output, NGPIND and NSEQGP are created, the index
**    of these arrays corresponding to the YONAME fields in the order
**    above.
**    NGPIND contains a sequence of 1's and 2's indicating which of
**    NCGP(1) and NCGP(2) are used to store each of the SG fields
**    listed above.
      DO 100 J=1,JPSGMX
      NGPIND(J)=1
100   CONTINUE
      NGPIND(15)=2
      NGPIND(16)=2
      NGPIND(20)=2

**    NSEQGP contains a sequence (in the order corresponding to the
**    fields listed above) of the initial record numbers in the NCGP,
**    or equivalent common blocks /CUR.../, /ACC.../,
**    files for these fields. Thus the divergence is contained in the
**    records beginning with the record NSEQGP(3).
      NSEQGP(1)=NR1SF
      NSEQGP(2)=NR1VO
      NSEQGP(3)=NR1D
      NSEQGP(4)=NR1OM
      NSEQGP(5)=NR1U
      NSEQGP(6)=NR1V
      NSEQGP(7)=NR1T
      NSEQGP(8)=NR1GH
      NSEQGP(9)=NR1Q
      NSEQGP(10)=NR1H
      NSEQGP(11)=NR1CHI
      NSEQGP(12)=NR1AP
      NSEQGP(13)=NR1TH
      NSEQGP(14)=NR1EPV
      NSEQGP(15)=NR1PSF
      NSEQGP(16)=NR1PSL
      NSEQGP(17)=NR1FU
      NSEQGP(18)=NR1FV
      NSEQGP(19)=NR1MSF
      NSEQGP(20)=NR1THS
      NSEQGP(21)=NR1ALM

**    Process namelist information, and set up array titles etc
**    Default values set
      DO 1000 JI=1,JPSGMX
      CIGP(JI)=ZCISG(JI)
      CIGH(JI)=ZCISG(JI)
      CIGM(JI)=ZCISG(JI)
      CIGZ(JI)=ZCISG(JI)
      LDGHWV(JI)=.FALSE.
      LDGMWV(JI)=.FALSE.
      LDGZWV(JI)=.FALSE.
      LDG3PL(JI)=.FALSE.
      LDGPPL(JI)=.FALSE.
      LDGHPL(JI)=.FALSE.
      LDGMPL(JI)=.FALSE.
      LDGZPL(JI)=.FALSE.
      LDGPPR(JI)=.FALSE.
      LDGHPR(JI)=.FALSE.
      LDGMPR(JI)=.FALSE.
      LDGZPR(JI)=.FALSE.
      YNAMSG(JI)=YONAME(JI)
1000  CONTINUE

**    When output is on theta surfaces THG array will contain
**    -(1/g).d(P)/d(TH) at output
      IF(YTYPSF.EQ.'TH') THEN
         IF(LMASSW) THEN
            DO 1050 JI=1,JPSGMX
            YNAMSG(JI)=YOWNAM(JI)
1050        CONTINUE
         ENDIF
         YNAMSG(13)=YONTHG
      ENDIF

      DO 1100 JL=1,JPNL
      LSGLEV(JL)=.FALSE.
1100  CONTINUE

**    Now overwrite the default values according to the user's
**    namelist input
**    ZZERO is a small constant used to detect the value 0.0. It should
**    be smaller than any expected user-input contour value.
      ZZERO=1.0E-3
      DO 2000 JI=1,JPSGMX

**    Printing control
      IGPGR=NGPPR(JI)
      IF(IGPGR.GT.0.AND.IGPGR.LE.JPSGMX) THEN
         LDGPPR(IGPGR)=.TRUE.
      ENDIF
      IGHGR=NGHPR(JI)
      IF(IGHGR.GT.0.AND.IGHGR.LE.JPSGMX) THEN
         LDGHPR(IGHGR)=.TRUE.
      ENDIF
      IGMGR=NGMPR(JI)
      IF(IGMGR.GT.0.AND.IGMGR.LE.JPSGMX) THEN
         LDGMPR(IGMGR)=.TRUE.
      ENDIF
      IGZGR=NGZPR(JI)
      IF(IGZGR.GT.0.AND.IGZGR.LE.JPSGMX) THEN
         LDGZPR(IGZGR)=.TRUE.
      ENDIF

**    Plotting control
      IG3PL=NG3PL(JI)
      IF(IG3PL.GT.0.AND.IG3PL.LE.JPSGMX) THEN
         LDG3PL(IG3PL)=.TRUE.
      ENDIF
      IGPPL=NGPPL(JI)
      IF(IGPPL.GT.0.AND.IGPPL.LE.JPSGMX) THEN
         LDGPPL(IGPPL)=.TRUE.
         IF(ABS(CINTGP(JI)).GT.ZZERO) CIGP(IGPPL)=CINTGP(JI)
      ENDIF
      IGHPL=NGHPL(JI)
      IF(IGHPL.GT.0.AND.IGHPL.LE.JPSGMX) THEN
         LDGHPL(IGHPL)=.TRUE.
         IF(ABS(CINTGH(JI)).GT.ZZERO) CIGH(IGHPL)=CINTGH(JI)
      ENDIF
      IGZPL=NGZPL(JI)
      IF(IGZPL.GT.0.AND.IGZPL.LE.JPSGMX) THEN
         LDGZPL(IGZPL)=.TRUE.
         IF(ABS(CINTGZ(JI)).GT.ZZERO) CIGZ(IGZPL)=CINTGZ(JI)
      ENDIF
      IGMPL=NGMPL(JI)
      IF(IGMPL.GT.0.AND.IGMPL.LE.JPSGMX) THEN
         LDGMPL(IGMPL)=.TRUE.
         IF(ABS(CINTGM(JI)).GT.ZZERO) CIGM(IGMPL)=CINTGM(JI)
      ENDIF

**    Wind vectors
      IGHWV=NGHVEC(JI)
      IF(IGHWV.GT.0.AND.IGHWV.LE.JPSGMX) THEN
         LDGHWV(IGHWV)=.TRUE.
      ENDIF
      IGZWV=NGZVEC(JI)
      IF(IGZWV.GT.0.AND.IGZWV.LE.JPSGMX) THEN
         LDGZWV(IGZWV)=.TRUE.
      ENDIF
      IGMWV=NGMVEC(JI)
      IF(IGMWV.GT.0.AND.IGMWV.LE.JPSGMX) THEN
         LDGMWV(IGMWV)=.TRUE.
      ENDIF
2000  CONTINUE

**    Output level numbers determined - level numbers refer to
**          increasing values of sigma, theta, pressure, etc.
      IF(YTYPSF.EQ.'ET') THEN
**       Use NVSGHR to define LSGLEV
         DO 2400 JL=1,JPNL
         ILEV=NVSGHR(JL)
         LSGLEV(ILEV)=.TRUE.
2400     CONTINUE
      ELSE
**       Use VSGSFC to define LSGLEV. LSGLEV(JL) set to .TRUE. if JL
**       occurs in the array NLEVEL, and if SFCOUT(JL) occurs in
**       array VSGSFC
         IF(YTYPSF.EQ.'TH') THEN
            DO 2500 J=1,JPNL
            ZOUT(J)=SFCOUT(J)
2500        CONTINUE
         ELSE IF(YTYPSF.EQ.'IS') THEN
            DO 2600 J=1,JPNL
            ZOUT(J)=SFCOUT(J)*0.01
2600        CONTINUE
         ENDIF
         ZDELTA=1.0E-3
         DO 3000 JL=1,JPNL
**       Check that JL occurs in array NLEVEL
         LOFLG1=.FALSE.
         DO 3100 J=1,JPNL
         IF(NLEVEL(J).EQ.JL) LOFLG1=.TRUE.
3100     CONTINUE
**       Check that ZOUT(JL) occurs in array VSGSFC
         LOFLG2=.FALSE.
         DO 3200 J=1,JPNL
         ZP=VSGSFC(J)+ZDELTA
         ZM=VSGSFC(J)-ZDELTA
         IF(ZOUT(JL).GT.ZM.AND.ZOUT(JL).LT.ZP) LOFLG2=.TRUE.
3200     CONTINUE
         IF(LOFLG1.AND.LOFLG2) LSGLEV(JL)=.TRUE.
3000     CONTINUE
      ENDIF

**    Prepare NCGPAC files (or common blocks /ACCSGF/, /ACCSGS/ and
**          /ACCSGH/) for use with time averages
      IF(LDSGTD) CALL TIMINI

      RETURN
      END
      SUBROUTINE SGINST
**    Function - to control instantaneous SG diagnostics, and the saving
**          of data for later use with timeseries output
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /GHCNST/LDGHPR,LDGHPL,LDGHWV,/GHDIAG/LDGHSL,LDGHCT,
**          VGHTS,/GMCNST/LDGMPR,LDGMPL,LDGMWV,/GMDIAG/LDGMMM,
**          VGMEW,VGMEWA,LDGMTS,/GPCNST/LDGPPR,LDGPPL,/GPDIAG/LDGPCT,
**          LDGPCP,/GZCNST/LDGZPR,LDGZPL,LDGZWV,/GZDIAG/LDGZZM,
**          VGZNS,VGZNSA,LDGZTS,/SGCNST/LSGLEV,NGPIND,NSEQGP,
**          /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDSGTS,LDSGIN,/ORDIAG/LMSKH,
**          LMSKNS,LMSKWE,/VARTIM/DAYT,NSTEPT,LTOUT,LTPRNT,LTASCI
**          /COMDAT/YTYPSF,/COMIOC/NCGP,NCSGSW,/DIAGTP/LDSG,
**          /CURSGF/all elements,/CURSGS/all elements
**    Com changed - /SPECTR/VO...SPAD,/CWORK/WORK3D
**    Params used - /PARAM1/JPNL,JPMG,JPJG,JPNHEM,
**          /PARAM2/JPJGG,JPIGD,JPMGPP/PARAM3/JPSGMX
**    Called by - SGCALC
**    Calls - SGCONV,LLCNVS,MSKPL,SGVEC,HROUT,GZOUT,GMOUT,GPOUT
**    Files read - NCGP(1),NCGP(2)
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDGHPR,LDGHPL,LDGHWV
      COMMON /GHCNST/LDGHPR(JPSGMX),LDGHPL(JPSGMX),LDGHWV(JPSGMX),
     -      CIGH(JPSGMX)
      LOGICAL LDGHSL,LDGHCT,LDGHED
      COMMON /GHDIAG/LDGHSL,LDGHCT,LDGHED,VGHTS(2),
     -      NGHPR(JPSGMX),NGHPL(JPSGMX),NGH,NGHVEC(JPSGMX),
     -      CINTGH(JPSGMX)
      LOGICAL LDGMPR,LDGMPL,LDGMWV
      COMMON /GMCNST/LDGMPR(JPSGMX),LDGMPL(JPSGMX),LDGMWV(JPSGMX),
     -      CIGM(JPSGMX)
      LOGICAL LDGMMM,LDGMTS
      COMMON /GMDIAG/LDGMMM,VGMEW,LDGMTS,VGMEWA(2),NGMPR(JPSGMX),
     -      NGMPL(JPSGMX),NGM,NGMVEC(JPSGMX),CINTGM(JPSGMX)
      LOGICAL LDGPPR,LDGPPL
      COMMON /GPCNST/LDGPPR(JPSGMX),LDGPPL(JPSGMX),CIGP(JPSGMX)
      LOGICAL LDGPCT,LDGPCP
      COMMON /GPDIAG/LDGPCT,NGPPF,VGPPF(2,JPGPPF),NGPPR(JPSGMX),
     -      NGPPL(JPSGMX),NGP,CINTGP(JPSGMX),LDGPCP
      LOGICAL LDGZPR,LDGZPL,LDGZWV
      COMMON /GZCNST/LDGZPR(JPSGMX),LDGZPL(JPSGMX),LDGZWV(JPSGMX),
     -      CIGZ(JPSGMX)
      LOGICAL LDGZZM,LDGZTS
      COMMON /GZDIAG/LDGZZM,VGZNS,LDGZTS,VGZNSA(2),NGZPR(JPSGMX),
     -      NGZPL(JPSGMX),NGZ,NGZVEC(JPSGMX),CINTGZ(JPSGMX)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LSGLEV
      CHARACTER*50 YNAMSG
      COMMON /SGCNST/LSGLEV(JPNL),NGPIND(JPSGMX),NSEQGP(JPSGMX),
     -      YNAMSG(JPSGMX)
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LOFLD,LOGP,LOGH,LOGZ,LOGM
      LOGICAL LOCPPR,LOCPPL,LOCPTS,LOCTPR,LOCTPL,LOCTTS
      LOGICAL LOGHPR,LOGHPL,LOWC,LOWCPR,LOWCPL,LOGHTS
      LOGICAL LOZMPR,LOZMPL,LOLSPR,LOLSPL,LOLRPR,LOLRPL,LOZMTS
      LOGICAL LOMMPR,LOMMPL,LOLAPR,LOLAPL,LOLMPR,LOLMPL,LOMMTS
      LOGICAL LOHVEC,LOHMSK,LOSVEC,LOZVEC,LOZMSK,LOMVEC,LOMMSK,
     -      LODUMY(JPNL)
      DIMENSION Z(JPMG,JPJGG,JPNL),ZR(JPIGD,JPJG)
      EQUIVALENCE (Z(1,1,1),VO(1)),(ZR(1,1),VO(1))
      SAVE LOHMSK,LOHVEC,LOSVEC,LOZVEC,LOZMSK,LOMVEC,LOMMSK,LODUMY
      DATA LOHMSK/.FALSE./,LOHVEC/.FALSE./,LOSVEC/.FALSE./,
     -      LOZVEC/.FALSE./,LOZMSK/.FALSE./,LOMVEC/.FALSE./,
     -      LOMMSK/.FALSE./,LODUMY/JPNL*.FALSE./

      IF(.NOT.LDSG) RETURN
C      IF(.NOT.LECANL) THEN
         ZDAY1=DAYT
C      ELSE
C         ZDAY1=FLOAT(NCDATE)/100.0
C      ENDIF

**    Wind vectors and orographic masks may be required for
**    incorporation into the UTF file, deoending upon the value of
**    certain user-specified switches. Set up a set of default flags
**    here, and if a requirement for vectors or masks is detected later,
**    then modify the flags and undertake the output if not already
**    done.
**    NB. It is up to the user to combine the appropriate fields at the
**    plotting stage.
**    LOHVEC - Flag to indicate that vectors for multi-level fields have
**          been produced.
**    LOSVEC - Flag to indicate that vectors for surface fields (ie
**          vectors at the lowest level) have been produced.
**    LOHMSK - Flag to indicate that latitude-longitude horizontal
**          orographic masks have been sent to the UTF file.
**    LOZVEC - Flag to indicate that vectors for zonal fields have
**          been produced.
**    LOZMSK - Flag to indicate that zonal mean orographic masks
**          have been sent to the UTF file.
**    LOMVEC - Flag to indicate that vectors for meridional fields have
**          been produced.
**    LOMMSK - Flag to indicate that meridional mean orographic masks
**          have been sent to the UTF file.
      LOHVEC=.FALSE.
      LOSVEC=.FALSE.
      LOHMSK=.FALSE.
      LOZVEC=.FALSE.
      LOZMSK=.FALSE.
      LOMVEC=.FALSE.
      LOMMSK=.FALSE.

**    Outer loop is over all possible SG output fields. This means that
**    any required field is read once-only off the scratch files when
**    computing the instantaneous diagnostics.

      DO 100 JF=1,JPSGMX
      LOGP=.FALSE.
      LOGH=.FALSE.
      LOGZ=.FALSE.
      LOGM=.FALSE.
**    First determine if field number JF is required

**    Vertical profile diagnostics
      IF(LDGP) THEN
**       Vertical profiles inappropriate for single level surface fields
         IF((JF.NE.15).AND.(JF.NE.16).AND.(JF.NE.20)) THEN
            IF(LDGPPR(JF).OR.LDGPPL(JF)) LOGP=.TRUE.
         ENDIF
      ENDIF

**    Horizontal level diagnostics
      IF(LDGH.AND.(LDGHPR(JF).OR.LDGHPL(JF))) LOGH=.TRUE.

**    Zonal slice diagnostics
      IF(LDGZ.AND.(LDGZPR(JF).OR.LDGZPL(JF))) LOGZ=.TRUE.

**    Meridional slice diagnostics
      IF(LDGM.AND.(LDGMPR(JF).OR.LDGMPL(JF))) LOGM=.TRUE.

**    LOFLD set to .TRUE. if present field required
      LOFLD=LOGP.OR.LOGH.OR.LOGZ.OR.LOGM

      IF(LOFLD) THEN
**       Read field from scratch files
         ICHAN=NCGP(NGPIND(JF))
         INIREC=NSEQGP(JF)
         IF(NGPIND(JF).EQ.2) THEN
**          Read surface/single level field. Note that although the
**          array ZR has JPIGD elements as its first dimension, only the
**          first JPIGC elements contain values read from scratch.
**          Likewise, Z only contains data for elements (1:1) in the
**          third dimension.
            ILEV=1
            DO 1000 J=1,JPJG
            READ(ICHAN,REC=INIREC-1+J)(ZR(JI,J),JI=1,JPIGC)

1000        CONTINUE

         ELSE
**          Read 3D field
            ILEV=JPNL
            DO 1100 J=1,JPJG
            READ(ICHAN,REC=INIREC-1+J)(ZR(JI,J),JI=1,JPIGD)
1100        CONTINUE
         ENDIF

**       Convert fields to meteorological units required for output
**       and/or interpolation.
         CALL SGCONV(ZR,JPNL,ILEV,JF)
**       Convert to 'standard' indexing format
         CALL LLCNVS(ZR,JPMGPP,JPNHEM,JPNL,JPJG,Z,JPMG,JPJGG,
     -         JPNL,ILEV,.TRUE.,WORK3D,JPMGPP,JPNHEM,JPNL,JPJG,
     -         .TRUE.,NCSGSW)

**       Now perform diagnostics
**       SG horizontal diagnostics
         IF(LOGH) THEN
**          LOGHPR is .TRUE. for horizontal level printout
**          LOGHPL is .TRUE. for horizontal level plots
**          LOWC is .TRUE if column totals through the whole atmosphere
**                to be calculated
**          LOWCPR is .TRUE. if column totals to be printed
**          LOWCPL is .TRUE. if column totals to be plotted
**          LOGHTS is .TRUE if time-series to be built from horizontal
**                level output
            LOGHPR=LDSGIN.AND.LTPRNT.AND.LDGHSL.AND.LDGHPR(JF)
            LOGHPL=LDSGIN.AND.LTASCI.AND.LDGHSL.AND.LDGHPL(JF)
            LOWC  =LDSGIN.AND.LTOUT .AND.LDGHCT.AND.(YTYPSF.EQ.'ET')
     -            .AND.(ILEV.EQ.JPNL)
            LOWCPR=LOWC  .AND.LTPRNT.AND.LDGHPR(JF)
            LOWCPL=LOWC  .AND.LTASCI.AND.LDGHPL(JF)
            LOGHTS=LDGHSL.AND.LTOUT .AND.LDSGTS.AND.
     -            (LDGHPR(JF).OR.LDGHPL(JF)).AND.(VGHTS(1).GT.-990.0)

**          Pass orographic mask to UTF if appropriate
            IF(LOGHPL.AND.(.NOT.LOHMSK).AND.LMSKH.AND.(ILEV.EQ.JPNL)
     -            .AND.YTYPSF.EQ.'IS') THEN
               CALL MSKPL('H',NSTEPT,-1,ZDAY1,-1.0)
               LOHMSK=.TRUE.
            ENDIF

**          Output the horizontal wind vectors if appropriate
**          Firstly, multi-level fields
            IF(LOGHPL.AND.(.NOT.LOHVEC).AND.LDGHWV(JF)) THEN
               IF(ILEV.EQ.JPNL) THEN
                  CALL SGVEC(ZDAY1,-1.0,'H',LSGLEV,.FALSE.)
                  LOHVEC=.TRUE.
**                The next line supposes that surface fields are plotted
**                with level JPNL wind vectors
                  IF(LSGLEV(JPNL)) LOSVEC=.TRUE.
               ENDIF
            ENDIF
**          Secondly, wind vectors for surface fields; the exact level
**          used for these wind vectors is defined in SGVEC
            IF(LOGHPL.AND.(.NOT.LOSVEC).AND.LDGHWV(JF)) THEN
               IF(ILEV.EQ.1) THEN
                  CALL SGVEC(ZDAY1,-1.0,'H',LODUMY,.TRUE.)
                  LOSVEC=.TRUE.
               ENDIF
            ENDIF
            CALL HROUT(ZDAY1,-1.0,JF,Z,ILEV,LOGHPR,LOGHPL,LOWC,LOWCPR,
     -            LOWCPL,LOGHTS)
         ENDIF

**       SG zonal diagnostics
         IF(LOGZ) THEN
**          LOZMPR is .TRUE. for zonal mean printout
**          LOZMPL is .TRUE. for zonal mean plots
**          LOLSPR is .TRUE. for north-south longitude slice printout
**          LOLSPL is .TRUE. for north-south longitude slice plots
**          LOLRPR is .TRUE. for limited longitude-range mean (printout)
**          LOLRPL is .TRUE. for limited longitude-range mean (plot)
**          LOZMTS is .TRUE. to create zonal mean time-series
            LOZMPR=LDGZPR(JF).AND.LTPRNT.AND.LDSGIN.AND.LDGZZM
            LOZMPL=LDGZPL(JF).AND.LTASCI.AND.LDSGIN.AND.LDGZZM
            LOLSPR=LDGZPR(JF).AND.LTPRNT.AND.LDSGIN.AND.
     -            (VGZNS.GT.-990.0)
            LOLSPL=LDGZPL(JF).AND.LTASCI.AND.LDSGIN.AND.
     -            (VGZNS.GT.-990.0)
            LOLRPR=LDGZPR(JF).AND.LTPRNT.AND.LDSGIN.AND.
     -            (VGZNSA(1).GT.-990.0)
            LOLRPL=LDGZPL(JF).AND.LTASCI.AND.LDSGIN.AND.
     -            (VGZNSA(1).GT.-990.0)
            LOZMTS=(LDGZPR(JF).OR.LDGZPL(JF)).AND.LTOUT.AND.LDGZZM
     -            .AND.LDSGTS.AND.LDGZTS

**          Pass orographic mask to UTF if appropriate
            IF(LOZMPL.AND.(.NOT.LOZMSK).AND.LMSKNS.AND.(ILEV.EQ.JPNL)
     -            .AND.YTYPSF.EQ.'IS') THEN
               CALL MSKPL('ZM',NSTEPT,-1,ZDAY1,-1.0)
               LOZMSK=.TRUE.
            ENDIF

**          Output the wind vectors on vertical slices if appropriate
**          Multi-level fields
            IF(LOZMPL.AND.(.NOT.LOZVEC).AND.LDGZWV(JF)) THEN
               IF(ILEV.EQ.JPNL) THEN
                  CALL SGVEC(ZDAY1,-1.0,'ZM',LSGLEV,.FALSE.)
                  LOZVEC=.TRUE.
               ENDIF
            ENDIF

            CALL GZOUT(ZDAY1,-1.0,JF,Z,ILEV,LOZMPR,LOZMPL,LOLSPR,
     -            LOLSPL,LOLRPR,LOLRPL,LOZMTS)
         ENDIF

**       SG meridional diagnostics
         IF(LOGM) THEN
**          LOMMPR is .TRUE. for meridional mean printout
**          LOMMPL is .TRUE. for meridional mean plots
**          LOLAPR is .TRUE. for north-south latitude slice printout
**          LOLAPL is .TRUE. for north-south latitude slice plots
**          LOLMPR is .TRUE. for limited latitude-range mean (printout)
**          LOLMPL is .TRUE. for limited latitude-range mean (plot)
**          LOMMTS is .TRUE. to create meridional mean time-series
            LOMMPR=LDGMPR(JF).AND.LTPRNT.AND.LDSGIN.AND.LDGMMM
            LOMMPL=LDGMPL(JF).AND.LTASCI.AND.LDSGIN.AND.LDGMMM
            LOLAPR=LDGMPR(JF).AND.LTPRNT.AND.LDSGIN.AND.
     -            (VGMEW.GT.-990.0)
            LOLAPL=LDGMPL(JF).AND.LTASCI.AND.LDSGIN.AND.
     -            (VGMEW.GT.-990.0)
            LOLMPR=LDGMPR(JF).AND.LTPRNT.AND.LDSGIN.AND.
     -            (VGMEWA(1).GT.-990.0)
            LOLMPL=LDGMPL(JF).AND.LTASCI.AND.LDSGIN.AND.
     -            (VGMEWA(1).GT.-990.0)
            LOMMTS=(LDGMPR(JF).OR.LDGMPL(JF)).AND.LTOUT.AND.LDGMMM
     -            .AND.LDGMTS.AND.LDSGTS

**          Pass orographic mask to UTF if appropriate
            IF(LOMMPL.AND.(.NOT.LOMMSK).AND.LMSKWE.AND.(ILEV.EQ.JPNL)
     -            .AND.YTYPSF.EQ.'IS') THEN
               CALL MSKPL('MM',NSTEPT,-1,ZDAY1,-1.0)
               LOMMSK=.TRUE.
            ENDIF

**          Output the wind vectors on vertical slices if appropriate
**          Multi-level fields
            IF(LOMMPL.AND.(.NOT.LOMVEC).AND.LDGMWV(JF)) THEN
               IF(ILEV.EQ.JPNL) THEN
                  CALL SGVEC(ZDAY1,-1.0,'MM',LSGLEV,.FALSE.)
                  LOMVEC=.TRUE.
               ENDIF
            ENDIF

            CALL GMOUT(ZDAY1,-1.0,JF,Z,ILEV,LOMMPR,LOMMPL,LOLAPR,
     -            LOLAPL,LOLMPR,LOLMPL,LOMMTS)
         ENDIF

**       SG profile diagnostics
         IF(LOGP) THEN
**          LOCPPR is .TRUE. for column profile printout,
**          LOCPPL is .TRUE. for column profile UTFs,
**          LOCPTS is .TRUE. if column profile time series to be built;
**          LOCTPR is .TRUE. for column total printout,
**          LOCTPL is .TRUE. for column total UTFs,
**          LOCTTS is .TRUE. if column total time series to be built;
            LOCPPR=LDGPCP.AND.LDSGIN.AND.LTPRNT.AND.LDGPPR(JF)
            LOCPPL=LDGPCP.AND.LDSGIN.AND.LTASCI.AND.LDGPPL(JF)
            LOCPTS=LDGPCP.AND.LDSGTS.AND.LTOUT
            LOCTPR=LDGPCT.AND.LDSGIN.AND.LTPRNT.AND.LDGPPR(JF)
            LOCTPL=LDGPCT.AND.LDSGIN.AND.LTASCI.AND.LDGPPL(JF)
            LOCTTS=LDGPCT.AND.LDSGTS.AND.LTOUT
**          Note: GPOUT will cause field Z(JF) to be overwitten if
**                column total amounts are required; this is because the
**                model half-level pressures (a 3D array) need to be
**                read in from the relevant scratch file. CONSEQUENTLY
**                GPOUT SHOULD BE THE LAST ROUTINE CALLED FROM SGINST.
            CALL GPOUT(ZDAY1,-1.0,JF,Z,ILEV,LOCPPR,LOCPPL,
     -            LOCPTS,LOCTPR,LOCTPL,LOCTTS)
         ENDIF

      ENDIF
100   CONTINUE
      RETURN
      END
      SUBROUTINE SGVEC(PDAY1,PDAY2,YPTYPE,LPLEV,LPSFC)
**    Function - to create wind vector UTF fields
**    Args in -
**               PDAY1   - Current day number, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**               YPTYPE  - Character variable defining levels at which
**                         wind vectors will be output; allowed values
**                         are 'H','ZM' and 'MM'
**               LPLEV   - Logical values denoting which of the JPNL
**                         output levels require the output of wind
**                         vectors (used if YPTYPE='H')
**               LPSFC   - .TRUE. if wind vectors required for use with
**                         the surface fields (used if YPTYPE='H')
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGP,NCGPAV,NCUTF,/COMDAT/LUTF14,
**          NASCII,YTYPSF,/COMNGP/NRU1,NRV1,/VERTCL/SIGMA,
**          /LVDIAG/SFCOUT
**    Com changed - /CWORK/WGP2D1,WGP2D2,WGP2D4
**    Params used - /PARAM1/JPMG,JPNHEM,JPNL,/PARAM2/JPJGG,JPMGP,JPJGGP,
**          /PARAM3/JPTRMX
**    Called by - SGINST,OPSG,OPTR,TRINST
**    Calls - GETGVL,U14OUT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      LOGICAL LPLEV(JPNL),LPSFC,LOLEVL(JPNL)
      DIMENSION ZWINDX(JPMG,JPJGG),ZWINDY(JPMG,JPJGG)
      EQUIVALENCE (ZWINDX(1,1),WGP2D1(1,1)),(ZWINDY(1,1),WGP2D2(1,1))
      DIMENSION ZUTF14(JPMG,JPJGG)
      EQUIVALENCE (ZUTF14(1,1),WGP2D4(1,1))
      CHARACTER*50 YONAMU,YONAMV,YONAME
      CHARACTER*(*) YPTYPE
      LOGICAL LOCALZ,LOCALM
      SAVE LOCALZ,LOCALM
      DATA LOCALZ/.TRUE./,LOCALM/.TRUE./

      IF(PDAY1.GT.PDAY2) THEN
         KCHANU=NCGP(1)
         KCHANV=NCGP(1)
      ELSE
         KCHANU=NCGPAV(1)
         KCHANV=NCGPAV(1)
      ENDIF

      YONAME(1:30)='                              '
      IF(YTYPSF.EQ.'ET') THEN
         YONAME(31:35)='SIGMA'
         ILVTYP=0
      ELSE IF(YTYPSF.EQ.'IS') THEN
         YONAME(31:35)='P(PA)'
         ILVTYP=2
      ELSE IF(YTYPSF.EQ.'TH') THEN
         YONAME(31:35)='THETA'
         ILVTYP=3
      ENDIF
**    ZARSTD - Standard arrow length, ie. the magnitude equivalent to
**    one grid interval
      ZARSTD=30.0

      IF(YPTYPE.EQ.'ZM') THEN
         IF(LOCALZ) THEN
            WRITE(6,6000)
6000        FORMAT(1X,/' ******************************************'
     -            /' * SGVEC: WARNING                         *'
     -            /' * ZONAL MEAN WIND VECTORS NOT YET ENABLED*'
     -            /' ******************************************')
            LOCALZ=.FALSE.
         ENDIF
      ENDIF

      IF(YPTYPE.EQ.'MM') THEN
         IF(LOCALM) THEN
            WRITE(6,6010)
6010        FORMAT(1X,/' **********************************************'
     -            /' * SGVEC: WARNING                             *'
     -            /' * MERIDIONAL MEAN WIND VECTORS NOT ENABLED   *'
     -            /' **********************************************')
            LOCALM=.FALSE.
         ENDIF
      ENDIF

      IF(YPTYPE.EQ.'H') THEN
         DO 100 J=1,JPNL
         LOLEVL(J)=LPLEV(J)
100      CONTINUE
**       The following line will enable wind vectors at the output level
**       nearest the surface for use with surface fields.
         LOLEVL(JPNL)=LOLEVL(JPNL).OR.LPSFC

         YONAMU(1:35)=YONAME(1:35)
         YONAMV(1:35)=YONAME(1:35)
         YONAMU(1:6)='U-WIND'
         YONAMV(1:6)='V-WIND'

         IF(PDAY1.GT.PDAY2) THEN
            ITFLAG=0
         ELSE
            ITFLAG=1
         ENDIF

**       Process wind vectors, level by level
         DO 200 JL=1,JPNL
         IF(LOLEVL(JL)) THEN
            CALL GETGVL(ZWINDX,JL,KCHANU,NR1U)
            CALL GETGVL(ZWINDY,JL,KCHANV,NR1V)

**       Wind component titles
            IF(YTYPSF.NE.'ET') THEN
               WRITE(YONAMU(36:50),'('' = '',E11.2,1X)')SFCOUT(JL)
               WRITE(YONAMV(36:50),'('' = '',E11.2,1X)')SFCOUT(JL)
            ELSE
               WRITE(YONAMU(36:50),'('' = '',E11.5,1X)')SIGMA(JL)
               WRITE(YONAMV(36:50),'('' = '',E11.5,1X)')SIGMA(JL)
            ENDIF

            IF(LUTF14) THEN
            IF(JPMOCT.EQ.1) THEN
               ISGTYP=1
            ELSE
               ISGTYP=3
            ENDIF
               CALL U14OUT(ZWINDX,JPMG,JPJGG,JPMG,ISGTYP,1,1,ILVTYP,
     -               1,0,ZARSTD,JPNHEM,YONAMU,50,NCUTF,NASCII,
     -               IFAIL,PDAY1,PDAY2,ZWINDX,ZWINDX,' ',' ',1,1,
     -               ITFLAG,ZUTF14)
               CALL U14OUT(ZWINDY,JPMG,JPJGG,JPMG,ISGTYP,1,2,ILVTYP,
     -               0,0,ZARSTD,JPNHEM,YONAMV,50,NCUTF,NASCII,
     -               IFAIL,PDAY1,PDAY2,ZWINDY,ZWINDY,' ',' ',1,1,
     -               ITFLAG,ZUTF14)
            ENDIF
         ENDIF
200      CONTINUE

         IF(PDAY1.GE.PDAY2) THEN
            WRITE(6,6020)PDAY1
6020        FORMAT(1X,'LAT-LONG WIND VECTORS PROCESSED FOR DAY',F10.2)
         ELSE
            WRITE(6,6030)PDAY1,PDAY2
6030        FORMAT(1X,'LAT-LONG WIND VECTORS PROCESSED FOR DAYS ',
     -            F10.2,' - ',F10.2)
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE TIMACC
**    Function - to perform step-by-step accumulations of gridpoint
**          fields prior to the calculation of the time-averages
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGP,NCGPAC,/COMAVG/NAVTYP,/COMNGP/NR1ALM,
**          NR1TH,NRMSK2,NRMSK3,/COMDAT/YTYPSF,/CURSGF/all elements,
**          /CURSGH/all elements,/CURSGS/all elements
**    Com changed - /SPECTR/VO...SPAD,/CWORK/WORKM,WGP2D1,WORK3D,
**          /ACCSGF/all elements,/ACCSGH/all elements,/ACCSGS/all
**          elements
**    Params used - /PARAM1/JPJG,JPNL,JPNHEM,/PARAM2/JPIGC,JPIGD,JPNLP,
**          JPMGPP,/PARAM3/JPGP3D,JPGPSF,JPGPHL
**    Called by - SGCALC,TRTACC
**    Calls - none
**    Files read - NCGP(1),NCGP(2),NCGPAC(1),NCGPAC(2),NCGP(3),
**         NCGPAC(3)
**    Files written - NCGPAC(1),NCGPAC(2),NCGPAC(3)
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      DIMENSION ZT(JPMGPP,JPNHEM,JPNL,JPJG),ZST(JPMGPP,JPNHEM,JPJG),
     -      ZHT(JPMGPP,JPNHEM,JPNLP,JPJG)
      DIMENSION ZG(JPMGPP,JPNHEM,JPNL),ZSG(JPMGPP,JPNHEM),
     -      ZHG(JPMGPP,JPNHEM,JPNLP)
      EQUIVALENCE (ZG(1,1,1),WORKM(1,1)),(ZSG(1,1),WGP2D1(1,1)),
     -      (ZHG(1,1,1),WORKM(1,1))
      EQUIVALENCE (ZT(1,1,1,1),VO(1)),(ZST(1,1,1),VO(1)),
     -      (ZHT(1,1,1,1),VO(1))
      DIMENSION ZMASK(JPMGPP,JPNHEM,JPNL,JPJG)
      EQUIVALENCE (ZMASK(1,1,1,1),WORK3D(1))
      LOGICAL LOMULT

**    Read accumulated data values from NCGPAC, read current gridpoint
**    values from NCGP, sum the two arrays together, and write out to
**    NCGPAC. Use masks, if required by the value of NAVTYP.

**    Surface fields
      DO 400 J=1,JPGPSF
      READ(NCGPAC(2),REC=J) ZST
      DO 410 JR=1,JPJG
      READ(NCGP(2),REC=JR+(J-1)*JPJG) ZSG
      IF(JPNHEM.EQ.1) THEN
         DO 450 JI=1,JPMG
         ZST(JI,1,JR)=ZST(JI,1,JR)+ZSG(JI,1)
450      CONTINUE
      ELSE
         DO 455 JI=1,JPMG
         ZST(JI,1,JR)=ZST(JI,1,JR)+ZSG(JI,1)
         ZST(JI,2,JR)=ZST(JI,2,JR)+ZSG(JI,2)
455      CONTINUE
      ENDIF
410   CONTINUE
      WRITE(NCGPAC(2),REC=J) ZST
400   CONTINUE

      READ(NCGPAC(2),REC=JPGPSF+1)ITIME
      ITIME=ITIME+1
      WRITE(NCGPAC(2),REC=JPGPSF+1)ITIME

**    3D (JPNLP level) half-level fields on model half levels
      DO 500 J=1,JPGPHL
      READ(NCGPAC(3),REC=J) ZHT
      DO 510 JR=1,JPJG
      READ(NCGP(3),REC=JR+(J-1)*JPJG) ZHG
      IF(JPNHEM.EQ.1) THEN
         DO 550 JL=1,JPNLP
         DO 550 JI=1,JPMG
         ZHT(JI,1,JL,JR)=ZHT(JI,1,JL,JR)+ZHG(JI,1,JL)
550      CONTINUE
      ELSE
         DO 555 JL=1,JPNLP
         DO 555 JI=1,JPMG
         ZHT(JI,1,JL,JR)=ZHT(JI,1,JL,JR)+ZHG(JI,1,JL)
         ZHT(JI,2,JL,JR)=ZHT(JI,2,JL,JR)+ZHG(JI,2,JL)
555      CONTINUE
      ENDIF
510   CONTINUE
      WRITE(NCGPAC(3),REC=J) ZHT
500   CONTINUE

      READ(NCGPAC(3),REC=JPGPHL+1)ITIME
      ITIME=ITIME+1
      WRITE(NCGPAC(3),REC=JPGPHL+1)ITIME

**    3D (JPNL level) fields

      IF(NAVTYP.EQ.2) THEN
**       Read land/air mask
         DO 1000 J=1,JPJG
         READ(NCGP(1),REC=NR1ALM+J-1) (((ZMASK(JI,JH,JK,J),
     -         JI=1,JPMGPP),JH=1,JPNHEM),JK=1,JPNL)
1000     CONTINUE
      ELSE IF(NAVTYP.EQ.3) THEN
**       Read sigma mask
         DO 1010 J=1,JPJG
         READ(NCGP(1),REC=NR1TH+J-1) (((ZMASK(JI,JH,JK,J),
     -         JI=1,JPMGPP),JH=1,JPNHEM),JK=1,JPNL)
1010     CONTINUE
      ENDIF

      DO 300 J=1,JPGP3D

**    Ensure that mask fields are not, themselves, weighted; their
**    gridpoint summations over time are required by TIMAVG.
      IF(NAVTYP.EQ.1) THEN
         LOMULT=.FALSE.
      ELSE
         LOMULT=.TRUE.
         IF(J.EQ.NRMSK2) LOMULT=.FALSE.
         IF(J.EQ.NRMSK3.AND.YTYPSF.EQ.'TH') LOMULT=.FALSE.
      ENDIF

      READ(NCGPAC(1),REC=J) ZT
      DO 310 JR=1,JPJG
      READ(NCGP(1),REC=JR+(J-1)*JPJG) ZG
      IF(JPNHEM.EQ.1) THEN
         IF(LOMULT) THEN
            DO 1100 JK=1,JPNL
            DO 1100 JI=1,JPMG
            ZG(JI,1,JK)=ZG(JI,1,JK)*ZMASK(JI,1,JK,JR)
1100        CONTINUE
         ENDIF
         DO 350 JL=1,JPNL
         DO 350 JI=1,JPMG
         ZT(JI,1,JL,JR)=ZT(JI,1,JL,JR)+ZG(JI,1,JL)
350      CONTINUE
      ELSE
         IF(LOMULT) THEN
            DO 1110 JK=1,JPNL
            DO 1110 JI=1,JPMG
            ZG(JI,1,JK)=ZG(JI,1,JK)*ZMASK(JI,1,JK,JR)
            ZG(JI,2,JK)=ZG(JI,2,JK)*ZMASK(JI,2,JK,JR)
1110        CONTINUE
         ENDIF
         DO 355 JL=1,JPNL
         DO 355 JI=1,JPMG
         ZT(JI,1,JL,JR)=ZT(JI,1,JL,JR)+ZG(JI,1,JL)
         ZT(JI,2,JL,JR)=ZT(JI,2,JL,JR)+ZG(JI,2,JL)
355      CONTINUE
      ENDIF
310   CONTINUE
      WRITE(NCGPAC(1),REC=J) ZT
300   CONTINUE

      READ(NCGPAC(1),REC=JPGP3D+1)ITIME
      ITIME=ITIME+1
      WRITE(NCGPAC(1),REC=JPGP3D+1)ITIME

      RETURN
      END
      SUBROUTINE TIMAVG
**    Function - to calculate gridpoint field time averages from the
**          step-by-step accumulated values.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGPAC,NCGP,NCGPAV,/COMAVG/NAVTYP,/COMNGP/
**          NR1ALM,NRMSK2,NRMSK3,/COMDAT/YTYPSF,/COMMSK/AMSKV,
**          /ACCSGF/all elements,/ACCSGH/all elements,/ACCSGS/all
**          elements
**    Com changed - /SPECTR/VO...SPAD,/CWORK/WORK3D,
**          /CURSGH/all elements,/CURSGS/all elements,
**          /CURSGF/all elements
**    Params used - /PARAM1/JPJG,JPNL,/PARAM2/JPIGC,JPIGD,JPNLP,
**          JPMGPP,/PARAM3/JPGP3D,JPGPSF,JPGPHL
**    Called by - ENDSG,TRTAVG
**    Calls - none
**    Files read - NCGPAC(1),NCGPAC(2),NCGPAC(3)
**    Files written - NCGPAV(1),NCGPAV(2),NCGPAV(3)
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      DIMENSION ZT(JPMGPP*JPNHEM*JPNL,JPJG),ZST(JPMGPP*JPNHEM,JPJG),
     -      ZHT(JPMGPP*JPNHEM*JPNLP,JPJG)
      EQUIVALENCE (ZT(1,1),VO(1)),(ZST(1,1),VO(1)),
     -      (ZHT(1,1),VO(1))
      DIMENSION ZDENOM(JPMGPP*JPNHEM*JPNL,JPJG)
      EQUIVALENCE (ZDENOM(1,1),WORK3D(1))
      LOGICAL LOMEAN

**    Read accumulated data values from NCGPAC, and divide by the number
**    of samples. Make use of masks if required by NAVTYP.

**    Surface fields
      READ(NCGPAC(2),REC=JPGPSF+1)ITIME
      RITIME=1.0/FLOAT(ITIME)

      JREC=0
      DO 400 J=1,JPGPSF
      READ(NCGPAC(2),REC=J) ZST
      DO 450 JJ=1,JPJG
      DO 450 JI=1,JPNHEM*JPMGPP
      ZST(JI,JJ)=ZST(JI,JJ)*RITIME
450   CONTINUE
      DO 460 JJ=1,JPJG
      JREC=JREC+1
      WRITE(NCGPAV(2),REC=JREC) (ZST(JI,JJ),JI=1,JPNHEM*JPMGPP)
460   CONTINUE
400   CONTINUE

**    3D (JPNLP level) half-level fields on model half levels
      READ(NCGPAC(3),REC=JPGPHL+1)ITIME
      RITIME=1.0/FLOAT(ITIME)

      JREC=0
      DO 500 J=1,JPGPHL
      READ(NCGPAC(3),REC=J) ZHT
      DO 550 JJ=1,JPJG
      DO 550 JI=1,JPNLP*JPNHEM*JPMGPP
      ZHT(JI,JJ)=ZHT(JI,JJ)*RITIME
550   CONTINUE
      DO 560 JJ=1,JPJG
      JREC=JREC+1
      WRITE(NCGPAV(3),REC=JREC) (ZHT(JI,JJ),JI=1,JPNLP*JPNHEM*JPMGPP)
560   CONTINUE
500   CONTINUE

**    3D (JPNL level) fields
      IF(NAVTYP.EQ.2) THEN
**       Fill ZDENOM with denominator (land/air) weighting function
         READ(NCGPAC(1),REC=NRMSK2)ZDENOM
      ELSE IF(NAVTYP.EQ.3) THEN
**       Fill ZDENOM with denominator (sigma) weighting function
         READ(NCGPAC(1),REC=NRMSK3)ZDENOM
      ENDIF
      READ(NCGPAC(1),REC=JPGP3D+1)ITIME
      RITIME=1.0/FLOAT(ITIME)

      JREC=0
      DO 300 J=1,JPGP3D

**    If NAVTYP=1, or if the current field is a mask or sigma field,
**    then the average is simply the arithmetic mean (LOMEAN=.TRUE.).
      IF(NAVTYP.EQ.1) THEN
         LOMEAN=.TRUE.
      ELSE
         LOMEAN=.FALSE.
         IF(J.EQ.NRMSK2) LOMEAN=.TRUE.
         IF(J.EQ.NRMSK3.AND.YTYPSF.EQ.'TH') LOMEAN=.TRUE.
      ENDIF

      READ(NCGPAC(1),REC=J) ZT
      IF(LOMEAN) THEN
         DO 350 JJ=1,JPJG
         DO 350 JI=1,JPNL*JPNHEM*JPMGPP
         ZT(JI,JJ)=ZT(JI,JJ)*RITIME
350      CONTINUE
      ELSE
         DO 1350 JJ=1,JPJG
         DO 1350 JI=1,JPNL*JPNHEM*JPMGPP
         IF(ZDENOM(JI,JJ).EQ.0.0) THEN
            ZT(JI,JJ)=AMSKV
         ELSE
            ZT(JI,JJ)=ZT(JI,JJ)/ZDENOM(JI,JJ)
         ENDIF
1350     CONTINUE
      ENDIF
      DO 360 JJ=1,JPJG
      JREC=JREC+1
      WRITE(NCGPAV(1),REC=JREC) (ZT(JI,JJ),JI=1,JPNL*JPNHEM*JPMGPP)
360   CONTINUE
300   CONTINUE

      RETURN
      END
      SUBROUTINE TIMINI
**    Function - to initialise SG scratch file/common blocks for
**          time-average calculations
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGPAC
**    Com changed - /CWORK/WGP2D1,/SPECTR/VO...SPAD,
**          /ACCSGF/all elements,/ACCSGH/all elements,/ACCSGS/all
**          elements
**    Params used - /PARAM1/JPJG,/PARAM2/JPIGC,JPIGD,JPNLP,
**          /PARAM3/JPGPSF,JPGP3D,JPGPHL
**    Called by - SGINIT,TRINIT
**    Calls - none
**    Files read - none
**    Files written - NCGPAC(1),NCGPAC(2),NCGPAC(3)
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      DIMENSION Z(JPIGD*JPJG),ZS(JPIGC*JPJG),ZH(JPIGC*JPNLP*JPJG)
      EQUIVALENCE (Z(1),VO(1)),(ZS(1),WGP2D1(1,1)),
     -      (ZH(1),VO(1))

**    Fill ZH and Z1 with zeroes
      DO 100 J=1,JPIGC*JPJG
      ZS(J)=0.0
100   CONTINUE
      DO 200 J=1,JPIGC*JPNLP*JPJG
      ZH(J)=0.0
200   CONTINUE
**    Since ZH is equivalenced to Z, Z is automatically filled with
**    zeroes

**    ITIME is a counter denoting number of timesteps for which data
**    in NCGPAC has been summed
      ITIME=0

      DO 300 JREC=1,JPGP3D
      WRITE(NCGPAC(1),REC=JREC)Z
300   CONTINUE
      WRITE(NCGPAC(1),REC=JPGP3D+1)ITIME

      DO 400 JREC=1,JPGPSF
      WRITE(NCGPAC(2),REC=JREC)ZS
400   CONTINUE
      WRITE(NCGPAC(2),REC=JPGPSF+1)ITIME

      DO 500 JREC=1,JPGPHL
      WRITE(NCGPAC(3),REC=JREC)ZH
500   CONTINUE
      WRITE(NCGPAC(3),REC=JPGPHL+1)ITIME

      RETURN
      END
      SUBROUTINE WRITSG(LP1,LP2,LP3,LP4,LP5,KLAT)
**    Function - to write gridpoint arrays (at the current latitude)
**          to scratch
**    Args in -
**               LP1     - .TRUE. if streamfunction to be output
**               LP2     - .TRUE. if velocity potential to be output
**               LP3     - .TRUE. iF vorticity to be output
**               LP4     - .TRUE. if divergence to be output
**               LP5     - .TRUE. if remaining gridpoint fields to be
**                         output
**               KLAT    - Latitude counter
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCGP,/GRIDP/SFG,CHIG,VOG,DG,OMG,UG,VG,
**          TG,QG,HG,APG,THG,EPVG,FUG,FVG,APSFCG,APMSLG,APJG,APMG,
**          AIRG,AMSFG,THSFCG,/COMPRL/APSGH
**          /COMNGP/NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,NR1U,NR1V,
**          NR1T,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,NR1FV,NR1PSF,
**          NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1ALM,NR1THS
**    Com changed - none
**    Params used - /PARAM2/JPIGC,JPIGD,JPNLP,/PARAM3/JPTRMX,JPGP3D,
**          JPGPHL,JPGPSF
**    Called by - SGFLUX,SFCHG,SFCHDV
**    Calls - CURWRT
**    Files read - none
**    Files written - NCGP(1),NCGP(2),NCGP(3)
**    Author - R Brugge, University of Reading (SMAP version)

      LOGICAL LP1,LP2,LP3,LP4,LP5
      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)

**    Write streamfunction to scratch file
      IF(LP1) THEN
         WRITE(NCGP(1),REC=NR1SF+KLAT-1)SFG
      ENDIF

**    Write velocity potential to scratch file
      IF(LP2) THEN
         WRITE(NCGP(1),REC=NR1CHI+KLAT-1)CHIG
      ENDIF

**    Write vorticity to scratch file
      IF(LP3) THEN
         WRITE(NCGP(1),REC=NR1VO+KLAT-1)VOG
      ENDIF

**    Write divergence to scratch file
      IF(LP4) THEN
         WRITE(NCGP(1),REC=NR1D+KLAT-1)DG
      ENDIF

**    Write other fields in /GRIDP/ and /COMPRL/ to scratch files
      IF(LP5) THEN
         WRITE(NCGP(1),REC=NR1OM+KLAT-1)OMG
         WRITE(NCGP(1),REC=NR1U+KLAT-1)UG
         WRITE(NCGP(1),REC=NR1V+KLAT-1)VG
         WRITE(NCGP(1),REC=NR1T+KLAT-1)TG
         WRITE(NCGP(1),REC=NR1GH+KLAT-1)GHG
         WRITE(NCGP(1),REC=NR1Q+KLAT-1)QG
         WRITE(NCGP(1),REC=NR1H+KLAT-1)HG
         WRITE(NCGP(1),REC=NR1AP+KLAT-1)APG
         WRITE(NCGP(1),REC=NR1TH+KLAT-1)THG
         WRITE(NCGP(1),REC=NR1EPV+KLAT-1)EPVG
         WRITE(NCGP(1),REC=NR1FU+KLAT-1)FUG
         WRITE(NCGP(1),REC=NR1FV+KLAT-1)FVG
         WRITE(NCGP(1),REC=NR1MSF+KLAT-1)AMSFG
         WRITE(NCGP(1),REC=NR1ALM+KLAT-1)AIRG

C     write(4,*)'field immediately prior to o/p to disk'
C     write(4,*)apsfcg(1)
C     write(4,*)'nr1psf,klat,ncgp(2)'
C     write(4,*)nr1psf,klat,ncgp(2)

         WRITE(NCGP(2),REC=NR1PSF+KLAT-1)APSFCG

         WRITE(NCGP(2),REC=NR1PSL+KLAT-1)APMSLG
         WRITE(NCGP(2),REC=NR1APJ+KLAT-1)APJG
         WRITE(NCGP(2),REC=NR1APM+KLAT-1)APMG
         WRITE(NCGP(2),REC=NR1THS+KLAT-1)THSFCG

         WRITE(NCGP(3),REC=NR1PHL+KLAT-1)APSGH
      ENDIF

      RETURN
      END
      SUBROUTINE INIMSK(KCHAN,KSTEP1,KSTEP2,PDAY1,PDAY2)
**    Function - Initialise orographic mask fields for current analysis
**          time
**    Args in -
**               KCHAN   - Channel containing surface pressure data; a
**                         value of -999 indiactes that the data can
**                         be found in /CURSGS/
**               KSTEP1  - Current time step number, used to timemark
**                         the orographic masks
**               KSTEP2  - Second of a range of time step numbers, used
**                         to timemark the orographic masks.
**               PDAY1   - Day number of the diagnostics, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**    Args out - none
**    Args for work - none
**    Com used - /COMNGP/NR1PSF,/ORDIAG/LMSKH,LMSKNS,LMSKWE,/CURSGS/
**          all elements
**    Com changed - /COMMSK/all elements
**    Params used - /PARAM1/JPMG,JPJG,JPNHEM,/PARAM2/JPJGG,/PARAM3/
**          JPTRMX
**    Called by - ANALYS,ENDSG,ENDTR
**    Calls - ZMEAN3,MERMN3,ABORT
**    Files read - KCHAN
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LOINST
      DIMENSION ZDUM(2)
      DIMENSION ZPZMIN(JPJGG),ZPZAV(JPJGG)
      DIMENSION ZPMMIN(JPMG),ZPMAV(JPMG)
      EQUIVALENCE (ZPZMIN(1),AZMSK(1,1)),(ZPZAV(1),AZMSK(1,2))
      EQUIVALENCE (ZPMMIN(1),AMMSK(1,1)),(ZPMAV(1),AMMSK(1,2))
**    Default values set in case routine never called
      DATA NFLGZM/-999,-999/,NFLGLL/-999,-999/,
     -      NFLGMM/-999,-999/

      IF((.NOT.LMSKNS).OR.(.NOT.LMSKWE).OR.(.NOT.LMSKH)) RETURN

**    Preset full surface pressure mask array to zero.
      DO 10 J=1,JPJGG
      DO 10 JI=1,JPMG
10    APHMSK(JI,J)=0.0

**    Set default timemark flags
      NFLGZM(1)=-999
      NFLGZM(2)=-999
      NFLGMM(1)=-999
      NFLGMM(2)=-999
      IF(PDAY1.GT.PDAY2) THEN
         LOINST=.TRUE.
      ELSE
         LOINST=.FALSE.
      ENDIF

**    Copy surface pressure field directly into lat-long mask array.
      IF(KCHAN.LE.0) THEN
         WRITE(6,6000)KCHAN
6000     FORMAT(1X,'INIMSK ERROR: KCHAN IS AN INVALID CHANNEL ',
     -         'NUMBER :',I5, ' ; ABORT CALLED')
         CALL ABORT
      ENDIF
      INIREC=NR1PSF
      DO 1100 J=1,JPJG
      IF(JPNHEM.EQ.1) THEN
         READ(KCHAN,REC=INIREC-1+J)(APHMSK(I,J),I=1,JPMG)
      ELSE
         ILATS=JPJGG+1-J
         READ(KCHAN,REC=INIREC-1+J)(APHMSK(I,J),I=1,JPMG),
     -         ZDUM,(APHMSK(I,ILATS),I=1,JPMG)
      ENDIF
1100  CONTINUE

**    Convert from Pascals to millibars
      DO 1200 J=1,JPJGG
      DO 1200 JI=1,JPMG
      APHMSK(JI,J)=0.01*APHMSK(JI,J)
1200  CONTINUE
      NFLGLL(1)=KSTEP1
      NFLGLL(2)=KSTEP2
      IF(KSTEP2.LT.KSTEP1) NFLGLL(2)=-999
      YMNAMH='LAT-LONG SURFACE PRESSURE                         '
      IF(PDAY2.LT.PDAY1) THEN
         WRITE(YMNAMH(36:42),'(F7.1)')PDAY1
      ELSE
         WRITE(YMNAMH(36:42),'(F7.1,''-'',F7.1)')PDAY1,PDAY2
      ENDIF

**    Compute AZMSK and AMMSK arrays for use with masks on zonal- and
**    meridional-mean fields
      IF(LMSKNS) THEN
         CALL ZMEAN3(APHMSK,JPMG,JPJGG,1,ZPZAV,JPMG,'S',LOINST)
         DO 2000 J=1,JPJGG
         IM=ISMIN(JPMG,APHMSK(1,J),1)
         ZPZMIN(J)=APHMSK(IM,J)
2000     CONTINUE
         NFLGZM(1)=KSTEP1
         NFLGZM(2)=KSTEP2
         IF(KSTEP2.LT.KSTEP1) NFLGZM(2)=-999
         YMNAMZ='ZONAL MEAN, MIN AND AV PRESSURE                   '
         IF(PDAY2.LT.PDAY1) THEN
            WRITE(YMNAMZ(36:42),'(F7.1)')PDAY1
         ELSE
            WRITE(YMNAMZ(36:42),'(F7.1,''-'',F7.1)')PDAY1,PDAY2
         ENDIF
      ENDIF

      IF(LMSKWE) THEN
         CALL MERMN3(APHMSK,JPMG,JPJGG,1,ZPMAV,JPMG,'S',LOINST)
         DO 2100 JI=1,JPMG
         ZPMMIN(JI)=APHMSK(JI,1)
         DO 2200 J=2,JPJGG
2200     ZPMMIN(JI)=AMIN1(ZPMMIN(JI),APHMSK(JI,J))
2100     CONTINUE
         NFLGMM(1)=KSTEP1
         NFLGMM(2)=KSTEP2
         IF(KSTEP2.LT.KSTEP1) NFLGMM(2)=-999
         YMNAMM='MERID MEAN, MIN AND AV PRESSURE                   '
         IF(PDAY2.LT.PDAY1) THEN
            WRITE(YMNAMM(36:42),'(F7.1)')PDAY1
         ELSE
            WRITE(YMNAMM(36:42),'(F7.1,''-'',F7.1)')PDAY1,PDAY2
         ENDIF
      ENDIF


      RETURN
      END
      SUBROUTINE MSKPL(YPTYPE,KSTEP1,KSTEP2,PDAY1,PDAY2)
**    Function - to output horizontal level, zonal-mean and meridional
**          mean orographic masks to the UTF file
**    Args in -
**               YPTYPE  - Character variable defining orographic mask
**                         to be output; allowed values are 'H', 'ZM'
**                         and 'MM'
**               KSTEP1  - Current time step number, or first of a range
**                         of step numbers if the masks refer to
**                         time-averages
**               KSTEP2  - Second of a range of time step numbers; if
**                         less than KSTEP1 it is assumed that the masks
**                         are instantaneous values
**               PDAY1   - Current day number, or the first
**                         of a sequence of days if PDAY2 > PDAY1
**               PDAY2   - Last day number of a sequence of days; must
**                         satisfy PDAY1 > PDAY2 for instantaneous
**                         fields
**    Args out - none
**    Args for work - none
**    Com used - /COMMSK/all elements,/COMDAT/NASCII,LUTF14,
**          /ORDIAG/CINTOR,/SGDIAG/NCSG,/COMIOC/NCUTF,
**    Com changed - /CWORK/WGP2D1
**    Params used - /PARAM1/JPMG,JPJG,JPNHEM,/PARAM2/JPMGP,JPJGGP
**    Called by - SGINST,OPSG,OPTR,TRINST
**    Calls - U14OUT,ZSECTE,ZSECTN
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (SMAP version)

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LROGPR,LROGPL,LMSKH,LMSKNS,LMSKWE
      COMMON /ORDIAG/LROGPR,LROGPL,CINTOR,LMSKH,LMSKNS,LMSKWE
      LOGICAL LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN
      COMMON /SGDIAG/LDGH,LDGZ,LDGM,LDGP,LDG3,LDSGTD,LDSGTS,LDSGIN,
     -      NCSG,NVSGHR(JPNL),VSGSFC(JPNL)
      CHARACTER*(*) YPTYPE
      DIMENSION ZUTF14(JPMG,JPJGG)
      EQUIVALENCE (ZUTF14(1,1),WGP2D1(1,1))

      IF(PDAY1.GT.PDAY2) THEN
         ITFLAG=0
      ELSE
         ITFLAG=1
      ENDIF

      IF(YPTYPE.EQ.'H') THEN
**       Check that field exists for current time
         IF((NFLGLL(1).NE.KSTEP1).AND.(NFLGLL(2).NE.KSTEP2)) THEN
            WRITE(6,6000)KSTEP1,KSTEP2,NFLGLL
6000        FORMAT(1X,'***MSKPL : LAT-LONG MASK NOT OUTPUT',
     -            ' STEP COUNTERS = ',4I10)
            RETURN
         ENDIF
         IF(LUTF14) THEN
            CALL U14OUT(APHMSK,JPMG,JPJGG,JPMG,1,0,3,2,1,1,
     -           CINTOR,JPNHEM,YMNAMH,50,NCUTF,NASCII,IFAIL,PDAY1,
     -           PDAY2,APHMSK,APHMSK,' ',' ',1,1,ITFLAG,
     -           ZUTF14)
         ENDIF
      ENDIF

      IF(YPTYPE.EQ.'ZM') THEN
**       Check that field exists for current time
         IF((NFLGZM(1).NE.KSTEP1).AND.(NFLGZM(2).NE.KSTEP2)) THEN
            WRITE(6,6010)KSTEP1,KSTEP2,NFLGZM
6010        FORMAT(1X,'***MSKPL : ZONAL MEAN MASK NOT OUTPUT',
     -            ' STEP COUNTERS = ',4I10)
            RETURN
         ENDIF
         CALL ZSECTE(AZMSK,JPJGG,2,YMNAMZ,0.0,1,50,1,1,NCSG,1,1,1,1,
     -         PDAY1,PDAY2,CINTOR,.FALSE.,.TRUE.,1,0,0.0,0,ITFLAG,
     -         11,1,4,2,AZMSK,AZMSK,' ',' ',1,1)
      ENDIF

      IF(YPTYPE.EQ.'MM') THEN
**       Check that field exists for current time
         IF((NFLGMM(1).NE.KSTEP1).AND.(NFLGMM(2).NE.KSTEP2)) THEN
            WRITE(6,6020)KSTEP1,KSTEP2,NFLGMM
6020        FORMAT(1X,'***MSKPL : MERIDIONAL MEAN MASK NOT OUTPUT',
     -            ' STEP COUNTERS = ',4I10)
            RETURN
         ENDIF
         CALL ZSECTN(AMMSK,JPMG,2,YMNAMM,0.0,1,50,1,1,NCSG,1,1,1,1,
     -         PDAY1,PDAY2,CINTOR,.FALSE.,.TRUE.,1,0,0.0,0,ITFLAG,
     -         12,1,4,2,AMMSK,AMMSK,' ',' ',1,1)
      ENDIF

      RETURN
      END
      FUNCTION ADD0(PDUM1,PDUM2,PDUM3,PDUM4,KDUM)
**    Function - a 'do nothing' routine to replace ADD1 or ADD2
**    Args in -
**               PDUM1   - Dummy argument
**               PDUM2   - Dummy argument
**               PDUM3   - Dummy argument
**               PDUM4   - Dummy argument
**               KDUM    - Dummy argument
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - TFSUMM,TFLAT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      ADD0=0.0

      RETURN
      END
      FUNCTION ADD1(PFACT,PFLD,PDUMMY,PSUM,KDIM)
**    Function - to increment array elements PSUM(j) by the quantity
**          PFACT*PFLD(j), where PFACT is a constant for all elements j.
**    Args in -
**               PFACT   - Real constant
**               PFLD    - Real array
**               PDUMMY  - Dummy array not used
**               PSUM    - Real summation array before increment is
**                         applied
**               KDIM    - Dimension of PFLD and PSUM
**    Args out -
**               PSUM    - Real summation array after increment is
**                         applied
**               ADD1    - 0.0 indicates successful completion
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPIGC,JPMGPP,JPIGD
**    Called by - TFSUMM,TFLAT
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      DIMENSION PSUM(KDIM),PFLD(KDIM),PDUMMY(KDIM)

**    Check dimensions
      IF(JPIGD.NE.KDIM) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***ADD1 ERROR - INVALID DIMENSION, ABORT CALLED')
         CALL ABORT
      ENDIF

      DO 100 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 100 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 100 JI=1,JPMG
      J=JI+IOFL+IOF
      PSUM(J)=PSUM(J)+PFACT*PFLD(J)
100   CONTINUE
      ADD1=1.0

      RETURN
      END
      FUNCTION ADD2(PFACT,PFLD1,PFLD2,PSUM,KDIM)
**    Function - to increment array elements PSUM(j) by the quantity
**          PFACT*PFLD1(j)*PFLD2(j), where PFACT is a constant for all
**          elements j.
**    Args in -
**               PFACT   - Real constant
**               PFLD1   - Real array
**               PFLD2   - Real array
**               PSUM    - Real summation array before increment is
**                         applied
**               KDIM    - Dimension of PFLD1, PFLD2 and PSUM
**    Args out -
**               PSUM    - Real summation array after increment is
**                         applied
**               ADD2    - 0.0 indicates successful completion
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPIGC,JPMGPP,JPIGD
**    Called by - TFSUMM,TFLAT
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      DIMENSION PSUM(KDIM),PFLD1(KDIM),PFLD2(KDIM)

**    Check dimensions
      IF(JPIGD.NE.KDIM) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***ADD2 ERROR - INVALID DIMENSION, ABORT CALLED')
         CALL ABORT
      ENDIF

      DO 100 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 100 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 100 JI=1,JPMG
      J=JI+IOFL+IOF
      PSUM(J)=PSUM(J)+PFACT*PFLD1(J)*PFLD2(J)
100   CONTINUE
      ADD2=2.0

      RETURN
      END
      SUBROUTINE ENDTF
**    Function - To control the output of transient fluxes at the end of
**          the diagnostic job
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - ENDOP
**    Calls - TFMEAN,OPTF
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

**    Compute transient fluxes
      CALL TFMEAN

**    Output required transient flux slices, etc.
      CALL OPTF

      RETURN
      END
      SUBROUTINE F3OUT(KF,KPASS,PX,KLEV)
**    Function - to copy user-selected 3D TF fields to an output
**          file. The user should alter the code in this routine if (for
**          example) a different output format is required, or if a
**          subset of each field is required.
**    Args in -
**               KF      - Field number
**               KPASS   - 1: total flux
**          /COMTIM/NSDATE,NEDATE,/COMARS/LECANL,/TFCNST/YNAMTF,
**                         3: low pass flux
**               PX      - Array containing data in MKS units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**    Args out - none
**    Args for work - none
**    Com used - /TFCNST/YNAMTF,
**          /LVDIAG/SFCOUT,/COMDAT/YTYPSF,BEGDAY,ENDDAY
**    Com changed - /F3DIAG/NCF3
**    Params used - /PARAM1/JPMG,JPNL,JPJG,JPNHEM,/PARAM2/JPJGG,
**          /PARAM3/JPTFMX
**    Called by - OPTF
**    Calls - none
**    Files read - none
**    Files written - NCF3
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /F3DIAG/NCF3,NF3PL(JPTFMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      CHARACTER*50 YONAME,YOTIME
      DIMENSION PX(JPMG,JPJGG,JPNL)

**    The following code writes the fields to NCF3 with the following
**    structure:
**    Record 1: number of records containing level values (=IRECLV) and
**              number of data records (=IRECDT), in the format 2I10.
**    Record 2: character*50 field title
**    Record 3: character*50 time description
**    Record 4: array dimensions (JPMG,JPNHEM,JPNL,JPJG) in format 4I10
**    Record 5: vertical model level type in format character*2
**    Records 6 to IRECLV+5 : vertical level values in format 8E10.3 (a
**              value of -999E30 corresponds to the surface)
**    Records IRECLV+6 to IRECLV+IRECDT+5 : array values in format
**              8E10.3
**    Note that only JPMG values per latitude are written out.

      IRECLV=KLEV/8
      IF(IRECLV*8.LT.KLEV)IRECLV=IRECLV+1

      IRECDT=(JPMG*JPNHEM*JPJG*KLEV)/8
      IF(IRECDT*8.LT.JPMG*JPNHEM*JPJG*KLEV)IRECDT=IRECDT+1
      YONAME=YNAMTF(KPASS,KF)
      YONAME(28:28)='('
      YONAME(29:30)=YTYPSF
      YONAME(31:31)=')'
      WRITE(YOTIME,'(''DAY '',F15.4,'' - DAY '',F15.4,
     -      '' AVERAGE '')')BEGDAY,ENDDAY

**    Write header records
      WRITE(NCF3,6000)IRECLV,IRECDT
6000  FORMAT(2I10)
      WRITE(NCF3,6010)YONAME
6010  FORMAT(A50)
      WRITE(NCF3,6010)YOTIME
      WRITE(NCF3,6020)JPMG,JPNHEM,KLEV,JPJG
6020  FORMAT(4I10)
      WRITE(NCF3,6030)YTYPSF
6030  FORMAT(A2)
      IF(KLEV.EQ.JPNL) THEN
         IF(YTYPSF.EQ.'ET') THEN
            WRITE(NCF3,6040)(FLOAT(JL),JL=1,JPNL)
6040        FORMAT(8E10.3)
         ELSE
            WRITE(NCF3,6040)(SFCOUT(JL),JL=1,JPNL)
         ENDIF
      ELSE IF(KLEV.EQ.1) THEN
         ZSFC=-999E30
         WRITE(NCF3,6040)ZSFC
      ENDIF

**    Write data out to NCF3
      WRITE(NCF3,6040)(((PX(IMG,IJ,ILV),IMG=1,JPMG),
     -      IJ=1,JPJGG),ILV=1,KLEV)

      RETURN
      END
      SUBROUTINE FHOUT(KF,KPASS,PX,KLEV,LPFHPR,LPFHPL)
**    Function - to control TF horizontal surface. One field is
**          handled for each call to this subroutine.
**    Args in -
**               KF      - Number of the TF field to be processed
**               KPASS   - 1: total flux
**                         2: high pass flux
**                         3: low pass flux
**               PX      - Array containing data in MKS units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPFHPR  - .TRUE. if horizontal slices to be printed
**               LPFHPL  - .TRUE. if horizontal slices to be plotted
**    Args out - none
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,NSIGFG,LUTF13,NASCII,BEGDAY,ENDDAY,
**          /TFCNST/YNAMTF,
**          LTFLEV,/TFDIAG/NCTF,TFCUT,/VERTCL/SIGMA,
**          /FHCNST/CIFH,/COMIOC/NCUTF,/LVDIAG/SFCOUT
**    Com changed - /CWORK/WGP2D1,WGP2D3
**    Params used - /PARAM1/JPMG,JPNHEM,JPNL,/PARAM2/JPJGG,JPMGP,
**          JPJGGP,/PARAM3/JPTFMX
**    Called by - OPTF
**    Calls - GLLOUT,U14OUT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDFHPR,LDFHPL
      COMMON /FHCNST/LDFHPR(JPTFMX),LDFHPL(JPTFMX),CIFH(JPTFMX)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      LOGICAL LPFHPR,LPFHPL,LOINST
      DIMENSION PX(JPMG,JPJGG,JPNL),ZUTF13(JPMGP,JPJGGP)
      DIMENSION ZMERID(JPMG),ZUTF14(JPMG,JPJGG)
      DIMENSION ZLONI(JPMGP),ZLONO(JPMGP),ZLATO(JPJGGP)
      EQUIVALENCE (ZMERID(1),WGP2D1(1,1)),
     -      (ZUTF13(1,1),WGP2D3(1,1)),(ZUTF14(1,1),WGP2D3(1,1))
      CHARACTER*50 YONAME
      CHARACTER*1 YOT

      YONAME=YNAMTF(KPASS,KF)
      IF(YTYPSF.EQ.'ET') THEN
         YONAME(28:29)='SI'
         ILVTYP=0
      ELSE IF(YTYPSF.EQ.'IS') THEN
         YONAME(28:29)='IS'
         ILVTYP=2
      ELSE IF(YTYPSF.EQ.'TH') THEN
         YONAME(28:29)='TH'
         ILVTYP=3
      ENDIF
      IF(KPASS.GT.1) THEN
         YONAME(30:32)='CUT'
         IF(TFCUT.LT.10.0) THEN
CHACK
C*****dirty hack: get rid of internal writes
C           WRITE(YONAME(33:35),'(F3.1)')TFCUT
      YONAME(33:35)='3.0'
C***********
         ELSE
            WRITE(YONAME(33:35),'(I3)')NINT(TFCUT)
         ENDIF
      ELSE
         YONAME(30:35)='      '
      ENDIF
 
      ZDAY1=BEGDAY
      ZDAY2=ENDDAY

      IMSK=0
      LOINST=.FALSE.
**    Setting YOT to 'S" will prevent use of masking arrays
      YOT='S'
      ITFLAG=1

      IF((LPFHPR.OR.LPFHPL)) THEN
         DO 1000 JL=1,KLEV
         IF(LTFLEV(JL)) THEN
**          Output the field
            IF(YTYPSF.NE.'ET') THEN
               IF(SFCOUT(JL).GE.10.0) THEN
CHACK
C*****dirty hack: get rid of internal writes
C                 WRITE(YONAME(36:47),'('' ='',F9.1,'' '')')SFCOUT(JL)
      if (jl.eq.1) YONAME(36:47)=' =  5000.00 '
      if (jl.eq.2) YONAME(36:47)=' = 15000.00 '
      if (jl.eq.3) YONAME(36:47)=' = 25000.00 '
      if (jl.eq.4) YONAME(36:47)=' = 35000.00 '
      if (jl.eq.5) YONAME(36:47)=' = 45000.00 '
      if (jl.eq.6) YONAME(36:47)=' = 55000.00 '
      if (jl.eq.7) YONAME(36:47)=' = 65000.00 '
      if (jl.eq.8) YONAME(36:47)=' = 75000.00 '
      if (jl.eq.9) YONAME(36:47)=' = 85000.00 '
      if (jl.eq.10) YONAME(36:47)=' = 95000.00 '
C***********
               ELSE IF(SFCOUT(JL).GT.0.01) THEN
                  WRITE(YONAME(36:47),'('' ='',F9.3,'' '')')SFCOUT(JL)
               ELSE IF(SFCOUT(JL).GT.0.0001) THEN
                  WRITE(YONAME(36:47),'('' ='',F9.5,'' '')')SFCOUT(JL)
               ELSE
                  WRITE(YONAME(36:47),'('' ='',E9.4,'' '')')SFCOUT(JL)
               ENDIF
            ELSE
               IF(SIGMA(JL).LT.0.001) THEN
                  WRITE(YONAME(36:47),'('' ='',E9.3,'' '')')SIGMA(JL)
               ELSE
                  WRITE(YONAME(36:47),'('' ='',F9.6,'' '')')SIGMA(JL)
               ENDIF
            ENDIF
            IF(LPFHPR) CALL GLLOUT(JPMG,JPJGG,PX(1,1,JL),0.0,NSIGFG,
     -            -1,-1,NCTF,1,JPMG,1,JPJGG,YONAME,ZDAY1,ZDAY2)
            IF(LPFHPL) THEN
               IF(LUTF14) THEN
                  CALL U14OUT(PX(1,1,JL),JPMG,JPJGG,JPMG,1,1,0,
     -                  ILVTYP,1,IMSK,CIFH(KF),JPNHEM,YONAME,50,NCUTF,
     -                  NASCII,IFAIL,ZDAY1,ZDAY2,PX(1,1,JL),
     -                  PX(1,1,JL),' ',' ',1,1,ITFLAG,ZUTF14)
               ENDIF
            ENDIF
         ENDIF
1000     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE FMOUT(KF,KPASS,PX,KLEV,LPMMPR,LPMMPL,LPLAPR,
     -            LPLAPL,LPLMPR,LPLMPL)
**    Function - to control meridional TF output. One field is
**          handled for each call to this subroutine.
**    Args in -
**               KF      - Number of the TF field to be processed
**               KPASS   - 1: total flux
**                         2: high pass flux
**                         3: low pass flux
**               PX      - Array containing data in MKS units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPMMPR  - .TRUE. if meridional means to be printed
**               LPMMPL  - .TRUE. if meridional means to be plotted
**               LPLAPR  - .TRUE. for west-east latitude slice
**                         printouts
**               LPLAPL  - .TRUE. for west-east latitude slice plots
**               LPLMPR  - .TRUE. for limited latitude-range 'meridional
**                         mean' printout
**               LPLMPL  - .TRUE. for limited latitude-range 'meridional
**                         mean' plots
**    Args out - none
**    Args for work - none
**    Com used - /TFDIAG/NCTF,TFCUT,/COMDAT/YTYPSF,NSIGFG,BEGDAY,ENDDAY,
**          /FMDIAG/VFMEW,VFMEWA,/TFCNST/YNAMTF,/FMCNST/CIFM,
**          /LEGAU/ALAT,ALATBY,/COMTIM/NSDATE,NEDATE,
**    Com changed - /CWORK/WORKM
**    Params used - /PARAM1/JPMG,JPNL,/PARAM2/JPJGG,JPMGP,JPJGGP,
**          /PARAM3/JPTFMX
**    Called by - OPTF
**    Calls - MERMN3,ZSECTN,WELATR,BOXAVS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDFMPR,LDFMPL
      COMMON /FMCNST/LDFMPR(JPTFMX),LDFMPL(JPTFMX),CIFM(JPTFMX)
      LOGICAL LDFMMM
      COMMON /FMDIAG/LDFMMM,VFMEW,VFMEWA(2),NFMPR(JPTFMX),
     -      NFMPL(JPTFMX),CINTFM(JPTFMX)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      DIMENSION PX(JPMG,JPJGG,JPNL)
      LOGICAL LPMMPR,LPMMPL,LPLAPR,LPLAPL,LPLMPR,LPLMPL,LOINST
      CHARACTER*50 YONAME
      CHARACTER*1 YOT
      DIMENSION ZMERID(JPMG,JPNL),ZLONI(JPMGP),ZLONO(JPMGP),
     -      ZLATO(JPJGGP)
      EQUIVALENCE (ZMERID(1,1),WORKM(1,1))

      YONAME=YNAMTF(KPASS,KF)
      IF(YTYPSF.EQ.'ET') THEN
         YONAME(28:29)='SI'
         ILVTYP=0
      ELSE IF(YTYPSF.EQ.'IS') THEN
         YONAME(28:29)='IS'
         ILVTYP=2
      ELSE IF(YTYPSF.EQ.'TH') THEN
         YONAME(28:29)='TH'
         ILVTYP=3
      ENDIF
      IF(KPASS.GT.1) THEN
         YONAME(30:32)='CUT'
         IF(TFCUT.LT.10.0) THEN
CHACK******
C           WRITE(YONAME(33:35),'(F3.1)')TFCUT
      YONAME(33:35)='3.0'
C***********
         ELSE
            WRITE(YONAME(33:35),'(I3)')NINT(TFCUT)
         ENDIF
      ELSE
         YONAME(30:35)='      '
      ENDIF

      ZDAY1=BEGDAY
      ZDAY2=ENDDAY

      IMSK=0
      LOINST=.FALSE.
**    Setting YOT to 'S" will prevent use of masking arrays
      YOT='S'
      ITFLAG=1

**    Create meridional means
      IF(LPMMPR.OR.LPMMPL) THEN
         CALL MERMN3(PX,JPMG,JPJGG,KLEV,ZMERID,JPMG,YOT,LOINST)
      ENDIF

**    Print out the meridional means, and pass them to the UTF file
      IF(LPMMPR.OR.LPMMPL) THEN
         YONAME(36:47)=' MERID MEAN '
         CALL ZSECTN(ZMERID,JPMG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -         NCTF,1,JPMG,1,JPNL,ZDAY1,ZDAY2,CIFM(KF),LPMMPR,
     -         LPMMPL,1,0,0.0,0,ITFLAG,12,IMSK,0,ILVTYP,ZMERID,
     -         ZMERID,' ',' ',1,1)
      ENDIF

**    Calculate a slice at the single latitude VFMEW; assume
**    d(field)/d(sin(latitude)) is constant
      IF(LPLAPR.OR.LPLAPL) THEN
         CALL WELATR(VFMEW,ALAT,PX,JPMG,JPJGG,KLEV,ZMERID)
CHACK***********
C        WRITE(YONAME(36:47),'('' LAT. '',F5.1,1X)')VFMEW
      YONAME(36:47)=' LAT 40.0   '
C***************


         CALL ZSECTN(ZMERID,JPMG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -         NCTF,1,JPMG,1,JPNL,ZDAY1,ZDAY2,CIFM(KF),LPLAPR,
     -         LPLAPL,1,0,0.0,0,ITFLAG,12,0,0,ILVTYP,ZMERID,
     -         ZMERID,' ',' ',1,1)
      ENDIF

**    West-east slice of area-averaged values between two specified
**          latitudes (VFMEWA(1) and VFMEWA(2))
      IF(LPLMPR.OR.LPLMPL) THEN
         DO 1000 JL=1,KLEV
         CALL BOXAVS(1,ZLONI,JPMG,ZLONO,0.0,360.0,ZLATO,
     -         ALATBY,JPJGG,VFMEWA(1),VFMEWA(2),PX(1,1,JL),
     -         ZMERID(1,JL),JPMG,.FALSE.)
1000     CONTINUE
         WRITE(YONAME(36:47),'(''AV'',I4,''/'',I4,''N'')')
     -         NINT(VFMEWA(1)),NINT(VFMEWA(2))
         CALL ZSECTN(ZMERID,JPMG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -         NCTF,1,JPMG,1,JPNL,ZDAY1,ZDAY2,CIFM(KF),LPLMPR,
     -         LPLMPL,1,0,0.0,0,ITFLAG,12,0,0,ILVTYP,ZMERID,
     -         ZMERID,' ',' ',1,1)
      ENDIF

      RETURN
      END
      SUBROUTINE FPOUT(KF,KPASS,PX,KLEV,LPCPPR,LPCPPL)
**    Function - to determine TF vertical profile at selected latitude-
**          longtitude coordinates, and to output the profiles. One
**          model field is handled for each call to this subroutine, the
**          field is assumed to be a 3D (non-surface) field.
**    Args in -
**               KF      - Number of the SG field to be processed
**               KPASS   - 1: total flux
**                         2: high pass flux
**                         3: low pass flux
**               PX      - Array containing data in meteorological
**                         output units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPCPPR  - .TRUE. for column profile printout,
**               LPCPPL  - .TRUE. for column profile UTFs,
**    Args out - none
**    Args for work - none
**    Com used - /TFDIAG/NCTF,TFCUT,/COMDAT/YTYPSF,BEGDAY,
**          ENDDAY,/FPDIAG/NFPPF,VFPPF,/TFCNST/YNAMTF,
**          /VERTCL/SIGMA,/LVDIAG/SFCOUT,/COMTIM/NSDATE,NEDATE,
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNL,JPJG,JPNHEM,/PARAM2/JPJGG
**          /PARAM3/JPFPPF
**    Called by - OPTF
**    Calls - PROFIL,PCOLOP
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDFPCP
      COMMON /FPDIAG/NFPPF,VFPPF(2,JPFPPF),NFPPR(JPTFMX),
     -      NFPPL(JPTFMX),LDFPCP
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      COMMON /VERTCL/SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),
     -      SIGMAK(JPNL),SIGM1K(JPNL),RDSIG(JPNL),SIGMA3(JPNL)
      DIMENSION PX(JPMG,JPJGG,JPNL)
      DIMENSION ZPF(JPNL,JPFPPF),ZOUTLV(JPNL)
      LOGICAL LPCPPR,LPCPPL
      CHARACTER*50 YONAME,YOX,YOY

**    Return if column totals and profiles not required
      IF((.NOT.LDFPCP)) RETURN

      IF(KLEV.NE.JPNL) THEN
         WRITE(6,6000) KLEV
6000     FORMAT(1X,'***FPOUT: WARNING - NO PROFILES COMPUTED, ONLY ',
     -         I5,' LEVELS OF DATA')
         RETURN
      ENDIF

      ZDAY1=BEGDAY
      ZDAY2=ENDDAY

**    Compute profiles at the specified coordinates
      CALL PROFIL(PX,JPMG,ZPF,NFPPF,VFPPF,KLEV)

**    Output the profiles
      IF(LPCPPR.OR.LPCPPL) THEN
         YONAME=YNAMTF(KPASS,KF)
         IF(YTYPSF.EQ.'ET') THEN
            YONAME(48:50)=' SI'
            ILVTYP=0
            DO 300 J=1,JPNL
            ZOUTLV(J)=SIGMA(J)
300         CONTINUE
         ELSE IF(YTYPSF.EQ.'IS') THEN
            YONAME(48:50)=' IS'
            ILVTYP=2
            DO 301 J=1,JPNL
            ZOUTLV(J)=SFCOUT(J)
301         CONTINUE
         ELSE IF(YTYPSF.EQ.'TH') THEN
            YONAME(48:50)=' TH'
            ILVTYP=3
            DO 302 J=1,JPNL
            ZOUTLV(J)=SFCOUT(J)
302         CONTINUE
         ENDIF
         IF(KPASS.GT.1) THEN
            YONAME(41:43)='CUT'
            IF(TFCUT.LT.10.0) THEN
               WRITE(YONAME(44:46),'(F3.1)')TFCUT
            ELSE
               WRITE(YONAME(44:46),'(I3)')NINT(TFCUT)
            ENDIF
         ELSE
            YONAME(41:46)='      '
         ENDIF
         YOY='      '//YONAME(47:50)
         YOX=' '
         CALL PCOLOP(ZPF,JPNL,NFPPF,ZDAY1,ZDAY2,YONAME,0,
     -         LPCPPR,LPCPPL,NCTF,VFPPF,ZOUTLV,ILVTYP,YOX,YOY)
      ENDIF

      RETURN
      END
      SUBROUTINE FZOUT(KF,KPASS,PX,KLEV,LPZMPR,LPZMPL,LPLSPR,
     -      LPLSPL,LPLRPR,LPLRPL)
**    Function - to control zonal TF output. One field is handled
**          for each call to this subroutine.
**    Args in -
**               KF      - Number of the TF field to be processed
**               KPASS   - 1: total flux
**                         2: high pass flux
**                         3: low pass flux
**               PX      - Array containing data in MKS units
**               KLEV    - Data is stored for levels (1:KLEV) although
**                         the array is dimensioned to contain JPNL
**                         levels
**               LPZMPR  - .TRUE. if zonal means to be printed
**               LPZMPL  - .TRUE. if zonal means to be plotted
**               LPLSPR  - .TRUE. for north-south longitude slice
**                         printouts
**               LPLSPL  - .TRUE. for north-south longitude slice plots
**               LPLRPR  - .TRUE. for limited longitude-range 'zonal
**                         mean' printout
**               LPLRPL  - .TRUE. for limited longitude-range 'zonal
**                         mean' plots
**    Args out - none
**    Args for work - none
**    Com used - /TFCNST/YNAMTF,/TFDIAG/NCTF,TFCUT,
**          /COMTIM/NSDATE,NEDATE,
**          /COMDAT/YTYPSF,BEGDAY,ENDDAY,NSIGFG,/FZCNST/CIFZ,
**          /FZDIAG/VFZNS,VFZNSA,/LEGAU/ALATBY
**    Com changed - none
**    Params used - /PARAM1/JPMG,JPNL,/PARAM2/JPJGG,JPMGP,JPJGGP,
**          /PARAM3/JPTFMX
**    Called by - OPTF
**    Calls - ZMEAN3,ZSECTE,NSLONR,BOXAVS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      LOGICAL LDFZPR,LDFZPL
      COMMON /FZCNST/LDFZPR(JPTFMX),LDFZPL(JPTFMX),CIFZ(JPTFMX)
      LOGICAL LDFZZM
      COMMON /FZDIAG/LDFZZM,VFZNS,VFZNSA(2),NFZPR(JPTFMX),
     -      NFZPL(JPTFMX),CINTFZ(JPTFMX)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      PARAMETER(JPXPD2=JPXPMX/2)
      COMMON /ZONAVP/UTVDZ(JPIGG,2),VTVDZ(JPIGG,2),TTVDZ(JPIGG,2),
     -      QTVDZ(JPIGG,2),TTCRZ(JPIGG,2),QTCRZ(JPIGG,2),TTLRZ(JPIGG,2),
     -      QTLRZ(JPIGG,2),TTRDZ(JPIGG,2),UTBLZ(JPIGG,2),VTBLZ(JPIGG,2),
     -      TTBLZ(JPIGG,2),QTBLZ(JPIGG,2),UTOTZ(JPIGG,2),VTOTZ(JPIGG,2),
     -      TTOTZ(JPIGG,2),QTOTZ(JPIGG,2),CTCRZ(JPIGG,2),CTLRZ(JPIGG,2)
      DIMENSION GPPZ(JPIGG,2,JPXPD2)
      EQUIVALENCE (GPPZ(1,1,1),UTVDZ(1,1))
      DIMENSION PX(JPMG,JPJGG,JPNL)
      LOGICAL LPZMPR,LPZMPL,LPLSPR,LPLSPL,LPLRPR,LPLRPL,LOINST
      CHARACTER*50 YONAME
      CHARACTER*1 YOT
      DIMENSION ZZONAL(JPJGG,JPNL),ZLONI(JPMGP),ZLONO(JPMGP),
     -      ZLATO(JPJGGP)

      YONAME=YNAMTF(KPASS,KF)
      IF(YTYPSF.EQ.'ET') THEN
         YONAME(28:29)='SI'
         ILVTYP=0
      ELSE IF(YTYPSF.EQ.'IS') THEN
         YONAME(28:29)='IS'
         ILVTYP=2
      ELSE IF(YTYPSF.EQ.'TH') THEN
         YONAME(28:29)='TH'
         ILVTYP=3
      ENDIF
      IF(KPASS.GT.1) THEN
         YONAME(30:32)='CUT'
         IF(TFCUT.LT.10.0) THEN
CHACK******
C           WRITE(YONAME(33:35),'(F3.1)')TFCUT
      YONAME(33:35)='3.0'
C***********
         ELSE
            WRITE(YONAME(33:35),'(I3)')NINT(TFCUT)
         ENDIF
      ELSE
         YONAME(30:35)='      '
      ENDIF

      ZDAY1=BEGDAY
      ZDAY2=ENDDAY

      IMSK=0
      LOINST=.FALSE.
**    Setting YOT to 'S" will prevent use of masking arrays
      YOT='S'
      ITFLAG=1

**    Create zonal means
      IF(LPZMPR.OR.LPZMPL) THEN
         CALL ZMEAN3(PX,JPMG,JPJGG,KLEV,ZZONAL,JPMG,YOT,LOINST)
      ENDIF

**    Print out the zonal means, and pass them to the UTF file
      IF(LPZMPR.OR.LPZMPL) THEN
         YONAME(36:47)=' ZONAL MEAN '
         CALL ZSECTE(ZZONAL,JPJGG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -         NCTF,1,JPJGG,1,JPNL,ZDAY1,ZDAY2,CIFZ(KF),LPZMPR,
     -         LPZMPL,1,0,0.0,0,ITFLAG,11,IMSK,0,ILVTYP,ZZONAL,
     -         ZZONAL,' ',' ',1,1)
      ENDIF

**    Calculate a slice at the single longitude VFZNS; assume
**    d(field)/d(longitude) is constant
      IF(LPLSPR.OR.LPLSPL) THEN
         CALL NSLONR(VFZNS,JPMG,PX,JPMG,JPJGG,KLEV,ZZONAL)
         WRITE(YONAME(36:47),'('' LON. '',F5.1,1X)')VFZNS
         CALL ZSECTE(ZZONAL,JPJGG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -         NCTF,1,JPJGG,1,JPNL,ZDAY1,ZDAY2,CIFZ(KF),LPLSPR,
     -         LPLSPL,1,0,0.0,0,ITFLAG,11,0,0,ILVTYP,ZZONAL,
     -         ZZONAL,' ',' ',1,1)
      ENDIF

**    North-south slice of area-averaged values between two specified
**          longitudes (VFZNSA(1) and VFZNSA(2))
      IF(LPLRPR.OR.LPLRPL) THEN
         DO 1000 JL=1,KLEV
         CALL BOXAVS(2,ZLONI,JPMG,ZLONO,VFZNSA(1),VFZNSA(2),ZLATO,
     -         ALATBY,JPJGG,-90.0,90.0,PX(1,1,JL),
     -         ZZONAL(1,JL),JPJGG,.FALSE.)
1000     CONTINUE
         WRITE(YONAME(36:47),'(''AV'',I4,''/'',I4,''E'')')
     -         NINT(VFZNSA(1)),NINT(VFZNSA(2))
         CALL ZSECTE(ZZONAL,JPJGG,JPNL,YONAME,0.0,NSIGFG,50,-1,1,
     -         NCTF,1,JPJGG,1,JPNL,ZDAY1,ZDAY2,CIFZ(KF),LPLRPR,
     -         LPLRPL,1,0,0.0,0,ITFLAG,11,0,0,ILVTYP,ZZONAL,
     -         ZZONAL,' ',' ',1,1)
      ENDIF

      RETURN
      END
      SUBROUTINE OPTF
**    Function - to control output of transient flux diagnostics
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /F3CNST/LDF3PL,/FHCNST/LDFHPL,LDFHPR,LDFHSL,
**          /FMCNST/LDFMPR,LDFMPL,/FPCNST/LDFPPR,LDFPPL,
**          /FZCNST/LDFZPR,LDFZPL,/TFDIAG/NTF,LDFH,LDFZ,LDFM,
**          LDFP,LDF3,LTFTOT,LTFHP,LTFLP,/FZDIAG/LDFZZM,VFZNS,
**          VFZNSA,/FMDIAG/LDFMMM,VFMEW,VFMEWA,/COMIOC/NCTF2,
**          /DIAGTP/LDTF,/VARTIM/LTPRNT,LTASCI,/FHDIAG/LDFHSL,
**          /FPDIAG/LDFPCP
**    Com changed - /SPECTR/VO...SPAD,/CWORK/WORK3D
**    Params used - /PARAM1/JPNL,JPMG,JPJG,JPNHEM,
**          /PARAM2/JPJGG,JPIGD,JPMGPP/PARAM3/JPTFMX
**    Called by - ENDTF
**    Calls - LLCNVS,FHOUT,FZOUT,FMOUT,FPOUT,F3OUT
**    Files read - none
**    Files written - NCTF2
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,LDTJ
      COMMON /DIAGTP/LDPH,LDXP,LDCO,LDSG,LDTR,LDTF,LDOD,LDZF,
     -      LDTJ
      LOGICAL LDF3PL
      COMMON /F3CNST/LDF3PL(JPTFMX)
      LOGICAL LDFHPR,LDFHPL
      COMMON /FHCNST/LDFHPR(JPTFMX),LDFHPL(JPTFMX),CIFH(JPTFMX)
      LOGICAL LDFHSL
      COMMON /FHDIAG/NFHPR(JPTFMX),NFHPL(JPTFMX),CINTFH(JPTFMX),LDFHSL
      LOGICAL LDFMPR,LDFMPL
      COMMON /FMCNST/LDFMPR(JPTFMX),LDFMPL(JPTFMX),CIFM(JPTFMX)
      LOGICAL LDFMMM
      COMMON /FMDIAG/LDFMMM,VFMEW,VFMEWA(2),NFMPR(JPTFMX),
     -      NFMPL(JPTFMX),CINTFM(JPTFMX)
      LOGICAL LDFPPR,LDFPPL
      COMMON /FPCNST/LDFPPR(JPTFMX),LDFPPL(JPTFMX)
      LOGICAL LDFPCP
      COMMON /FPDIAG/NFPPF,VFPPF(2,JPFPPF),NFPPR(JPTFMX),
     -      NFPPL(JPTFMX),LDFPCP
      LOGICAL LDFZPR,LDFZPL
      COMMON /FZCNST/LDFZPR(JPTFMX),LDFZPL(JPTFMX),CIFZ(JPTFMX)
      LOGICAL LDFZZM
      COMMON /FZDIAG/LDFZZM,VFZNS,VFZNSA(2),NFZPR(JPTFMX),
     -      NFZPL(JPTFMX),CINTFZ(JPTFMX)
      PARAMETER(ISPAD=9200)
      COMPLEX VO,D,T,Q,H,SP,GS,VORES
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA),VORES(JPIGN),DRES(JPIGN),
     -      TRES(JPIGN)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      LOGICAL LTPRNT,LTASCI,LTOUT
      COMMON /VARTIM/NSTEPT,DAYT,LTPRNT,LTASCI,LTOUT
      LOGICAL LOFP,LOFH,LOFZ,LOFM,LOF3,LOFLD
      LOGICAL LOCPPR,LOCPPL,LOFHPR,LOFHPL
      LOGICAL LOZMPR,LOZMPL,LOLSPR,LOLSPL,LOLRPR,LOLRPL
      LOGICAL LOMMPR,LOMMPL,LOLAPR,LOLAPL,LOLMPR,LOLMPL
      DIMENSION Z(JPMG,JPJGG,JPNL),ZR(JPIGD,JPJG)
      EQUIVALENCE (Z(1,1,1),VO(1)),(ZR(1,1),VO(1))

      IF(.NOT.LDTF) RETURN
      IF((.NOT.LTFTOT).AND.(.NOT.LTFHP).AND.(.NOT.LTFLP)) RETURN

**    Outer loop is over all possible TF output fields. This means that
**    any required field is read once-only off the scratch file at
**    output.

      DO 100 JF=1,JPTFMX
      DO 105 JPASS=1,3
      LOFP=.FALSE.
      LOFH=.FALSE.
      LOFZ=.FALSE.
      LOFM=.FALSE.
      LOF3=.FALSE.
**    First determine if field number JF is required

**    Vertical profile diagnostics
      IF(LDFP.AND.(LDFPPR(JF).OR.LDFPPL(JF))) LOFP=.TRUE.

**    Horizontal level diagnostics
      IF(LDFH.AND.(LDFHPR(JF).OR.LDFHPL(JF))) LOFH=.TRUE.

**    Zonal slice diagnostics
      IF(LDFZ.AND.(LDFZPR(JF).OR.LDFZPL(JF))) LOFZ=.TRUE.

**    Meridional slice diagnostics
      IF(LDFM.AND.(LDFMPR(JF).OR.LDFMPL(JF))) LOFM=.TRUE.

**    3-D field output to user-specified output channel
      IF(LDF3.AND.LDF3PL(JF)) LOF3=.TRUE.

**    LOFLD set to .TRUE. if field JF required
      LOFLD=LOFP.OR.LOFH.OR.LOFZ.OR.LOFM.OR.LOF3

      IF(JPASS.EQ.1.AND.(.NOT.LTFTOT)) LOFLD=.FALSE.
      IF(JPASS.EQ.2.AND.(.NOT.LTFHP)) LOFLD=.FALSE.
      IF(JPASS.EQ.3.AND.(.NOT.LTFLP)) LOFLD=.FALSE.

      IF(LOFLD) THEN
**       Read field from scratch file NCTF2
         INIREC=(JF-1)*3+JPASS
         ISKP=NTF*3
         ILEV=JPNL
**       Skip over unwanted records at beginning of file
         IF(INIREC.NE.1) THEN
            DO 1001 JR=1,INIREC-1
            READ(NCTF2)
1001        CONTINUE
         ENDIF
**       Read required records, skipping over those in-between
         DO 1002 J=1,JPJG
         READ(NCTF2)(ZR(JI,J),JI=1,JPIGD)
         IF(J.NE.JPJG) THEN
            DO 1003 JR=1,ISKP-1
            READ(NCTF2)
1003        CONTINUE
         ENDIF
1002     CONTINUE

**       Convert to 'standard' indexing format
         CALL LLCNVS(ZR,JPMGPP,JPNHEM,JPNL,JPJG,Z,JPMG,JPJGG,
     -         JPNL,ILEV,.TRUE.,WORK3D,JPMGPP,JPNHEM,JPNL,JPJG,
     -         .TRUE.,IDUMMY)

**       Now perform diagnostics
**       TF horizontal diagnostics
         IF(LOFH) THEN
**          LOFHPR is .TRUE. for horizontal level printout
**          LOFHPL is .TRUE. for horizontal level plots
            LOFHPR=LTPRNT.AND.LDFHSL.AND.LDFHPR(JF)
            LOFHPL=LTASCI.AND.LDFHSL.AND.LDFHPL(JF)
            CALL FHOUT(JF,JPASS,Z,ILEV,LOFHPR,LOFHPL)
         ENDIF

**       TF zonal diagnostics
         IF(LOFZ) THEN
**          LOZMPR is .TRUE. for zonal mean printout
**          LOZMPL is .TRUE. for zonal mean plots
**          LOLSPR is .TRUE. for north-south longitude slice printout
**          LOLSPL is .TRUE. for north-south longitude slice plots
**          LOLRPR is .TRUE. for limited longitude-range mean (printout)
**          LOLRPL is .TRUE. for limited longitude-range mean (plot)
            LOZMPR=LDFZPR(JF).AND.LTPRNT.AND.LDFZZM
            LOZMPL=LDFZPL(JF).AND.LTASCI.AND.LDFZZM
            LOLSPR=LDFZPR(JF).AND.LTPRNT.AND.(VFZNS.GT.-990.0)
            LOLSPL=LDFZPL(JF).AND.LTASCI.AND.(VFZNS.GT.-990.0)
            LOLRPR=LDFZPR(JF).AND.LTPRNT.AND.(VFZNSA(1).GT.-990.0)
            LOLRPL=LDFZPL(JF).AND.LTASCI.AND.(VFZNSA(1).GT.-990.0)
            CALL FZOUT(JF,JPASS,Z,ILEV,LOZMPR,LOZMPL,LOLSPR,
     -            LOLSPL,LOLRPR,LOLRPL)
         ENDIF

**       TF meridional diagnostics
         IF(LOFM) THEN
**          LOMMPR is .TRUE. for meridional mean printout
**          LOMMPL is .TRUE. for meridional mean plots
**          LOLAPR is .TRUE. for north-south latitude slice printout
**          LOLAPL is .TRUE. for north-south latitude slice plots
**          LOLMPR is .TRUE. for limited latitude-range mean (printout)
**          LOLMPL is .TRUE. for limited latitude-range mean (plot)
            LOMMPR=LDFMPR(JF).AND.LTPRNT.AND.LDFMMM
            LOMMPL=LDFMPL(JF).AND.LTASCI.AND.LDFMMM
            LOLAPR=LDFMPR(JF).AND.LTPRNT.AND.(VFMEW.GT.-990.0)
            LOLAPL=LDFMPL(JF).AND.LTASCI.AND.(VFMEW.GT.-990.0)
            LOLMPR=LDFMPR(JF).AND.LTPRNT.AND.(VFMEWA(1).GT.-990.0)
            LOLMPL=LDFMPL(JF).AND.LTASCI.AND.(VFMEWA(1).GT.-990.0)
            CALL FMOUT(JF,JPASS,Z,ILEV,LOMMPR,LOMMPL,LOLAPR,
     -            LOLAPL,LOLMPR,LOLMPL)
         ENDIF

**       TF profile diagnostics
         IF(LOFP) THEN
**          LOCPPR is .TRUE. for column profile printout,
**          LOCPPL is .TRUE. for column profile UTFs,
            LOCPPR=LDFPCP.AND.LTPRNT.AND.LDFPPR(JF)
            LOCPPL=LDFPCP.AND.LTASCI.AND.LDFPPL(JF)
            CALL FPOUT(JF,JPASS,Z,ILEV,LOCPPR,LOCPPL)
         ENDIF

**       Output of 3-D TF field data
         IF(LOF3.AND.LTOUT.AND.LTASCI) THEN
            CALL F3OUT(JF,JPASS,Z,ILEV)
         ENDIF

**       Rewind NCTF2 ready to read in the next flux component
         REWIND NCTF2
      ENDIF
105   CONTINUE
100   CONTINUE

      RETURN
      END
      SUBROUTINE TFCONT (KLAT,LPGRID)
**    Function - To control the incorporation of contributions from the
**          gridpoint fields into the transient fluxes.
**    Args in -
**               KLAT    - Current latitude at which contributions are
**                         to be computed.
**               LPGRID  - .TRUE. if fields are located in /GRIDP/ and
**                         tracer common blocks - else they are located
**                         on scratch files.
**    Args out - none
**    Args for work - none
**    Com used - /TFDIAG/NTF,NFLDTF,FACTTF,/COMIOC/NCGP,NCTRC,
**          NCTF1,NCTF2,/COMNGP/NR1SF,
**          NR1VO,NRID,NR1OM,NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,
**          NR1CHI,NR1AP,NR1TH,NR1EPV,NR1FU,NR1FV,NR1MSF,NR1TR,
**          /COMTRV/NTRCRS,LTREXS,/TFCNST/NSAMLP
**    Com changed - /GRIDP/SFG,VOG,DG,OMG,UG,VG,TG,GHG,QG,HG,CHIG,APG,
**          THG,EPVG,FUG,FVG,AMSFG,/TRPTR/TRCRG,/TFCNST/NPER,NLOWPB
**    Params used - /PARAM2/JPIGC,JPIGD,/PARAM3/JPSGMX,JPTRF,JPTRMX,JPTRL,
**          JPTFMX,/TRPTR/JPITRG
**    Called by - SGFLUX
**    Calls - TFSUMM,ABORT,CURRD
**    Files read - NCGP(1),NCTRC
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
**    JPGRID should be set to the total number of elements on /GRIDP/
      PARAMETER(JPGRID=20*JPIGD+5*JPIGC)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      LOGICAL LGCMTR,LTREXS
      COMMON /COMTRV/LGCMTR,NTRCRS,LTREXS
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      COMPLEX TRCR
      POINTER (JPITRG,TRCRG(JPIGD,NTRCRS)),(JPITR,TRCR(JPIGB,NTRCRS))
      COMMON /TRPTR/JPITRG,JPITR
      LOGICAL LPGRID,LOCALL
      LOGICAL LOFLD(JPSGMX),LOTRC(JPTRMX)
      DIMENSION IZPTR(0:JPSGMX),IELEM1(JPTFMX),IELEM2(JPTFMX)
      DIMENSION ZGRID(JPGRID),ZTFG(JPIGD,4)
      EQUIVALENCE (ZGRID(1),UG(1))
      EXTERNAL ADD0,ADD1,ADD2
      SAVE LOCALL,LOFLD,LOTRC,IZPTR,IELEM1,IELEM2
      DATA LOCALL/.TRUE./,LOFLD/JPSGMX*.FALSE./,LOTRC/JPTRMX*.FALSE./

**    If this is the first time that the routine is called, then
      IF(LOCALL) THEN
         IF(.NOT.LPGRID) THEN
**          Determine which fields are to be extracted from scratch
**          files  -- note that each field may appear in more than one
**          transient flux equation.
            DO 100 JTF=1,NTF
            DO 100 JF=1,4
            IFLDNO=NFLDTF(JF,JTF)
            IF(IFLDNO.GT.0.AND.IFLDNO.LE.JPSGMX) THEN
               LOFLD(IFLDNO)=.TRUE.
            ENDIF
            IF(IFLDNO.GE.JPTRF) THEN
               LOTRC(IFLDNO-JPTRF+1)=.TRUE.
            ENDIF
100         CONTINUE
         ENDIF

**       IZPTR(j) points to the first element of data in /GRIDP/
**       corresponding to the SG field code j. The entry for j=0
**       is a dummy one - the corresponding array should not be used.
         IZPTR(0)=1
         IZPTR(5)=1
         IZPTR(6)=IZPTR(5)+JPIGD
         IZPTR(2)=IZPTR(6)+JPIGD
         IZPTR(3)=IZPTR(2)+JPIGD
         IZPTR(9)=IZPTR(3)+JPIGD
         IZPTR(10)=IZPTR(9)+JPIGD
         IZPTR(7)=IZPTR(10)+JPIGD
         IZPTR(1)=IZPTR(7)+3*(JPIGC+JPIGD)
         IZPTR(11)=IZPTR(1)+JPIGD
         IZPTR(4)=IZPTR(11)+JPIGD
         IZPTR(8)=IZPTR(4)+JPIGD
         IZPTR(12)=IZPTR(8)+JPIGD
         IZPTR(13)=IZPTR(12)+JPIGD
         IZPTR(14)=IZPTR(13)+JPIGD
         IZPTR(17)=IZPTR(14)+JPIGC+JPIGD
         IZPTR(18)=IZPTR(17)+JPIGD
         IZPTR(19)=IZPTR(18)+JPIGD

**       IELEM1 and IELEM2 are the number of valid fields (codes.ne.0)
**       in the first and second parts of each transient flux equation.
         DO 180 J=1,NTF
         IELEM1(J)=2
         IELEM2(J)=2
         IF(NFLDTF(1,J).EQ.0) IELEM1(J)=IELEM1(J)-1
         IF(NFLDTF(2,J).EQ.0) IELEM1(J)=IELEM1(J)-1
         IF(NFLDTF(3,J).EQ.0) IELEM2(J)=IELEM2(J)-1
         IF(NFLDTF(4,J).EQ.0) IELEM2(J)=IELEM2(J)-1
         IF(IABS(IELEM2(J)-IELEM1(J)).EQ.1) THEN
            WRITE(6,6100) IELEM1(J),IELEM2(J),J
6100        FORMAT(1X,'***TFCONT WARNING, NUMBER OF FIELDS IN EACH ',
     -            'TERM OF THE TF EQUATION ',I2,',',I2,/
     -            ' MAY BE IN ERROR FOR EQUATION NUMBER ',I3)
         ENDIF
180      CONTINUE

         LOCALL=.FALSE.
      ENDIF

      IF(.NOT.LPGRID) THEN
**       Gridpoint fields in scratch - copy appropriate fields to
**       common block and tracer arrays
         IF(LOFLD(1)) READ(NCGP(1),REC=NR1SF+KLAT-1)SFG
         IF(LOFLD(2)) READ(NCGP(1),REC=NR1VO+KLAT-1)VOG
         IF(LOFLD(3)) READ(NCGP(1),REC=NR1D+KLAT-1)DG
         IF(LOFLD(4)) READ(NCGP(1),REC=NR1OM+KLAT-1)OMG
         IF(LOFLD(5)) READ(NCGP(1),REC=NR1U+KLAT-1)UG
         IF(LOFLD(6)) READ(NCGP(1),REC=NR1V+KLAT-1)VG
         IF(LOFLD(7)) READ(NCGP(1),REC=NR1T+KLAT-1)TG
         IF(LOFLD(8)) READ(NCGP(1),REC=NR1GH+KLAT-1)GHG
         IF(LOFLD(9)) READ(NCGP(1),REC=NR1Q+KLAT-1)QG
         IF(LOFLD(10)) READ(NCGP(1),REC=NR1H+KLAT-1)HG
         IF(LOFLD(11)) READ(NCGP(1),REC=NR1CHI+KLAT-1)CHIG
         IF(LOFLD(12)) READ(NCGP(1),REC=NR1AP+KLAT-1)APG
         IF(LOFLD(13)) READ(NCGP(1),REC=NR1TH+KLAT-1)THG
         IF(LOFLD(14)) READ(NCGP(1),REC=NR1EPV+KLAT-1)EPVG
         IF(LOFLD(17)) READ(NCGP(1),REC=NR1FU+KLAT-1)FUG
         IF(LOFLD(18)) READ(NCGP(1),REC=NR1FV+KLAT-1)FVG
         IF(LOFLD(19)) READ(NCGP(1),REC=NR1MSF+KLAT-1)AMSFG
         DO 300 JF=1,NTRCRS
         IF(LOTRC(JF)) READ(NCTRC,REC=NR1TR(JF)+KLAT-1)
     -         (TRCRG(JI,JF),JI=1,JPIGD)
300       CONTINUE
      ENDIF

**    Increment counter NPER
      IF(KLAT.EQ.1) NPER=NPER+1

      DO 1000 JF=1,NTF
**    Set up arrays ZTFG(j), each containing one of
**    the (up to) four arrays required by the current transient flux
**    equation.
      DO 1100 J=1,4
      IF(NFLDTF(J,JF).EQ.0) THEN
**       No array requested - can use a dummy array for ZTFG
         IF(J.EQ.1) THEN
            WRITE(6,6000)
6000        FORMAT(1X,'***TFCONT ERROR: FIRST FIELD IS NULL:'
     -            'ABORT CALLED')
            CALL ABORT
         ELSE
            DO 1200 JE=1,JPIGD
            ZTFG(JE,J)=ZTFG(JE,J-1)
1200        CONTINUE
         ENDIF
      ELSE IF(NFLDTF(J,JF).GT.0.AND.NFLDTF(J,JF).LE.JPSGMX) THEN
**       Copy gridpoint array into ZTFG
         IEL=IZPTR(NFLDTF(J,JF))-1
         DO 1300 JE=1,JPIGD
         IEL=IEL+1
         ZTFG(JE,J)=ZGRID(IEL)
1300     CONTINUE
      ELSE IF(NFLDTF(J,JF).GE.JPTRF) THEN
**       Copy tracer into ZTFG
         ITR=NFLDTF(J,JF)-JPTRF+1
         DO 1400 JE=1,JPIGD
         ZTFG(JE,J)=TRCRG(JE,ITR)
1400     CONTINUE
      ENDIF
1100  CONTINUE

**    Functions to be called within TFSUMM dependent upon the form
**    of each transient flux equation
      IGD=JPIGD
      IF((IELEM1(JF).EQ.2).AND.(IELEM2(JF).EQ.2)) THEN
         CALL TFSUMM(ZTFG,IGD,4,FACTTF(1,JF),FACTTF(2,JF),ADD2,ADD2,
     -         IELEM1(JF),IELEM2(JF))
      ELSE IF((IELEM1(JF).EQ.2).AND.(IELEM2(JF).EQ.1)) THEN
         CALL TFSUMM(ZTFG,IGD,4,FACTTF(1,JF),FACTTF(2,JF),ADD2,ADD1,
     -         IELEM1(JF),IELEM2(JF))
      ELSE IF((IELEM1(JF).EQ.2).AND.(IELEM2(JF).EQ.0)) THEN
         CALL TFSUMM(ZTFG,IGD,4,FACTTF(1,JF),FACTTF(2,JF),ADD2,ADD0,
     -         IELEM1(JF),IELEM2(JF))
      ELSE IF((IELEM1(JF).EQ.1).AND.(IELEM2(JF).EQ.2)) THEN
         CALL TFSUMM(ZTFG,IGD,4,FACTTF(1,JF),FACTTF(2,JF),ADD1,ADD2,
     -         IELEM1(JF),IELEM2(JF))
      ELSE IF((IELEM1(JF).EQ.1).AND.(IELEM2(JF).EQ.1)) THEN
         CALL TFSUMM(ZTFG,IGD,4,FACTTF(1,JF),FACTTF(2,JF),ADD1,ADD1,
     -         IELEM1(JF),IELEM2(JF))
      ELSE IF((IELEM1(JF).EQ.1).AND.(IELEM2(JF).EQ.0)) THEN
         CALL TFSUMM(ZTFG,IGD,4,FACTTF(1,JF),FACTTF(2,JF),ADD1,ADD0,
     -         IELEM1(JF),IELEM2(JF))
      ENDIF
1000  CONTINUE

      IF(KLAT.EQ.JPJG) THEN
**       Rewind work files after last latitude summations at each
**       analysis time, and swap file names so that last file written
**       is the next file to be read.
         REWIND NCTF1
         REWIND NCTF2
         ICHAN=NCTF1
         NCTF1=NCTF2
         NCTF2=ICHAN

         IF(NPER.EQ.NSAMLP) THEN
**          Start another low pass block
            NPER=0
            NLOWPB=NLOWPB+1
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE TFINIT(LPTF)
**    Function - to initialise the arrays and constants required by the
**          TF diagnostics
**    Args in -
**               LPTF    - .TRUE. if TF diagnostics are required
**    Args out -
**               LPTF    - may be set to false if TF diagnostics are
**                         inappropriate
**    Args for work - none
**    Com used - /COMDAT/YTYPSF,NFREQD,/TFDIAG/NTF,FACTTF,NFLDTF,
**          NVTFHR,TFCUT,VTFSFC,/LVDIAG/NLEVEL,SFCOUT,
**          /FPDIAG/NFPPR,NFPPL,
**          /GHDIAG/all elements,/FMDIAG/NFMPR,NFMPL,CINTFM,
**          /FZDIAG/NFZPR,NFZPL,CINTFZ,/F3DIAG/NF3PL,
**          /COMAVG/LMASSW,/COMIOC/NCTF1,NCTF2,/COMTIM/TSPD
**    Com changed - /TFCNST/all elements,/F3CNST/all elements,
**          /FPCNST/all elements,/FHCNST/all elements,/FZCNST/all
**          elements,/FMCNST/all elements,/CWORK/WORK3D
**    Params used - /PARAM1/JPNL,JPJG,/PARAM2/JPIGD,/PARAM3/JPSGMX,
**          JPTFMX,JPTRL,JPTRF
**    Called by - DINIT
**    Calls - ABORT
**    Files read - none
**    Files written - NCTF1
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      PARAMETER(JPALOW=100+JPTRL)
      LOGICAL LMASSW,LAVMSK,LAVSIG
      COMMON /COMAVG/NAVTYP,LMASSW,LAVMSK,LAVSIG
      LOGICAL LWRITE,LASCII,LSCRAT,LUTF14,LROGR
      CHARACTER*2 YTYPSF
      CHARACTER*6 YDUM6
      CHARACTER*8 YNAME(2)
      INTEGER NAME(2)
      COMMON /COMDAT/BEGDAY,ENDDAY,LWRITE,LASCII,LSCRAT,NASCII,
     -      LUTF14,LROGR,NSIGFG,NAME,YNAME,YTYPSF,YDUM6
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /COMTIM/TSPD,NSTART,NEND,NFREQD,NFREQP,NFREQA,
     -      NFRACC
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LDF3PL
      COMMON /F3CNST/LDF3PL(JPTFMX)
      COMMON /F3DIAG/NCF3,NF3PL(JPTFMX)
      LOGICAL LDFHPR,LDFHPL
      COMMON /FHCNST/LDFHPR(JPTFMX),LDFHPL(JPTFMX),CIFH(JPTFMX)
      LOGICAL LDFHSL
      COMMON /FHDIAG/NFHPR(JPTFMX),NFHPL(JPTFMX),CINTFH(JPTFMX),LDFHSL
      LOGICAL LDFMPR,LDFMPL
      COMMON /FMCNST/LDFMPR(JPTFMX),LDFMPL(JPTFMX),CIFM(JPTFMX)
      LOGICAL LDFMMM
      COMMON /FMDIAG/LDFMMM,VFMEW,VFMEWA(2),NFMPR(JPTFMX),
     -      NFMPL(JPTFMX),CINTFM(JPTFMX)
      LOGICAL LDFPPR,LDFPPL
      COMMON /FPCNST/LDFPPR(JPTFMX),LDFPPL(JPTFMX)
      LOGICAL LDFPCP
      COMMON /FPDIAG/NFPPF,VFPPF(2,JPFPPF),NFPPR(JPTFMX),
     -      NFPPL(JPTFMX),LDFPCP
      LOGICAL LDFZPR,LDFZPL
      COMMON /FZCNST/LDFZPR(JPTFMX),LDFZPL(JPTFMX),CIFZ(JPTFMX)
      LOGICAL LDFZZM
      COMMON /FZDIAG/LDFZZM,VFZNS,VFZNSA(2),NFZPR(JPTFMX),
     -      NFZPL(JPTFMX),CINTFZ(JPTFMX)
      COMMON /LVDIAG/OUTLEV(JPNL),SFCOUT(JPNL),NLEVEL(JPNL)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      DIMENSION ZOUT(JPNL),ZTFAVG(JPIGD,10)
      EQUIVALENCE (ZTFAVG(1,1),WORK3D(1))
      LOGICAL LPTF,LOFLG1,LOFLG2
      CHARACTER*3 YOFLD(0:JPALOW),YOSIGM
      CHARACTER*4 YOFACT
      DATA (YOFLD(J),J=0,JPSGMX)/
     -      '   ',
     -      'PSI', 'RVO', 'DIV', 'OMG', ' U ', ' V ', ' T ',
     -      'GHT', ' Q ', 'HTG', 'CHI', ' P ', 'TH ', 'EPV',
     -      'XXX', 'XXX', 'FU ', 'FV ', ' M ', 'XXX', 'XXX'/
      DATA YOSIGM/'SIG'/

**    WARNING: Equivalencing of ZTFAVG with WORK3D may fail if
**    model arrays contain too few latitudes.
      IF(10.GT.JPJG) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***TFINIT: ERROR - FEWER THAN 10 LATITUDES IN ',
     -         'EACH HEMISPHERE MEANS ZTFAVG INCORRECTLY ',
     -         /'EQUIVALENCED; ABORT CALLED')
         CALL ABORT
      ENDIF

      DO 100 J=JPTRF,JPTRL
      YOFLD(J)(1:3)='TR0'
      ITR=J-100
      IF(ITR.LT.10) THEN
         WRITE(YOFLD(J)(3:3),7010)ITR
7010     FORMAT(I1)
      ELSE
         WRITE(YOFLD(J)(2:3),7020)ITR
7020     FORMAT(I2)
      ENDIF
100   CONTINUE

**    Process namelist information, and set up array titles etc
**    Default values set
      DO 1000 JI=1,JPTFMX
      CIFH(JI)=-0.1
      CIFM(JI)=-0.1
      CIFZ(JI)=-0.1
      LDF3PL(JI)=.FALSE.
      LDFPPL(JI)=.FALSE.
      LDFHPL(JI)=.FALSE.
      LDFMPL(JI)=.FALSE.
      LDFZPL(JI)=.FALSE.
      LDFPPR(JI)=.FALSE.
      LDFHPR(JI)=.FALSE.
      LDFMPR(JI)=.FALSE.
      LDFZPR(JI)=.FALSE.
      YNAMTF(1,JI)='+0.0XXXXXX+0.0XXXXXX(   T )'//
     -      '                    MKS'
      YNAMTF(2,JI)='+0.0XXXXXX+0.0XXXXXX(   HI)'//
     -      '                    MKS'
      YNAMTF(3,JI)='+0.0XXXXXX+0.0XXXXXX(   LO)'//
     -      '                    MKS'
1000  CONTINUE

**    When output is on theta surfaces THG gridpoint array will
**    contain -(1/g).d(P)/d(TH) at output; setting LMASSW to
**    .TRUE. will cause all quantities to be multiplied by sigma.
      IF(YTYPSF.EQ.'TH') THEN
         IF(LMASSW) THEN
            DO 1050 JI=1,JPTFMX
            YNAMTF(1,JI)(22:24)=YOSIGM
            YNAMTF(2,JI)(22:24)=YOSIGM
            YNAMTF(3,JI)(22:24)=YOSIGM
1050        CONTINUE
         ENDIF
         YOFLD(13)=YOSIGM
      ENDIF

      DO 1100 JL=1,JPNL
      LTFLEV(JL)=.FALSE.
1100  CONTINUE

      NPER=0
      NLOWPB=0
      NSAMLP=NINT(TFCUT*TSPD)/NFREQD

**    Now overwrite the default values according to the user's
**    namelist input

**    Formulae titles
      DO 1500 J=1,NTF
      WRITE(YOFACT,7000)FACTTF(1,J)
7000  FORMAT(F4.1)
      IF(FACTTF(1,J).GE.0.0) YOFACT(1:1)='+'
      YNAMTF(1,J)(1:4)=YOFACT
      YNAMTF(1,J)(5:7)=YOFLD(NFLDTF(1,J))
      YNAMTF(1,J)(8:10)=YOFLD(NFLDTF(2,J))
      WRITE(YOFACT,7000)FACTTF(2,J)
      IF(FACTTF(2,J).GE.0.0) YOFACT(1:1)='+'
      YNAMTF(1,J)(11:14)=YOFACT
      YNAMTF(1,J)(15:17)=YOFLD(NFLDTF(3,J))
      YNAMTF(1,J)(18:20)=YOFLD(NFLDTF(4,J))
      IF(YNAMTF(1,J)(15:20).EQ.'      ') YNAMTF(1,J)(11:14)='    '
      YNAMTF(2,J)(1:20)=YNAMTF(1,J)(1:20)
      YNAMTF(3,J)(1:20)=YNAMTF(1,J)(1:20)
1500  CONTINUE

**    Set LTFTRC to .TRUE. if tracers are used in the transient fluxes
      LTFTRC=.FALSE.
      DO 1600 JTF=1,NTF
      DO 1600 JF=1,4
      IF(NFLDTF(JF,JTF).GE.JPTRF) LTFTRC=.TRUE.
1600  CONTINUE

**    Set LTFGLB to .TRUE. if transient flux accumulations need to
**    be done 'globally', ie if vorticity, streamfunction, divergence
**    or velocity potential is involved, and if the output is not
**    on model (sigma) levels.
      LTFGLB=.FALSE.
      IF(YTYPSF.NE.'ET') THEN
         DO 1700 JTF=1,NTF
         DO 1700 JF=1,4
         IFLDNO=NFLDTF(JF,JTF)
         IF((IFLDNO.EQ.1).OR.(IFLDNO.EQ.2).OR.(IFLDNO.EQ.3).OR.
     -         (IFLDNO.EQ.11)) LTFGLB=.TRUE.
1700     CONTINUE
      ENDIF

**    ZZERO is a small constant used to detect the value 0.0. It should
**    be smaller than any expected user-input contour value.
      ZZERO=1.0E-3
      DO 2000 JI=1,JPTFMX

**    Printing control
      IFPGR=NFPPR(JI)
      IF(IFPGR.GT.0.AND.IFPGR.LE.JPTFMX) THEN
         LDFPPR(IFPGR)=.TRUE.
      ENDIF
      IFHGR=NFHPR(JI)
      IF(IFHGR.GT.0.AND.IFHGR.LE.JPTFMX) THEN
         LDFHPR(IFHGR)=.TRUE.
      ENDIF
      IFMGR=NFMPR(JI)
      IF(IFMGR.GT.0.AND.IFMGR.LE.JPTFMX) THEN
         LDFMPR(IFMGR)=.TRUE.
      ENDIF
      IFZGR=NFZPR(JI)
      IF(IFZGR.GT.0.AND.IFZGR.LE.JPTFMX) THEN
         LDFZPR(IFZGR)=.TRUE.
      ENDIF

**    Plotting control
      IF3PL=NF3PL(JI)
      IF(IF3PL.GT.0.AND.IF3PL.LE.JPTFMX) THEN
         LDF3PL(IF3PL)=.TRUE.
      ENDIF
      IFPPL=NFPPL(JI)
      IF(IFPPL.GT.0.AND.IFPPL.LE.JPTFMX) THEN
         LDFPPL(IFPPL)=.TRUE.
      ENDIF
      IFHPL=NFHPL(JI)
      IF(IFHPL.GT.0.AND.IFHPL.LE.JPTFMX) THEN
         LDFHPL(IFHPL)=.TRUE.
         IF(ABS(CINTFH(JI)).GT.ZZERO) CIFH(IFHPL)=CINTFH(JI)
      ENDIF
      IFZPL=NFZPL(JI)
      IF(IFZPL.GT.0.AND.IFZPL.LE.JPTFMX) THEN
         LDFZPL(IFZPL)=.TRUE.
         IF(ABS(CINTFZ(JI)).GT.ZZERO) CIFZ(IFZPL)=CINTFZ(JI)
      ENDIF
      IFMPL=NFMPL(JI)
      IF(IFMPL.GT.0.AND.IFMPL.LE.JPTFMX) THEN
         LDFMPL(IFMPL)=.TRUE.
         IF(ABS(CINTFM(JI)).GT.ZZERO) CIFM(IFMPL)=CINTFM(JI)
      ENDIF
2000  CONTINUE

**    Output level numbers determined - level numbers refer to
**          increasing values of sigma, theta, pressure, etc.
      IF(YTYPSF.EQ.'ET') THEN
**       Use NVTFHR to define LTFLEV
         DO 2400 JL=1,JPNL
         ILEV=NVTFHR(JL)
         LTFLEV(ILEV)=.TRUE.
2400     CONTINUE
      ELSE
**       Use VTFSFC to define LTFLEV. LTFLEV(JL) set to .TRUE. if JL
**       occurs in the array NLEVEL, and if SFCOUT(JL) occurs in
**       array VTFSFC
         IF(YTYPSF.EQ.'TH') THEN
            DO 2500 J=1,JPNL
            ZOUT(J)=SFCOUT(J)
2500        CONTINUE
         ELSE IF(YTYPSF.EQ.'IS') THEN
            DO 2600 J=1,JPNL
            ZOUT(J)=SFCOUT(J)*0.01
2600        CONTINUE
         ENDIF
         ZDELTA=1.0E-3
         DO 3000 JL=1,JPNL
**       Check that JL occurs in array NLEVEL
         LOFLG1=.FALSE.
         DO 3100 J=1,JPNL
         IF(NLEVEL(J).EQ.JL) LOFLG1=.TRUE.
3100     CONTINUE
**       Check that ZOUT(JL) occurs in array VTFSFC
         LOFLG2=.FALSE.
         DO 3200 J=1,JPNL
         ZP=VTFSFC(J)+ZDELTA
         ZM=VTFSFC(J)-ZDELTA
         IF(ZOUT(JL).GT.ZM.AND.ZOUT(JL).LT.ZP) LOFLG2=.TRUE.
3200     CONTINUE
         IF(LOFLG1.AND.LOFLG2) LTFLEV(JL)=.TRUE.
3000     CONTINUE
      ENDIF

**    Now initialise scratch files used during transient flux
**    calculations. Note that 10 working files are needed for each
**    of the NTF flux types to be computed.
      DO 4000 JWF=1,10
      DO 4000 JI=1,JPIGD
4000  ZTFAVG(JI,JWF)=0.0
      DO 4100 JTF=1,NTF
      DO 4100 JIH=1,JPJG
4100  WRITE(NCTF1)ZTFAVG
      REWIND NCTF1
      REWIND NCTF2

      RETURN
      END
      SUBROUTINE TFLAT(PCONVF,KDIM1,KELEM1,KELEM2,PFNC1,PFNC2,
     -      PFACT1,PFACT2)
**    Function - To compute the total, low and high pass transient
**          fluxes at a single latitude for a single transient flux
**          equation. The results, in MKS units, are output to the
**          transient flux scratch files NCTF2.
**    Args in -
**               PCONVF  - Conversion factors to convert fields to MKS
**                         units
**               KDIM1   - Dimension of PCONVF
**               KELEM1  - Number of fields in first term of the
**                         transient flux equation
**               KELEM2  - Number of fields in the second term of the
**                         transient flux equation
**               PFNC1   - Function required to process first term in
**                         the equation
**               PFNC2   - Function required to process second term in
**                         the equation
**               PFACT1  - First multiplicative factor in equation
**               PFACT2  - Second multiplicative factor in equation
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCTF1,NCTF2,TFCNST/NSAMLP,NLOWPB
**    Com changed - none
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPIGC,JPMGPP,
**          JPIGD,/PARAM3/JPTFMX
**    Called by - TFMEAN
**    Calls - ABORT,PFNC1,PFNC2
**    Files read - NCTF1
**    Files written - NCTF2
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      DIMENSION PCONVF(KDIM1)
      DIMENSION ZTFAVG(JPIGD,10)

**    Check dimensions
      IF(4.NE.KDIM1) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***TFLAT ERROR - INVALID DIMENSIONS; ABORT')
         CALL ABORT
      ENDIF
**    WARNING: Equivalencing of ZTFAVG with WORK3D may fail if
**    model arrays contain too few latitudes
      IF(10.GT.JPJG) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***TFLAT: ERROR - FEWER THAN 10 LATITUDES IN ',
     -         'EACH HEMISPHERE MEANS ZTFAVG INCORRECTLY ',
     -         /'EQUIVALENCED; ABORT CALLED')
         CALL ABORT
      ENDIF

**    Check that all conversion factor products are identical -
**    otherwise, the resulting equation is meaningless.
      ZF1=PCONVF(1)*PCONVF(2)
      ZF2=PCONVF(3)*PCONVF(4)
      ZF12=ZF2-ZF1
      IF(KELEM2.NE.0.AND.(ABS(ZF12).GT.1.0E-3)) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'***TFLAT ERROR - INVALID MKS FACTORS; ABORT')
         CALL ABORT
      ENDIF
      ZCONVF=ZF1

      READ(NCTF1) ZTFAVG

**    ZSAMPL is the reciprocal of the number of timestep samples used in
**    total. ZPASS needs to take into account the number of fields in
**    each term of the equation, and also the number of low pass blocks
**    completed.
      ZSAMPL=1.0/(FLOAT(NSAMLP*NLOWPB))
      ZPASS=1.0/FLOAT((NSAMLP**KELEM1)*NLOWPB)

      IF(KELEM1.EQ.2) THEN
         DO 100 JL=1,JPNL
         IOFL=(JL-1)*JPIGC
         DO 100 JHEM=1,JPNHEM
         IOF=(JHEM-1)*JPMGPP
         DO 100 JI=1,JPMG
         J=JI+IOFL+IOF
         ZTFAVG(J,2)=0.0
         ZTFAVG(J,7)=ZTFAVG(J,7)*ZSAMPL
         ZTFAVG(J,8)=ZTFAVG(J,8)*ZSAMPL
100      CONTINUE
      ELSE IF(KELEM1.EQ.1) THEN
         DO 110 JL=1,JPNL
         IOFL=(JL-1)*JPIGC
         DO 110 JHEM=1,JPNHEM
         IOF=(JHEM-1)*JPMGPP
         DO 110 JI=1,JPMG
         J=JI+IOFL+IOF
         ZTFAVG(J,2)=0.0
         ZTFAVG(J,7)=ZTFAVG(J,7)*ZSAMPL
110      CONTINUE
      ENDIF
      ZFAIL=PFNC1(PFACT1,ZTFAVG(1,7),ZTFAVG(1,8),ZTFAVG(1,2),JPIGD)
         IF(KELEM2.EQ.2) THEN
         DO 120 JL=1,JPNL
         IOFL=(JL-1)*JPIGC
         DO 120 JHEM=1,JPNHEM
         IOF=(JHEM-1)*JPMGPP
         DO 120 JI=1,JPMG
         J=JI+IOFL+IOF
         ZTFAVG(J,9)=ZTFAVG(J,9)*ZSAMPL
         ZTFAVG(J,10)=ZTFAVG(J,10)*ZSAMPL
120      CONTINUE
         ZFAIL=PFNC2(PFACT2,ZTFAVG(1,9),ZTFAVG(1,10),ZTFAVG(1,2),JPIGD)
      ELSE IF(KELEM2.EQ.1) THEN
         DO 130 JL=1,JPNL
         IOFL=(JL-1)*JPIGC
         DO 130 JHEM=1,JPNHEM
         IOF=(JHEM-1)*JPMGPP
         DO 130 JI=1,JPMG
         J=JI+IOFL+IOF
         ZTFAVG(J,9)=ZTFAVG(J,9)*ZSAMPL
130      CONTINUE
**       ZTFAVG( ,10) used as a dummy argument
         ZFAIL=PFNC2(PFACT2,ZTFAVG(1,9),ZTFAVG(1,10),ZTFAVG(1,2),JPIGD)
      ENDIF

**    Compute total eddy flux ZTFAVG( ,1), and the low pass component
**    ZTFAVG( ,3)
      DO 140 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 140 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 140 JI=1,JPMG
      J=JI+IOFL+IOF
      ZTFAVG(J,1)=ZCONVF*(ZTFAVG(J,1)*ZSAMPL-ZTFAVG(J,2))
      ZTFAVG(J,3)=ZCONVF*(ZPASS*ZTFAVG(J,6)-ZTFAVG(J,2))
140   CONTINUE

**    Compute high pass component ZTFAVG( ,2)
      DO 150 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 150 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 150 JI=1,JPMG
      J=JI+IOFL+IOF
      ZTFAVG(J,2)=ZTFAVG(J,1)-ZTFAVG(J,3)
150   CONTINUE

**    Store results on NCTF2
      DO 160 J=1,3
      WRITE(NCTF2)(ZTFAVG(JI,J),JI=1,JPIGD)
160   CONTINUE

      RETURN
      END
      SUBROUTINE TFMEAN
**    Function - Controls the computation of the transient fluxes,
**          for all equations and all latitudes.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /TFDIAG/NTF,NFLDTF,FACTTF/COMIOC/NCTF1,NCTF2,
**          /LEGAU/CS
**    Com changed - none
**    Params used - /PARAM1/JPJG,/PARAM3/JPTFMX,/PARAM2/JPJGG
**    Called by - ENDTF
**    Calls - TFLAT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP),ALONBY(JPMGP)
      LOGICAL LDFH,LDFZ,LDFM,LDFP,LDF3,LTFTOT,LTFHP,LTFLP
      COMMON /TFDIAG/LDFH,LDFZ,LDFM,LDFP,LDF3,NCTF,NVTFHR(JPNL),
     -      VTFSFC(JPNL),TFCUT,NTF,FACTTF(2,JPTFMX),NFLDTF(4,JPTFMX),
     -      LTFTOT,LTFHP,LTFLP
      DIMENSION ZCONVF(4)
      DIMENSION IELEM1(JPTFMX),IELEM2(JPTFMX)
      EXTERNAL ADD0,ADD1,ADD2

**    IELEM1 and IELEM2 are the number of valid fields (codes.ne.0) in
**    the first and second part of each transient flux equation.
      DO 3000 J=1,NTF
      IELEM1(J)=2
      IELEM2(J)=2
      IF(NFLDTF(1,J).EQ.0) IELEM1(J)=IELEM1(J)-1
      IF(NFLDTF(2,J).EQ.0) IELEM1(J)=IELEM1(J)-1
      IF(NFLDTF(3,J).EQ.0) IELEM2(J)=IELEM2(J)-1
      IF(NFLDTF(4,J).EQ.0) IELEM2(J)=IELEM2(J)-1
3000  CONTINUE

**    Loop over all the Gaussian latitudes
      DO 1000 JLAT=1,JPJG
**    Loop over all the equations
      DO 100 JE=1,NTF
**    Determine necessary factors to convert to MKS units - all
**    gridpoint fields are stored as MKS fields in the required units,
**    except for u and v which are stored as velocity times
**    cos(latitude)
      DO 110 JF=1,4
      ZCONVF(JF)=1.0
      IF((NFLDTF(JF,JE).EQ.5).OR.(NFLDTF(JF,JE).EQ.6))
     -       ZCONVF(JF)=1.0/CS(JLAT)
110   CONTINUE
      IF((IELEM1(JE).EQ.2).AND.(IELEM2(JE).EQ.2)) THEN
         CALL TFLAT(ZCONVF,4,IELEM1(JE),IELEM2(JE),ADD2,ADD2,
     -         FACTTF(1,JE),FACTTF(2,JE))
      ELSE IF((IELEM1(JE).EQ.2).AND.(IELEM2(JE).EQ.1)) THEN
         CALL TFLAT(ZCONVF,4,IELEM1(JE),IELEM2(JE),ADD2,ADD1,
     -         FACTTF(1,JE),FACTTF(2,JE))
      ELSE IF((IELEM1(JE).EQ.2).AND.(IELEM2(JE).EQ.0)) THEN
         CALL TFLAT(ZCONVF,4,IELEM1(JE),IELEM2(JE),ADD2,ADD0,
     -         FACTTF(1,JE),FACTTF(2,JE))
      ELSE IF((IELEM1(JE).EQ.1).AND.(IELEM2(JE).EQ.2)) THEN
         CALL TFLAT(ZCONVF,4,IELEM1(JE),IELEM2(JE),ADD1,ADD2,
     -         FACTTF(1,JE),FACTTF(2,JE))
      ELSE IF((IELEM1(JE).EQ.1).AND.(IELEM2(JE).EQ.1)) THEN
         CALL TFLAT(ZCONVF,4,IELEM1(JE),IELEM2(JE),ADD1,ADD1,
     -         FACTTF(1,JE),FACTTF(2,JE))
      ELSE IF((IELEM1(JE).EQ.1).AND.(IELEM2(JE).EQ.0)) THEN
         CALL TFLAT(ZCONVF,4,IELEM1(JE),IELEM2(JE),ADD1,ADD0,
     -         FACTTF(1,JE),FACTTF(2,JE))
      ENDIF
100   CONTINUE
1000  CONTINUE

      REWIND NCTF1
      REWIND NCTF2

      RETURN
      END
      SUBROUTINE TFSUMM(PTFG,KDIM1,KDIM2,PFACT1,PFACT2,PFNC1,PFNC2,
     -      KELEM1,KELEM2)
**    Function - To compute summations required in the calculation of
**          the transient fluxes - each call to this routine processes
**          one transient flux equation, at a single latitude.
**    Args in -
**               PTFG    - Array of KDIM2 gridpoint fields required by
**                         the current equation.
**               KDIM1   - First dimension of PTFG (number of elements
**                         per gridpoint field)
**               KDIM2   - Second dimension of PTFG
**               PFACT1  - First multiplicative factor in equation
**               PFACT2  - Second multiplicative factor in equation
**               PFNC1   - Function required to process first term in
**                         the equation
**               PFNC2   - Function required to process second term in
**                         the equation
**               KELEM1  - Number of elements in the first term of the
**                         equation
**               KELEM2  - Number of elements in the second term of the
**                         equation
**    Args out - none
**    Args for work - none
**    Com used - /COMIOC/NCTF1,NCTF2,/TFCNST/NPER
**    Com changed - /CWORK/WORK3D
**    Params used - /PARAM1/JPNL,JPMG,JPNHEM,/PARAM2/JPIGC,JPMGPP,
**          JPIGD,/PARAM3/JPTFMX
**    Called by - TFCONT
**    Calls - PFNC1,PFNC2 (eg ADD0, ADD1 or ADD2),ABORT
**    Files read - NCTF1
**    Files written - NCTF2
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL,
     -      JPJGM=JPJG-1,JPJGP=JPJG+1,JPNWP=1+JPMM/JPMOCT,
     -      JPMOCTP=JPMOCT+1,
     -      JPIDD=JPMGPP*JPNL,JPIDH=JPMGP*JPJGGP,JPIDN=JPIDM*JPNL,
     -      JPIGM=JPIDM*JPNHEM,JPIGN=JPIDN*JPNHEM)
      PARAMETER(JPPHMX=12,JPXPMX=38,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCSURF,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCDYN3,
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP,NCGP(3)
      COMMON /CWORK/WGP2D1(JPMGPP,JPJGGP),WGP2D2(JPMGPP,JPJGGP),
     -      WGP2D3(JPMGPP,JPJGGP),WGP2D4(JPMGPP,JPJGGP),
     -      WORKM(JPMGPP*JPNHEM,JPNLP),WORK3D(JPMGPP*JPJG*JPNHEM*JPNL)
      LOGICAL LTFLEV,LTFTRC,LTFGLB
      CHARACTER*50 YNAMTF
      COMMON /TFCNST/LTFLEV(JPNL),LTFTRC,LTFGLB,NPER,NLOWPB,NSAMLP,
     -      YNAMTF(3,JPTFMX)
      DIMENSION PTFG(JPIGC,JPNL,4)
      DIMENSION ZTFAVG(JPIGD,10)
      EQUIVALENCE (ZTFAVG(1,1),WORK3D(1))
      DIMENSION ZTFAV2(JPIGC,JPNL,10)
      EQUIVALENCE (ZTFAV2(1,1,1),ZTFAVG(1,1))

**    Check dimensions
      IF(JPIGD.NE.KDIM1) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***TFSUMM ERROR - INVALID DIMENSIONS; ABORT')
         CALL ABORT
      ENDIF
**    WARNING: Equivalencing of ZTFAVG with WORK3D may fail if
**    model arrays contain too few latitudes
      IF(10.GT.JPJG) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***TFSUMM: ERROR - FEWER THAN 10 LATITUDES IN ',
     -         'EACH HEMISPHERE MEANS ZTFAVG INCORRECTLY ',
     -         /'EQUIVALENCED; ABORT CALLED')
         CALL ABORT
      ENDIF
      IF(4.NE.KDIM2) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'***TFSUMM ERROR - INVALID DIMENSIONS (KDIM2);',
     -         ' ABORT')
         CALL ABORT
      ENDIF

**    Read the contents of file NCTF1, incorporate contributions of
**    current latitude fields, and write the results to NCTF2.
      READ (NCTF1) ZTFAVG
**    Contribution from first term in the equation
      ZFAIL=PFNC1(PFACT1,PTFG(1,1,1),PTFG(1,1,2),ZTFAVG(1,1),JPIGD)
      IF(KELEM1.EQ.2) THEN
         IF(JPNHEM.EQ.1) THEN
            DO 100 JL=1,JPNL
            DO 100 JI=1,JPMG
            ZTFAV2(JI,JL,2)=ZTFAV2(JI,JL,2)+PTFG(JI,JL,1)
            ZTFAV2(JI,JL,3)=ZTFAV2(JI,JL,3)+PTFG(JI,JL,2)
100         CONTINUE
         ELSE
            DO 101 JL=1,JPNL
            DO 101 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,2)=ZTFAV2(JI,JL,2)+PTFG(JI,JL,1)
            ZTFAV2(JI,JL,3)=ZTFAV2(JI,JL,3)+PTFG(JI,JL,2)
            ZTFAV2(JIP,JL,2)=ZTFAV2(JIP,JL,2)+PTFG(JIP,JL,1)
            ZTFAV2(JIP,JL,3)=ZTFAV2(JIP,JL,3)+PTFG(JIP,JL,2)
101         CONTINUE
         ENDIF
      ELSE IF(KELEM1.EQ.1) THEN
         IF(JPNHEM.EQ.1) THEN
            DO 200 JL=1,JPNL
            DO 200 JI=1,JPMG
            ZTFAV2(JI,JL,2)=ZTFAV2(JI,JL,2)+PTFG(JI,JL,1)
200         CONTINUE
         ELSE
            DO 201 JL=1,JPNL
            DO 201 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,2)=ZTFAV2(JI,JL,2)+PTFG(JI,JL,1)
            ZTFAV2(JIP,JL,2)=ZTFAV2(JIP,JL,2)+PTFG(JIP,JL,1)
201         CONTINUE
         ENDIF
      ENDIF
**    Contribution from second term in the equation
      IF(KELEM2.EQ.2) THEN
         ZFAIL=PFNC2(PFACT2,PTFG(1,1,3),PTFG(1,1,4),ZTFAVG(1,1),JPIGD)
         IF(JPNHEM.EQ.1) THEN
            DO 300 JL=1,JPNL
            DO 300 JI=1,JPMG
            ZTFAV2(JI,JL,4)=ZTFAV2(JI,JL,4)+PTFG(JI,JL,3)
            ZTFAV2(JI,JL,5)=ZTFAV2(JI,JL,5)+PTFG(JI,JL,4)
300         CONTINUE
         ELSE
            DO 301 JL=1,JPNL
            DO 301 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,4)=ZTFAV2(JI,JL,4)+PTFG(JI,JL,3)
            ZTFAV2(JI,JL,5)=ZTFAV2(JI,JL,5)+PTFG(JI,JL,4)
            ZTFAV2(JIP,JL,4)=ZTFAV2(JIP,JL,4)+PTFG(JIP,JL,3)
            ZTFAV2(JIP,JL,5)=ZTFAV2(JIP,JL,5)+PTFG(JIP,JL,4)
301         CONTINUE
         ENDIF
      ELSE IF(KELEM2.EQ.1) THEN
**       PTFG( ,4) used as a dummy argument
         ZFAIL=PFNC2(PFACT2,PTFG(1,1,3),PTFG(1,1,4),ZTFAVG(1,1),JPIGD)
         IF(JPNHEM.EQ.1) THEN
            DO 400 JL=1,JPNL
            DO 400 JI=1,JPMG
            ZTFAV2(JI,JL,4)=ZTFAV2(JI,JL,4)+PTFG(JI,JL,3)
400         CONTINUE
         ELSE
            DO 401 JL=1,JPNL
            DO 401 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,4)=ZTFAV2(JI,JL,4)+PTFG(JI,JL,3)
            ZTFAV2(JIP,JL,4)=ZTFAV2(JIP,JL,4)+PTFG(JIP,JL,3)
401         CONTINUE
         ENDIF
      ENDIF

      IF(NPER.EQ.NSAMLP) THEN
**       Current sample is the last in current low-pass block.
**       Contribution from first term in the equation
         IF(KELEM1.EQ.2) THEN
         IF(JPNHEM.EQ.1) THEN
            DO 1100 JL=1,JPNL
            DO 1100 JI=1,JPMG
            ZTFAV2(JI,JL,7)=ZTFAV2(JI,JL,7)+ZTFAV2(JI,JL,2)
            ZTFAV2(JI,JL,8)=ZTFAV2(JI,JL,8)+ZTFAV2(JI,JL,3)
1100        CONTINUE
         ELSE
            DO 1101 JL=1,JPNL
            DO 1101 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,7)=ZTFAV2(JI,JL,7)+ZTFAV2(JI,JL,2)
            ZTFAV2(JI,JL,8)=ZTFAV2(JI,JL,8)+ZTFAV2(JI,JL,3)
            ZTFAV2(JIP,JL,7)=ZTFAV2(JIP,JL,7)+ZTFAV2(JIP,JL,2)
            ZTFAV2(JIP,JL,8)=ZTFAV2(JIP,JL,8)+ZTFAV2(JIP,JL,3)
1101        CONTINUE
         ENDIF
            ZFAIL=PFNC1(PFACT1,ZTFAVG(1,2),ZTFAVG(1,3),
     -            ZTFAVG(1,6),JPIGD)
            DO 1150 J=1,JPIGD
            ZTFAVG(J,2)=0.0
            ZTFAVG(J,3)=0.0
1150        CONTINUE
         ELSE IF(KELEM1.EQ.1) THEN
         IF(JPNHEM.EQ.1) THEN
            DO 1200 JL=1,JPNL
            DO 1200 JI=1,JPMG
            ZTFAV2(JI,JL,7)=ZTFAV2(JI,JL,7)+ZTFAV2(JI,JL,2)
1200        CONTINUE
         ELSE
            DO 1201 JL=1,JPNL
            DO 1201 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,7)=ZTFAV2(JI,JL,7)+ZTFAV2(JI,JL,2)
            ZTFAV2(JIP,JL,7)=ZTFAV2(JIP,JL,7)+ZTFAV2(JIP,JL,2)
1201        CONTINUE
         ENDIF
            ZFAIL=PFNC1(PFACT1,ZTFAVG(1,2),ZTFAVG(1,3),
     -            ZTFAVG(1,6),JPIGD)
            DO 1250 J=1,JPIGD
            ZTFAVG(J,2)=0.0
1250        CONTINUE
         ENDIF
**       Contribution from second term in the equation
         IF(KELEM2.EQ.2) THEN
         IF(JPNHEM.EQ.1) THEN
            DO 1300 JL=1,JPNL
            DO 1300 JI=1,JPMG
            ZTFAV2(JI,JL,9)=ZTFAV2(JI,JL,9)+ZTFAV2(JI,JL,4)
            ZTFAV2(JI,JL,10)=ZTFAV2(JI,JL,10)+ZTFAV2(JI,JL,5)
1300        CONTINUE
         ELSE
            DO 1301 JL=1,JPNL
            DO 1301 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,9)=ZTFAV2(JI,JL,9)+ZTFAV2(JI,JL,4)
            ZTFAV2(JI,JL,10)=ZTFAV2(JI,JL,10)+ZTFAV2(JI,JL,5)
            ZTFAV2(JIP,JL,9)=ZTFAV2(JIP,JL,9)+ZTFAV2(JIP,JL,4)
            ZTFAV2(JIP,JL,10)=ZTFAV2(JIP,JL,10)+ZTFAV2(JIP,JL,5)
1301        CONTINUE
         ENDIF
            ZFAIL=PFNC2(PFACT2,ZTFAVG(1,4),ZTFAVG(1,5),
     -            ZTFAVG(1,6),JPIGD)
            DO 1350 J=1,JPIGD
            ZTFAVG(J,4)=0.0
            ZTFAVG(J,5)=0.0
1350        CONTINUE
         ELSE IF(KELEM2.EQ.1) THEN
         IF(JPNHEM.EQ.1) THEN
            DO 1400 JL=1,JPNL
            DO 1400 JI=1,JPMG
            ZTFAV2(JI,JL,9)=ZTFAV2(JI,JL,9)+ZTFAV2(JI,JL,4)
1400        CONTINUE
         ELSE
            DO 1401 JL=1,JPNL
            DO 1401 JI=1,JPMG
            JIP=JI+JPMGPP
            ZTFAV2(JI,JL,9)=ZTFAV2(JI,JL,9)+ZTFAV2(JI,JL,4)
            ZTFAV2(JIP,JL,9)=ZTFAV2(JIP,JL,9)+ZTFAV2(JIP,JL,4)
1401        CONTINUE
         ENDIF
**          ZTFAVG( ,5) used as a dummy argument
            ZFAIL=PFNC2(PFACT2,ZTFAVG(1,4),ZTFAVG(1,5),
     -            ZTFAVG(1,6),JPIGD)
            DO 1450 J=1,JPIGD
            ZTFAVG(J,4)=0.0
1450        CONTINUE
         ENDIF
      ENDIF

**    Write out results to NCTF2
      WRITE(NCTF2) ZTFAVG

      RETURN
      END
      SUBROUTINE DVPCOR(KJH)
**    Function - If interpolating grid point fields from model to
**          isobaric levels, the routine corrects the model level
**          vorticity and divergence to those using gradient operator on
**          pressure surfaces, but leaves fields on model levels.
**    Args in -
**               KJH     - Current latitude
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/APG,/LEGAU/SECSQ,/COMPRL/DELTP,GLNPX,GLNPY,
**          /VERTCL/SIGMA,DSIGMA,/COMGRM/DUDLSG,DVDLSG
**    Com changed - /GRIDP/VOG,DG
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPMGPP,JPIGC
**    Called by - not currently used
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in
**          UFLUX2F

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,DEN(JPIGC,JPNL),ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP)
      LOGICAL LHYBTH
      COMMON /VERTCL/AETA(JPNLP),BETA(JPNLP),DPETA(JPNL),DBETA(JPNL),
     -      SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),SIGMAK(JPNL),
     -      SIGM1K(JPNL),RDSIG(JPNL),CETA(JPNLP),DETA(JPNLP),LHYBTH,
     -      SIGMA3(JPNL)

      DO 100 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 200 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 300 JI=1,JPMG
      IK=IOFL+IOF+JI
      II=JI+IOF
**    ZDETDP : d(eta)/dp
      ZDETDP=DSIGMA(JL)/DELTP(II,JL)
      VOG(IK)=VOG(IK)-(SECSQ(KJH)*ZDETDP*APG(IK)/SIGMA(JL))*
     -      (DVDLSG(II,JL)*GLNPX(II,JL)-DUDLSG(II,JL)*GLNPY(II,JL))
      DG(IK)=DG(IK)-(SECSQ(KJH)*ZDETDP*APG(IK)/SIGMA(JL))*
     -      (DUDLSG(II,JL)*GLNPX(II,JL)+DVDLSG(II,JL)*GLNPY(II,JL))
300   CONTINUE
200   CONTINUE
100   CONTINUE

      RETURN
      END
      SUBROUTINE DVTCOR(KJH)
**    Function - If interpolating grid point fields from model to
**          theta levels, the routine corrects the model level
**          vorticity and divergence to those using gradient operator on
**          theta surfaces, but leaves fields on model levels.
**    Args in -
**               KJH     - Current latitude
**    Args out - none
**    Args for work - none
**    Com used - /GRIDP/APG,TG,TXG,TYG,/LEGAU/SECSQ,
**          /COMPRL/DELTP,GLNPX,GLNPY,/VERTCL/SIGMA,DSIGMA,
**          /INVAR/AKAP,/COMGRM/DUDLSG,DVDLSG,DTDLSG
**    Com changed - /GRIDP/VOG,DG
**    Params used - /PARAM1/JPNL,JPNHEM,JPMG,/PARAM2/JPMGPP,JPIGC
**    Called by - not currently used
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL)
      COMMON /COMGRM/DUDLSG(JPIGC,JPNL),DVDLSG(JPIGC,JPNL),
     -      DTDLSG(JPIGC,JPNL),RGG(JPNL2),NINTRL(JPIGC,JPNLP)
      COMMON /COMPRL/ALNPSH(JPIGC,JPNL),APSGH(JPIGC,JPNLP),
     -      DELTP(JPIGC,JPNL),NCKPRL,APSGMX(JPNL,JPNHEM),
     -      APSGMN(JPNL,JPNHEM),XLAPSE,DEN(JPIGC,JPNL),ALPH(JPIGC,JPNL),
     -      GLNPX(JPIGC,JPNL),GLNPY(JPIGC,JPNL),APX(JPIGC,JPNLP),
     -      APY(JPIGC,JPNLP),TSRF(JPIGC),OMSRF(JPIGC),THSRF(JPIGC)
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,REFP0,ECMWFP,GA,RD,RV,CPD,CPV,AKAP,CLATNT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP)
      LOGICAL LHYBTH
      COMMON /VERTCL/AETA(JPNLP),BETA(JPNLP),DPETA(JPNL),DBETA(JPNL),
     -      SIGMAH(JPNLM),DSIGMA(JPNL),SIGMA(JPNL),SIGMAK(JPNL),
     -      SIGM1K(JPNL),RDSIG(JPNL),CETA(JPNLP),DETA(JPNLP),LHYBTH,
     -      SIGMA3(JPNL)

      DO 100 JL=1,JPNL
      IOFL=(JL-1)*JPIGC
      DO 200 JHEM=1,JPNHEM
      IOF=(JHEM-1)*JPMGPP
      DO 300 JI=1,JPMG
      IK=IOFL+IOF+JI
      II=JI+IOF

**    ZDETDP: d(eta)/dp
      ZDETDP=DSIGMA(JL)/DELTP(II,JL)

**    ZDENOM: d(T)/dp  - kappa.T/p
      ZDENOM=DTDLSG(II,JL)*ZDETDP/SIGMA(JL)-AKAP*TG(IK)/APG(IK)
      VOG(IK)=VOG(IK)-(SECSQ(KJH)*ZDETDP/SIGMA(JL))*
     -      ((TXG(IK)-AKAP*TG(IK)*GLNPX(II,JL))*DVDLSG(II,JL)-
     -      (TYG(IK)-AKAP*TG(IK)*GLNPY(II,JL))*DUDLSG(II,JL))/ZDENOM
      DG(IK)=DG(IK)-(SECSQ(KJH)*ZDETDP/SIGMA(JL))*
     -      ((TXG(IK)-AKAP*TG(IK)*GLNPX(II,JL))*DUDLSG(II,JL)-
     -      (TYG(IK)-AKAP*TG(IK)*GLNPY(II,JL))*DVDLSG(II,JL))/ZDENOM
300   CONTINUE
200   CONTINUE
100   CONTINUE

      RETURN
      END
      SUBROUTINE LEVCHK(PLEV,KDIM,PDEFLT,YPDIAG,KERR,LPERR,PMIN,PMAX)
**    Function - to check validity of horizontal level values
**    Args in -
**               PLAT    - Level value(s)
**               KDIM    - Number of level values input
**               PDEFLT  - Default values to be used if input
**                         values are incorrect
**               YPDIAG  - Diagnostics for which levels are being
**                         checked
**               KERR    - 1 if LPERR to be set to .TRUE. when an
**                         error is detected; else 0
**               LPERR   - error flag (set before call)
**               PMIN    - (range of P values that PLEV
**               PMAX    - (should lie between
**    Args out -
**               PLAT    - Level value(s)
**               LPERR   - set to .TRUE. if KERR=1 and an error detected
**                         in this routine
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - not currently used
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PLEV(KDIM)
      LOGICAL LPERR
      CHARACTER*(*) YPDIAG

      IF(KDIM.EQ.1) THEN
         IF((PLEV(1).GT.PMAX).OR.(PLEV(1).LT.PMIN)) THEN
            IF(PLEV(1).NE.PDEFLT) THEN
               PRINT 6000,YPDIAG
6000           FORMAT(1X,'WARNING: ARE ',A,
     -               ' LEVELS SET CORRECTLY?')
               IF(KERR.EQ.1) LPERR=.TRUE.
            ENDIF
         ENDIF
      ELSE IF(KDIM.EQ.2) THEN
         IF((PLEV(1).LT.PMIN).OR.(PLEV(2).GT.PMAX).OR.
     -         (PLEV(2).LT.PMIN).OR.(PLEV(1).GT.PMAX).OR.
     -         (PLEV(1).GT.PLEV(2))) THEN
            IF((PLEV(1).NE.PDEFLT).OR.PLEV(2).NE.PDEFLT) THEN
               PRINT 6000,YPDIAG
               IF(KERR.EQ.1) LPERR=.TRUE.
               IF(PLEV(2).LT.PLEV(1)) THEN
                  PLEV(1)=PDEFLT
                  PLEV(2)=PDEFLT
               ENDIF
            ENDIF
         ENDIF
         IF((PLEV(1).EQ.PDEFLT).OR.PLEV(2).EQ.PDEFLT) THEN
            PLEV(1)=PDEFLT
            PLEV(2)=PDEFLT
         ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE SFCHG
**    Function - Obtain gridpoint streamfunction from gridpoint
**          vorticity, and gridpoint velocity potential from gridpoint
**          divergence. The routine is used to compute fields on non-sigma
**          surfaces. The same level type and definition of gradient
**          operator are used in all four fields.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - /INVAR/EZ,/COMFFT/WORK,TRIG,MFAX,/LEGAU/JINC,
**          /COMIOC/NCLEG,NCGP,/COMNGP/NR1VO,NR1D,/COMMSK/AMSKV
**    Com changed - /SPECTR/VO,D,/GRIDP/VOG,DG,CHIG,SFG,/LEGAU/
**          ALP,DALP,RLP
**    Params used - /PARAM1/JPNL,JPNHEM,JPJG,JPJGL,JPCRAY,JPMG,JPNWJ2,
**          /PARAM2/JPMGPP,JPIGA,JPIGB,JPIGD,/PARAM3/JPTRMX
**    Called by - not currently used
**    Calls - FFT991,HANAL,HEXP,WRITSG
**    Files read - NCLEG,NCGP(1)
**    Files written - none
**    Author - R Brugge, University of Reading, based on code in SFGCPR
**    in UFLUX2F

      PARAMETER(JPNN=31,JPMM=31,JPNHEM=2,JPMOCT=1,JPNL=10,JPMG=96,
     -      JPJG=24,JPNWJ2=256,JPJGL=JPJG,JPCRAY=64,
     -      JPMFDM=4,JPSFDM=1,JPTRUP=1,JPTRDN=1)
      PARAMETER (JPJGG=JPJG*JPNHEM,JPMJP=JPNWJ2+JPNWJ2,JPJGGP=JPJGG+1,
     -      JPJGG2=JPJGG-2,JPJGGM=JPJGG-1,JPNNP=JPNN+1,JPNLP=JPNL+1,
     -      JPNLM=JPNL-1,JPIDG=JPJG*JPNL,JPIGG=JPIDG*JPNHEM,
     -      JPMGP=JPMG+1,JPMGPP=JPMG+2,JPIGC=JPMGPP*JPNHEM,JPMH=2,
     -      JPIGA=JPNWJ2*JPNHEM,JPNWW=1+(JPMM-1)/JPMOCT,
     -      JPIDL=JPMGPP/2,JPIGL=JPIDL*JPNHEM,JPIDF=JPCRAY*JPMGP,
     -      JPNLWG=11*JPNL+3,JPIDA=3*JPMG/2+1,JPIDM=JPNNP/2,
     -      JPIGB=JPIGA*JPNL,JPIGD=JPNHEM*JPMGPP*JPNL,
     -      JPIDK=JPIDL*JPNL,JPIGK=JPIDK*JPNHEM,JPNL2=JPNL*JPNL)
      PARAMETER(JPPHMX=66,JPXPMX=28,JPXP2=2*JPXPMX,JPIDMX=39,JPCOMX=6,
     -      JPSGMX=21,JPGPPF=10,JPGP3D=18,JPGPSF=5,JPGPHL=1,
     -      JPTRMX=50,JPTPPF=10,JPTRF=101,JPTRL=100+JPTRMX,
     -      JPTFMX=10,JPFPPF=10,JPODMX=7,JPOPPF=10,JPZFMX=10,
     -      JPTJMX=JPSGMX+JPTRMX)
      COMMON/COMFFT/NTWG,NRSTWG,NTNL,NRSTNL,TRIG(JPIDA),
     -      WORK(JPIDF),MFAX(10)
      COMMON /COMIOC/NCLEG,NCFICH,NCNAME,NCUTF,NCHIST,NCPHY1,NCPHY2,
     -      NCPHY3,NCPHY4,NCPHY5,NCROGS,NCROGG,NCDYN1,NCDYN2,NCGP(3),
     -      NCGPAC(3),NCGPAV(3),NCGPTS,NCSGSW,NCGHTS,NCGZTS,NCGMTS,
     -      NCAIRM,NCTRC,NCTRAC,NCTRAV,NCTPTS,NCTHTS,NCTZTS,NCTMTS,
     -      NCTF1,NCTF2,NCOPTS,NCOHTS,NCOZTS,NCOMTS,NCODAC,NCODAV,
     -      NCODC,NCETWK,NCZFWK,NCTJIN,NCTJOP
      PARAMETER(JPNLL=1+(JPNL-1)*(JPJGL/JPJG))
      CHARACTER*50 YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMMSK/APHMSK(JPMG,JPJGG),AZMSK(JPJGG,2),AMMSK(JPMG,2),
     -      NFLGLL(2),NFLGZM(2),NFLGMM(2),AMSKV,AMSKVC,
     -      AIRLL(JPMG,JPJGG,JPNLL),
     -      YMNAMH,YMNAMZ,YMNAMM
      COMMON /COMNGP/NRSZ3D,NRSZSF,NRSZHL,NR1SF,NR1CHI,NR1VO,NR1D,NR1OM,
     -      NR1U,NR1V,NR1T,NR1GH,NR1Q,NR1H,NR1AP,NR1TH,NR1EPV,NR1FU,
     -      NR1FV,NR1PSF,NR1PSL,NR1APJ,NR1APM,NR1PHL,NR1MSF,NR1THS,
     -      NR1ALM,NRSZ3A,NRSZSA,NRSZHA,NRMSK2,NRMSK3,NR1TR(JPTRMX),
     -      NR1RHG,NR1MMG,NR1SPG,NR1ELG,NR1NAG,NR1UGG,NR1VGG
      COMMON /GRIDP/UG(JPIGD),VG(JPIGD),VOG(JPIGD),DG(JPIGD),QG(JPIGD),
     -      HG(JPIGD),TG(JPIGD),APSFCG(JPIGC),TYG(JPIGD),APJG(JPIGC),
     -      TXG(JPIGD),APMG(JPIGC),SFG(JPIGD),CHIG(JPIGD),OMG(JPIGD),
     -      GHG(JPIGD),APG(JPIGD),THG(JPIGD),EPVG(JPIGD),APMSLG(JPIGC),
     -      FUG(JPIGD),FVG(JPIGD),AMSFG(JPIGD),THSFCG(JPIGC),
     -      AIRG(JPIGD)
      COMPLEX EZ
      COMMON /INVAR/GPI,REFP0,ECMWFP,GA,RD,RV,CPD,CPV,AKAP,CLATNT,
     -      WROTAT,RADEA,CV,CG,CT,CTKAP,EZ,AVOGAD,DOBFAC,AMWAIR
      COMMON /LEGAU/ALP(JPMJP,JPJGL),DALP(JPMJP,JPJGL),
     -      RLP(JPMJP,JPJGL),RDLP(JPMJP,JPJGL),
     -      JINC,SI(JPJGG),SISQ(JPJGG),CSSQ(JPJGG),CS(JPJGG),
     -      GWT(JPJGG),SECSQ(JPJGG),AW(JPJGG),ALAT(JPJGG),
     -      EXN1,EXN2,EXS1,EXS2,EXE1,EXE2,EXE3,
     -      ALATBY(JPJGGP)
      PARAMETER(ISPAD=2600)
      COMPLEX VO,D,T,Q,H,SP,GS
      COMMON /SPECTR/VO(JPIGB),D(JPIGB),Q(JPIGB),H(JPIGB),T(JPIGB),
     -      SP(JPIGA),SPAD(ISPAD),GS(JPIGA)
      DIMENSION ZING(2*JPIGD),ZOUTG(2*JPIGD)
      EQUIVALENCE (ZING(1),VOG(1)),(ZOUTG(1),SFG(1))

**    ZING equivalenced to VOG and DG to speed up FFT; likewise ZOUTG
**    equivalenced to SFG and CHIG.
      INTRNL=(2*JPNL*JPNHEM)
      ITNL=(INTRNL-1)/JPCRAY
      IRSTNL=INTRNL-JPCRAY*ITNL

**    Preset spectral arrays to zero
      DO 10 JI=1,JPIGB
      VO(JI)=CMPLX(0.0,0.0)
      D(JI)=CMPLX(0.0,0.0)
10    CONTINUE

      IL=1
      IF (JPJGL.EQ.1) REWIND NCLEG

**    Direct transform to obtain spectral values
      DO 50 JIH=1,JPJG
      IF (JPJGL.EQ.1) READ(NCLEG) ALP
      READ(NCGP(1),REC=NR1VO+JIH-1)VOG
      READ(NCGP(1),REC=NR1D+JIH-1)DG
      IF (ITNL.NE.0) THEN
         DO 20 JI=1,ITNL
         CALL FFT991(ZING(1+(JI-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX,
     -         1,JPMGPP,JPMG,JPCRAY,-1)
20       CONTINUE
      ENDIF
      CALL FFT991(ZING(1+ITNL*JPCRAY*JPMGPP),WORK,TRIG,MFAX,
     -      1,JPMGPP,JPMG,IRSTNL,-1)
      IJH=JIH
      CALL HANAL(VOG,VO,JPNL,1,IJH,IL)
      CALL HANAL(DG,D,JPNL,2,IJH,IL)
      IL=IL+JINC
50    CONTINUE

**    Indirect transform back to grid point space, performing the
**    (del)**(-2) operation to obtain streamfunction and velocity
**    potential. Set divergence global mean to zero. Vorticity includes
**    planetary component, so temporarily remove. Set (m=0,n=0)
**    vorticity coefficient to zero at all levels.
      DO 60 JI=1,JPIGB,JPIGA
      D(JI)=CMPLX(0.0,0.0)
      VO(JI)=VO(JI)-EZ
60    CONTINUE
      IF (JPNHEM.EQ.2) THEN
         DO 70 JI=JPNWJ2+1,JPIGB,JPIGA
         VO(JI)=0.0
70       CONTINUE
      ENDIF

      IL=1
      IF (JPJGL.EQ.1) REWIND NCLEG

      DO 100 JIH=1,JPJG
      IF (JPJGL.EQ.1) READ(NCLEG) ALP,DALP,RLP
      CALL HEXP(VO,SFG,JPNL,5,IL)
      CALL HEXP(D,CHIG,JPNL,6,IL)
      IF (ITNL.NE.0) THEN
         DO 80 JI=1,ITNL
         CALL FFT991(ZOUTG(1+(JI-1)*JPCRAY*JPMGPP),WORK,TRIG,MFAX,
     -         1,JPMGPP,JPMG,JPCRAY,1)
80       CONTINUE
      ENDIF
      CALL FFT991(ZOUTG(1+ITNL*JPCRAY*JPMGPP),WORK,TRIG,MFAX,
     -      1,JPMGPP,JPMG,IRSTNL,1)

**    Now write current latitude values of SFG and CHIG to scratch
      IJH=JIH
      CALL WRITSG(.TRUE.,.TRUE.,.FALSE.,.FALSE.,.FALSE.,IJH)
      IL=IL+JINC
100   CONTINUE

**    Add planetary vorticity component back
      DO 110 JI=1,JPIGB,JPIGA
      VO(JI)=VO(JI)+EZ
110   CONTINUE

      RETURN
      END
****************UMAPLIB13 ROUTINES
      SUBROUTINE ARBNDS(PARRAY, KPTS, PMIN, PMAX, KFAIL)
**    Function - Finds the maximum and minimum values of an array,
**          checks for a zero range of the array, and sets an error
**          flag to -1 if the minimum value of the array is negative.
**    Args in -
**               PARRAY  - Array to be processed.
**               KPTS    - Dimension of PARRAY.
**               KFAIL   - Error flag.
**    Args out -
**               PMIN    - Minimum value in array.
**               PMAX    - Maximum value in the array.
**               KFAIL   - Error flag. Set to 1 if array
**                         has zero range or to -1 if minimum value
**                         is negative.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by -
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code
**          by Glenn Carver (ACMG) and Jeff Cole (CGAM).

      DIMENSION PARRAY(KPTS)

      PMIN = PARRAY(1)
      PMAX = PMIN
      DO 100 J = 2, KPTS
         PMIN = AMIN1( PMIN, PARRAY(J) )
         PMAX = AMAX1( PMAX, PARRAY(J) )
 100  CONTINUE
      ZRANGE = PMAX - PMIN
      ZAMAX = AMAX1( ABS(PMIN), ABS(PMAX) )
      IF ( ZRANGE .LE. ZAMAX*1.0E-3 ) THEN
         WRITE (6, 6001)
6001     FORMAT (1X, '** WARNING IN ARBNDS: FIELD HAS ZERO RANGE.'/)
         KFAIL = 1
      ENDIF
      IF ( PMIN .LE. 0.0 ) KFAIL = -1

      RETURN
      END
      SUBROUTINE ATRUNC(PX,KIDIM,KJDIM,KOIDIM,KOJDIM)
**    Function - to remove unwanted data from an array, and to compress
**          together the array elements
**    Args in -
**               PX      - array
**               KIDIM   - first dimension of PX
**               KJDIM   - second dimension of PX
**               KOIDIM  - number of elements of data to be retained
**                         in the first dimension. It is assumed that
**                         the first KOIDIM elements are required.
**               KOJDIM  - number of elements of data to be retained
**                         in the second dimension. It is assumed
**                         that the first KOJDIM elements are required.
**    Args out -
**               PX      - modified array containing required data in
**                         the first KOIDIM*KOJDIM elements.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Called by - OPPHTS,OPSGTS,OPXPTS,OPTRTS
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R.Brugge, University of Reading

      DIMENSION PX(KIDIM*KJDIM)

**    The required data will be compressed to fill the first KOIDIM*
**          KOJDIM elements of the array

      IF(KIDIM.EQ.KOIDIM.AND.KJDIM.EQ.KOJDIM) RETURN

      IOELEM=0
      DO 100 J=1,KOJDIM
      DO 100 JI=1,KOIDIM
      IOELEM=IOELEM+1
      INELEM=(J-1)*KIDIM+JI
      PX(IOELEM)=PX(INELEM)
100   CONTINUE

      RETURN
      END
      SUBROUTINE AWI(KDLONI,KLONI,PLONI,KLATI,PLATI,PDATAI,PMASK,PFILL,
     -      KDLONO,KLONO,PLONO,KLATO,PLATO,PDATAO,KERR,LPSUM)
**    Function - This subroutine does an area weighted average from one
**          grid, on a spherical earth, to another. A masking array is
**          used to specify those input data points that are to be used
**          in the averaging process.
**          Restrictions:  Longitude must be the first dimension and it
**                         be monotonically increasing (West to East).
**                         Latitude must be the second dimension and it
**                         must be monotonic.
**                         Values for longitude and latitude must be in
**                         degrees.
**                         Arrays that wrap around must repeat
**                         longitudes with a 360 degree increment.  It
**                         will be assumed that values in the wrapped
**                         input  array will also repeat (wrapped values
**                         in these arrays will not be used).
**    Args in -
**               KDLONI  - First dimension of input PDATAI and PMASK
**               KLONI   - Number of grid boxes in longitude for PDATAI
**                         and PMASK
**               PLONI   - Longitude (deg) limits of grid boxes for
**                         PDATAI and PMASK
**               KLATI   - Number of grid boxes in latitude for PDATAI
**                         and PMASK
**               PLATI   - Latitude (deg) limits of grid boxes for
**                         PDATAI and PMASK
**               PDATAI  - Array of input data
**               PMASK   - Real mask array whose elements
**                         correspond to those elements of PDATAI
**               PFILL   - Value to be assigned to output gridpoint data
**                         value in the event that it contains no
**                         computed value.
**               KDLONO  - First dimension of output PDATAO
**               KLONO   - Number of grid boxes in longitude for PDATAO
**               PLONO   - Longitude (deg) limits of grid boxes for
**                         PDATAO
**               KLATO   - Number of grid boxes in latitude for PDATAO
**               PLATO   - Latitude (deg) limits of grid boxes for
**                         PDATAO
**               LPSUM   - .TRUE. if area sum to be computed, else area-
**                         averages are returned in PDATAO
**    Args out - none
**               PDATAO  - Array of output data
**               KERR    - Error indication (values may be summed for
**                         multiple errors):
**                            0  no errors
**                            1  input longitude dimension and/or length
**                               <=0
**                            2  output dimension and/or length <=0
**                            4  input latititude dimension <=0
**                            8  output latitude dimension <=0
**                           16  wrap-around on input longitude grid
**                               doesn't repeat (+360)
**                           32  wrap-around on output longitude grid
**                               doesn't repeat (+360)
**                           64  longitude of input is not monotonic
**                               increasing
**                          128  longitude of output is not monotonic
**                               increasing
**                          256  latitude of input is not monotonic
**                          512  latitude of output is not monotonic
**                         1024  input longitude wraps but doesn't
**                               repeat identically
**                         2048  output longitude wraps but doesn't
**                               repeat identically
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - BOXAV
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code
**          by Peter Glecker (of Lawrence Livermore Lab.)

      LOGICAL LPSUM
      DIMENSION PMASK(KDLONI,KLATI)
      DIMENSION PLONI(KLONI+1),PLATI(KLATI+1),PLONO(KLONO+1),
     -      PLATO(KLATO+1)
      DIMENSION PDATAI(KDLONI,KLATI),PDATAO(KDLONO,KLATO)

      ZPI=ATAN2(0.0,-1.0)

**    Check dimensions and lengths.
      KERR=0
      IF (KDLONI.LT.KLONI.OR.KLONI.LE.0) KERR=1
      IF (KDLONO.LT.KLONO.OR.KLONO.LE.0) KERR=KERR+2
      IF (KLATI.LE.0) KERR=KERR+4
      IF (KLATO.LE.0) KERR=KERR+8
      IF (KERR.GT.0) RETURN

**    Check monotonic increasing input longitudes.
      DO 100 J=2,KLONI
      IF(PLONI(J).LE.PLONI(J-1)) THEN
         KERR=KERR+64
         GO TO 200
      ENDIF
100   CONTINUE
200   CONTINUE

**    Check monotonic increasing output longitudes.
      DO 301 J=2,KLONO
      IF(PLONO(J).LE.PLONO(J-1)) THEN
         KERR=KERR+128
         GO TO 400
      ENDIF
301   CONTINUE
400   CONTINUE

**    Check monotonicity of input latitudes.
      ZSGN=(PLATI(2)-PLATI(1))
      DO 501 J=2,KLATI
      IF(ZSGN.LT.0.0) THEN
         IF(PLATI(J)-PLATI(J-1).GE.0) THEN
            KERR=KERR+256
            GO TO 600
         ENDIF
      ELSE IF(ZSGN.GT.0.0) THEN
         IF(PLATI(J)-PLATI(J-1).LE.0.0) THEN
            KERR=KERR+256
            GO TO 600
         ENDIF
      ELSE
        KERR=KERR+256
        GO TO 600
      ENDIF
501   CONTINUE
600   CONTINUE

**    Check monotonicity of output latitudes.
      ZSGN=(PLATO(2)-PLATO(1))
      DO 700 J=2,KLATO
      IF(ZSGN.LT.0.0) THEN
         IF(PLATO(J)-PLATO(J-1).GE.0.0) THEN
            KERR=KERR+512
            GO TO 800
         ENDIF
      ELSE IF(ZSGN.GT.0.0) THEN
         IF(PLATO(J)-PLATO(J-1).LE.0.0) THEN
            KERR=KERR+512
            GO TO 800
         ENDIF
      ELSE
         KERR=KERR+512
         GO TO 800
      ENDIF
700   CONTINUE
800   CONTINUE

**    Find wrap around of input grid, if it exists.
      IKLONI=KLONI
      ZALMX=PLONI(1)
      ZALMN=PLONI(1)
      DO 1000 I=2,KLONI+1
      ZALMX=MAX(ZALMX,PLONI(I))
      ZALMN=MIN(ZALMN,PLONI(I))
      ZAL=ABS(PLONI(I)-PLONI(1))-360.0
      IF(ABS(ZAL).LE.1.E-3) THEN
         IKLONI=I-1
         GO TO 1100
      ELSE IF(ZAL.GT.0.0) THEN
         KERR=KERR+1024
         GO TO 1200
      ENDIF
1000  CONTINUE
1100  CONTINUE
      ZDLN=0.0
      IF(ZALMN.LT.0.0) THEN
         ZDLN=INT(-ZALMN/360.0+.001)*360.0
      ELSE IF(ZALMN.GT.360.0) THEN
         ZDLN=-INT(ZALMN/360.0+.001)*360.0
      ENDIF
1200  CONTINUE

**    Find wrap around of output grid, if it exists.
      IKLONO=KLONO
      ZALMXO=PLONO(1)
      ZALMNO=PLONO(1)
      DO 1300 I=2,KLONO+1
      ZALMXO=MAX(ZALMXO,PLONO(I))
      ZALMNO=MIN(ZALMNO,PLONO(I))
      ZAL=ABS(PLONO(I)-PLONO(1))-360.0
      IF(ABS(ZAL).LE.1.E-3) THEN
         IKLONO=I-1
         GO TO 1400
      ELSE IF(ZAL.GT.0.0) THEN
         KERR=KERR+2048
         GO TO 1500
      ENDIF
1300  CONTINUE
1400  CONTINUE
      ZDLNO=0.0
      IF(ZALMNO.LT.0.0) THEN
         ZDLNO=INT(-ZALMNO/360.0+.001)*360.0
      ELSE IF(ZALMNO.GT.360.0) THEN
         ZDLNO=-INT(ZALMNO/360.0+.001)*360.0
      ENDIF
1500  CONTINUE

**    Test for errors.  Return if any exist.
      IF(KERR.NE.0) RETURN

**    The output grid needs to begin with or after the input grid.
      IF(ZALMNO+ZDLNO.LT.ZALMN+ZDLN) ZDLNO=ZDLNO+360.0

      DO 2000 J=1,KLATO
**    Find index limits in latitude to cover the new grid.
      J1=KLATI+1
      J2=0
      ZMNLTO=MIN(PLATO(J),PLATO(J+1))
      ZMXLTO=MAX(PLATO(J),PLATO(J+1))

**    Search for index limits in J
      DO 1700 JJ=1,KLATI
      ZMNLT=MIN(PLATI(JJ),PLATI(JJ+1))
      ZMXLT=MAX(PLATI(JJ),PLATI(JJ+1))

**    Find JJ limits
      IF(ZMXLT.GT.ZMNLTO.AND.ZMNLT.LT.ZMXLTO) THEN
         J1=MIN(JJ,J1)
         J2=MAX(JJ,J2)
      ENDIF
1700  CONTINUE

**    If input grid doesn't at least partially cover the
**          output grid box, no values will be assigned
**
      IF(J2.LT.J1) THEN
         DO 201 JI=1,IKLONO
         PDATAO(JI,J)=PFILL
201      CONTINUE
         GO TO 2000
      ENDIF

      DO 7100 JI=1,IKLONO
**    Find index limits in longitude to cover the new grid
      I1=3*KLONI+1
      I2=0
      ZMNLNO=MIN(PLONO(JI),PLONO(JI+1))+ZDLNO
      ZMXLNO=MAX(PLONO(JI),PLONO(JI+1))+ZDLNO

**    Search for index limits in JI. Because of wrap around it is
**          necessary to look through the data twice. The output grid
**          longitudes have been adjusted (using ZDLNO) such that the
**          first longitude in the output grid is greater than the first
**          longitude on the input grid.
      DO 35 K=0,1
      DO 30 JII=1,IKLONI
      ZMNLN=MIN(PLONI(JII),PLONI(JII+1))+ZDLN+K*360.0
      ZMXLN=MAX(PLONI(JII),PLONI(JII+1))+ZDLN+K*360.0
**    Find JII limits
      IF(ZMXLN.GT.ZMNLNO.AND.ZMNLN.LT.ZMXLNO) THEN
         I1=MIN(JII+K*KLONI,I1)
         I2=MAX(JII+K*KLONI,I2)
      ENDIF
30    CONTINUE
35    CONTINUE

**    If input grid doesn't partially cover the output grid box, no
**          values will be assigned.
      IF(I2.LT.I1) THEN
         PDATAO(JI,J)=PFILL
         GO TO 7100
      ENDIF

      ZERAD=6371000.0
      ZAREA=0.0
      WT=0.0
      AVG=0.0
      DO 50 JJ=J1,J2
      SLATMX=MAX(PLATI(JJ),PLATI(JJ+1))
      SLATMN=MIN(PLATI(JJ),PLATI(JJ+1))
      WLAT=MAX(SIN(MIN(ZMXLTO,SLATMX)*ZPI/180.)-
     -      SIN(MAX(ZMNLTO,SLATMN)*ZPI/180.),0.0)
      IF(WLAT.NE.0.0) THEN
         DO 40 JIII=I1,I2
         SLON=ZDLN
         SLONP=ZDLN
         IF (JIII.GT.IKLONI) THEN
            SLON=SLON+360.
            SLONP=SLONP+360.
         ENDIF
         JII=MOD(JIII-1,IKLONI)+1
         JIIP=JII+1
         SLON=SLON+PLONI(JII)
         SLONP=SLONP+PLONI(JIIP)
         SLONMX=MAX(SLON,SLONP)
         SLONMN=MIN(SLON,SLONP)
         DELON=MAX(MIN(ZMXLNO,SLONMX)-
     -         MAX(ZMNLNO,SLONMN),0.0)
         WT=WT+WLAT*DELON*PMASK(JII,JJ)
         AVG=AVG+PDATAI(JII,JJ)*WLAT*DELON*PMASK(JII,JJ)
         ZAREA=ZAREA+(ZERAD**2)*WLAT*(DELON*ZPI/180.0)*PMASK(JII,JJ)
40       CONTINUE
      ENDIF
50    CONTINUE
      IF(WT.GT.0.0) THEN
         IF(LPSUM) THEN
            PDATAO(JI,J)=(AVG/WT)*ZAREA
         ELSE
            PDATAO(JI,J)=AVG/WT
         ENDIF
      ELSE
         PDATAO(JI,J)=PFILL
      ENDIF
7100  CONTINUE
2000  CONTINUE

**    Finish filling the output array from wrap-around
      IF(IKLONO.LT.KLONO) THEN
         DO 300 J=1,KLATO
         DO 300 JI=IKLONO+1,KLONO
         PDATAO(JI,J)=PDATAO(JI-IKLONO,J)
 300     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE AWIS(KDLONI,KLONI,PLONI,KLATI,PLATI,PDATAI,
     -      KDLONO,KLONO,PLONO,KLATO,PLATO,PDATAO,KERR,LPSUM)
**    Function - This subroutine does an area weighted average from one
**          grid, on a spherical earth, to another. No data masking is
**          employed; consequently the routine cannot distinguish, for
**          example between 'real' and 'underground' data points.
**          Restrictions:  Longitude must be the first dimension and it
**                         be monotonically increasing (West to East).
**                         Latitude must be the second dimension and it
**                         must be monotonic.
**                         Values for longitude and latitude must be in
**                         degrees.
**                         Arrays that wrap around must repeat
**                         longitudes with a 360 degree increment.  It
**                         will be assumed that values in the wrapped
**                         input  array will also repeat (wrapped values
**                         in these arrays will not be used).
**    Args in -
**               KDLONI  - First dimension of input PDATAI
**               KLONI   - Number of grid boxes in longitude for PDATAI
**               PLONI   - Longitude (deg) limits of grid boxes for
**                         PDATAI
**               KLATI   - Number of grid boxes in latitude for PDATAI
**               PLATI   - Latitude (deg) limits of grid boxes for
**                         PDATAI
**               PDATAI  - Array of input data
**               KDLONO  - First dimension of output PDATAO
**               KLONO   - Number of grid boxes in longitude for PDATAO
**               PLONO   - Longitude (deg) limits of grid boxes for
**                         PDATAO
**               KLATO   - Number of grid boxes in latitude for PDATAO
**               PLATO   - Latitude (deg) limits of grid boxes for
**                         PDATAO
**               LPSUM   - .TRUE. if area sum to be computed, else area-
**                         averages are returned in PDATAO
**    Args out - none
**               PDATAO  - Array of output data
**               KERR    - Error indication (values may be summed for
**                         multiple errors):
**                            0  no errors
**                            1  input longitude dimension and/or length
**                               <=0
**                            2  output dimension and/or length <=0
**                            4  input latititude dimension <=0
**                            8  output latitude dimension <=0
**                           16  wrap-around on input longitude grid
**                               doesn't repeat (+360)
**                           32  wrap-around on output longitude grid
**                               doesn't repeat (+360)
**                           64  longitude of input is not monotonic
**                               increasing
**                          128  longitude of output is not monotonic
**                               increasing
**                          256  latitude of input is not monotonic
**                          512  latitude of output is not monotonic
**                         1024  input longitude wraps but doesn't
**                               repeat identically
**                         2048  output longitude wraps but doesn't
**                               repeat identically
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - BOXAVS
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code
**          by Peter Glecker (of Lawrence Livermore Lab)

      DIMENSION PLONI(KLONI+1),PLATI(KLATI+1),PLONO(KLONO+1),
     -      PLATO(KLATO+1)
      DIMENSION PDATAI(KDLONI,KLATI),PDATAO(KDLONO,KLATO)
      LOGICAL LPSUM

      ZPI=ATAN2(0.0,-1.0)

**    Check dimensions and lengths.
      KERR=0
      IF (KDLONI.LT.KLONI.OR.KLONI.LE.0) KERR=1
      IF (KDLONO.LT.KLONO.OR.KLONO.LE.0) KERR=KERR+2
      IF (KLATI.LE.0) KERR=KERR+4
      IF (KLATO.LE.0) KERR=KERR+8
      IF (KERR.GT.0) RETURN

**    Check monotonic increasing input longitudes.
      DO 100 J=2,KLONI
      IF(PLONI(J).LE.PLONI(J-1)) THEN
         KERR=KERR+64
         GO TO 200
      ENDIF
100   CONTINUE
200   CONTINUE

**    Check monotonic increasing output longitudes.
      DO 301 J=2,KLONO
      IF(PLONO(J).LE.PLONO(J-1)) THEN
         KERR=KERR+128
         GO TO 400
      ENDIF
301   CONTINUE
400   CONTINUE

**    Check monotonicity of input latitudes.
      ZSGN=(PLATI(2)-PLATI(1))
      DO 501 J=2,KLATI
      IF(ZSGN.LT.0.0) THEN
         IF(PLATI(J)-PLATI(J-1).GE.0) THEN
            KERR=KERR+256
            GO TO 600
         ENDIF
      ELSE IF(ZSGN.GT.0.0) THEN
         IF(PLATI(J)-PLATI(J-1).LE.0.0) THEN
            KERR=KERR+256
            GO TO 600
         ENDIF
      ELSE
        KERR=KERR+256
        GO TO 600
      ENDIF
501   CONTINUE
600   CONTINUE

**    Check monotonicity of output latitudes.
      ZSGN=(PLATO(2)-PLATO(1))
      DO 700 J=2,KLATO
      IF(ZSGN.LT.0.0) THEN
         IF(PLATO(J)-PLATO(J-1).GE.0.0) THEN
            KERR=KERR+512
            GO TO 800
         ENDIF
      ELSE IF(ZSGN.GT.0.0) THEN
         IF(PLATO(J)-PLATO(J-1).LE.0.0) THEN
            KERR=KERR+512
            GO TO 800
         ENDIF
      ELSE
         KERR=KERR+512
         GO TO 800
      ENDIF
700   CONTINUE
800   CONTINUE

**    Find wrap around of input grid, if it exists.
      IKLONI=KLONI
      ZALMX=PLONI(1)
      ZALMN=PLONI(1)
      DO 1000 I=2,KLONI+1
      ZALMX=MAX(ZALMX,PLONI(I))
      ZALMN=MIN(ZALMN,PLONI(I))
      ZAL=ABS(PLONI(I)-PLONI(1))-360.0
      IF(ABS(ZAL).LE.1.E-3) THEN
         IKLONI=I-1
         GO TO 1100
      ELSE IF(ZAL.GT.0.0) THEN
         KERR=KERR+1024
         GO TO 1200
      ENDIF
1000  CONTINUE
1100  CONTINUE
      ZDLN=0.0
      IF(ZALMN.LT.0.0) THEN
         ZDLN=INT(-ZALMN/360.0+.001)*360.0
      ELSE IF(ZALMN.GT.360.0) THEN
         ZDLN=-INT(ZALMN/360.0+.001)*360.0
      ENDIF
1200  CONTINUE

**    Find wrap around of output grid, if it exists.
      IKLONO=KLONO
      ZALMXO=PLONO(1)
      ZALMNO=PLONO(1)
      DO 1300 I=2,KLONO+1
      ZALMXO=MAX(ZALMXO,PLONO(I))
      ZALMNO=MIN(ZALMNO,PLONO(I))
      ZAL=ABS(PLONO(I)-PLONO(1))-360.0
      IF(ABS(ZAL).LE.1.E-3) THEN
         IKLONO=I-1
         GO TO 1400
      ELSE IF(ZAL.GT.0.0) THEN
         KERR=KERR+2048
         GO TO 1500
      ENDIF
1300  CONTINUE
1400  CONTINUE
      ZDLNO=0.0
      IF(ZALMNO.LT.0.0) THEN
         ZDLNO=INT(-ZALMNO/360.0+.001)*360.0
      ELSE IF(ZALMNO.GT.360.0) THEN
         ZDLNO=-INT(ZALMNO/360.0+.001)*360.0
      ENDIF
1500  CONTINUE

**    Test for errors.  Return if any exist.
      IF(KERR.NE.0) RETURN

**    The output grid needs to begin with or after the input grid.
      IF(ZALMNO+ZDLNO.LT.ZALMN+ZDLN) ZDLNO=ZDLNO+360.0

      DO 2000 J=1,KLATO
**    Find index limits in latitude to cover the new grid.
      J1=KLATI+1
      J2=0
      ZMNLTO=MIN(PLATO(J),PLATO(J+1))
      ZMXLTO=MAX(PLATO(J),PLATO(J+1))

**    Search for index limits in J
      DO 1700 JJ=1,KLATI
      ZMNLT=MIN(PLATI(JJ),PLATI(JJ+1))
      ZMXLT=MAX(PLATI(JJ),PLATI(JJ+1))

**    Find JJ limits
      IF(ZMXLT.GT.ZMNLTO.AND.ZMNLT.LT.ZMXLTO) THEN
         J1=MIN(JJ,J1)
         J2=MAX(JJ,J2)
      ENDIF
1700  CONTINUE

**    If input grid doesn't at least partially cover the
**          output grid box, no values will be assigned
**
      IF(J2.LT.J1) THEN
         DO 201 JI=1,IKLONO
C*****hack:limit on exponent for single prec ifc
C        PDATAO(JI,J)=1.E40
         PDATAO(JI,J)=1.E35
201      CONTINUE
         GO TO 2000
      ENDIF

      DO 7100 JI=1,IKLONO
**    Find index limits in longitude to cover the new grid
      I1=3*KLONI+1
      I2=0
      ZMNLNO=MIN(PLONO(JI),PLONO(JI+1))+ZDLNO
      ZMXLNO=MAX(PLONO(JI),PLONO(JI+1))+ZDLNO

**    Search for index limits in JI. Because of wrap around it is
**          necessary to look through the data twice. The output grid
**          longitudes have been adjusted (using ZDLNO) such that the
**          first longitude in the output grid is greater than the first
**          longitude on the input grid.
      DO 35 K=0,1
      DO 30 JII=1,IKLONI
      ZMNLN=MIN(PLONI(JII),PLONI(JII+1))+ZDLN+K*360.0
      ZMXLN=MAX(PLONI(JII),PLONI(JII+1))+ZDLN+K*360.0
**    Find JII limits
      IF(ZMXLN.GT.ZMNLNO.AND.ZMNLN.LT.ZMXLNO) THEN
         I1=MIN(JII+K*KLONI,I1)
         I2=MAX(JII+K*KLONI,I2)
      ENDIF
30    CONTINUE
35    CONTINUE

**    If input grid doesn't partially cover the output grid box, no
**          values will be assigned.
      IF(I2.LT.I1) THEN
C*****hack:limit on exponent for single prec ifc
C        PDATAO(JI,J)=1.E40
         PDATAO(JI,J)=1.E35
         GO TO 7100
      ENDIF

      ZERAD=6371000.0
      ZAREA=0.0
      WT=0.0
      AVG=0.0
      DO 50 JJ=J1,J2
      SLATMX=MAX(PLATI(JJ),PLATI(JJ+1))
      SLATMN=MIN(PLATI(JJ),PLATI(JJ+1))
      WLAT=MAX(SIN(MIN(ZMXLTO,SLATMX)*ZPI/180.)-
     -      SIN(MAX(ZMNLTO,SLATMN)*ZPI/180.),0.0)
      IF(WLAT.NE.0.0) THEN
         DO 40 JIII=I1,I2
         SLON=ZDLN
         SLONP=ZDLN
         IF (JIII.GT.IKLONI) THEN
            SLON=SLON+360.
            SLONP=SLONP+360.
         ENDIF
         JII=MOD(JIII-1,IKLONI)+1
         JIIP=JII+1
         SLON=SLON+PLONI(JII)
         SLONP=SLONP+PLONI(JIIP)
         SLONMX=MAX(SLON,SLONP)
         SLONMN=MIN(SLON,SLONP)
         DELON=MAX(MIN(ZMXLNO,SLONMX)-
     -         MAX(ZMNLNO,SLONMN),0.0)
         WT=WT+WLAT*DELON
         AVG=AVG+PDATAI(JII,JJ)*WLAT*DELON
         ZAREA=ZAREA+(ZERAD**2)*WLAT*(DELON*ZPI/180.0)
40       CONTINUE
      ENDIF
50    CONTINUE
      IF(WT.GT.0.0) THEN
         IF(LPSUM) THEN
            PDATAO(JI,J)=(AVG/WT)*ZAREA
         ELSE
            PDATAO(JI,J)=AVG/WT
         ENDIF
      ELSE
C*****hack:limit on exponent for single prec ifc
C        PDATAO(JI,J)=1.E40
         PDATAO(JI,J)=1.E35
      ENDIF
7100  CONTINUE
2000  CONTINUE

**    Finish filling the output array from wrap-around
      IF(IKLONO.LT.KLONO) THEN
         DO 300 J=1,KLATO
         DO 300 JI=IKLONO+1,KLONO
         PDATAO(JI,J)=PDATAO(JI-IKLONO,J)
 300     CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE BOXAV(KTYPE,PLONI,KLONI,PLONO,PLONOW,PLONOE,PLATO,
     -      PLATI,KLATI,PLATON,PLATOS,PDATAI,PDATAO,KELEMO,LPSUM,
     -      PMASK,PFILL)
**    Function - To perform an area-weighted average from one grid to
**          another. This routine take a horizontal 2D array as input.
**          Note that references to the input grid refer to the
**          standard global model grid as defined by the T-truncation,
**          while the output grid refers to the grid used to compute the
**          average between specific latitudes and longitudes. The
**          routine assumes that data is available over the entire
**          globe (KLATI=JPJG*2,KLONI=JPMG), and that one of the
**          following output scenarios is required:
**             1. output data for a single latitude range around the
**                entire globe (KLATO=1, KLONO=KLONI, KELEMO=KLONI))
**             2. output data for a single longitude range for the
**                complete north-south range (KLATO=KLATI, KLONO=1,
**                KELEMO=KLATI))
**             3. output data for a subset of both the latitude and
**                longitude range (KLATO=1, KLONO=1, KELEMO=1)
**          (Here, LAT=latitude and LON=longitude, I=input, O=output.)
**          Note that the data field arrays do not contain wrap around
**          data - each element refers to a unique location.
**    Args in -
**               KTYPE   - One of 1, 2 or 3 - corresponding to the list
**                         above
**               KLONI   - Number of gridboxes in input grid in the
**                         west-east direction around the entire globe
**               PLONOW  - Western limit on the output gridbox (not
**                         used if KTYPE=1) in degrees
**               PLONOE  - Eastern limit on the output gridbox (not
**                         used if KTYPE=1) in degrees
**               PLATI   - Array containing input gridbox latitude
**                         boundaries in degrees of dimension KLATI+1
**               KLATI   - Number of gridboxes north-south for the input
**                         grid (pole to pole)
**               PLATON  - Northern limit on the output grid (not used
**                         if KTYPE=2) in degrees
**               PLATOS  - Southern limit on the output grid (not used
**                         if KTYPE=2) in degrees
**               PDATAI  - Input data - array of size (KLONI,KLATI)
**               KELEMO  - Number of output data values returned
**               LPSUM   - .TRUE. if output field to contain data
**                         values of average times area, else areal
**                         averages returned
**               PMASK   - Real mask array whose elements
**                         correspond to those elements of PDATAI to
**                         be used in computing the output array PDATAO
**               PFILL   - Value to be assigned to output gridpoint data
**                         value in the event that it contains no
**                         computed value.
**    Args out -
**               PDATAO  - Output data - array of size (KELEMO).
**    Args for work -
**               PLONI   - Array space of size KLONI+1 to hold wrap
**                         around input longitudes defining the input
**                         box boundaries
**               PLONO   - Array space of size KLONI+1 to hold wrap
**                         around output longitudes defining the output
**                         box boundaries
**               PLATO   - Array space of size KLATI+1 to hold output
**                         box boundary latitudes
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GMOUT,GZOUT,HROUT,THOUT,TMOUT,TZOUT
**    Calls - ABORT,AWI
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PLONI(KLONI+1),PLONO(KLONI+1),PLATI(KLATI+1),
     -      PLATO(KLATI+1),PDATAI(KLONI,KLATI),PDATAO(KELEMO)
      LOGICAL LPSUM
      DIMENSION PMASK(KLONI,KLATI)

**    Error check on KTYPE
      IF(KTYPE.LT.1.OR.(KTYPE.GT.3)) THEN
         WRITE(6,6000)KTYPE
6000     FORMAT(1X,'***BOXAV : INVALID KTYPE = ',I3)
         CALL ABORT
      ENDIF

**    Error check on KELEMO
      IF((KTYPE.EQ.1.AND.KELEMO.NE.KLONI).OR.
     -      (KTYPE.EQ.2.AND.KELEMO.NE.KLATI).OR.
     -      (KTYPE.EQ.3.AND.KELEMO.NE.1)) THEN
         WRITE(6,6010) KELEMO,KTYPE
6010     FORMAT(1X,'***BOXAV : INVALID KELEMO, KTYPE = ',I3,',',I3)
         CALL ABORT
      ENDIF

**    Input box longitude boundaries - specified from model truncation.
**          Note that these boundaries wrap around the globe
      PLONI(1)=-180.0/FLOAT(KLONI)
      DO 100 J=2,KLONI+1
      PLONI(J)=PLONI(J-1)+360.0/FLOAT(KLONI)
100   CONTINUE

**    Output box longitude boundaries - again, these wrap around
      IF(KTYPE.EQ.1) THEN
         DO 200 J=1,KLONI+1
         PLONO(J)=PLONI(J)
200      CONTINUE
**       ILONO - number of output boxes west-east
         ILONO=KLONI
      ELSE
         PLONO(1)=PLONOW
         PLONO(2)=PLONOE
         IF(PLONO(1).GT.PLONO(2)) PLONO(1)=PLONO(1)-360.0
         PLONO(3)=PLONO(1)+360.0
         ILONO=1
      ENDIF

**    Input box latitude boundaries (from 90.0 to -90.0 degrees) are
**          defined via the argument list. Now determine the output
**          latitude box boundaries.
      IF(KTYPE.EQ.2) THEN
         DO 300 J=1,KLATI+1
         PLATO(J)=PLATI(J)
**       ILATO - number of output boxes, north-south
         ILATO=KLATI
300      CONTINUE
      ELSE
         PLATO(1)=PLATON
         PLATO(2)=PLATOS
         ILATO=1
      ENDIF

**    Perform area averaging
      CALL AWI(KLONI,KLONI,PLONI,KLATI,PLATI,PDATAI,PMASK,PFILL,
     -      ILONO,ILONO,PLONO,ILATO,PLATO,PDATAO,IERR,LPSUM)
      IF(IERR.NE.0) THEN
         WRITE(6,6020)IERR
6020     FORMAT(1X,'***BOXAV: IERR RETURNED FROM AWI = ',I5)
         CALL ABORT
      ENDIF

      RETURN
      END
      SUBROUTINE BOXAVS(KTYPE,PLONI,KLONI,PLONO,PLONOW,PLONOE,PLATO,
     -      PLATI,KLATI,PLATON,PLATOS,PDATAI,PDATAO,KELEMO,LPSUM)
**    Function - To perform an area-weighted average from one grid to
**          another. No masking of data values is employed.
**          This routine take a horizontal 2D array as input.
**          Note that references to the input grid refer to the
**          standard global model grid as defined by the T-truncation,
**          while the output grid refers to the grid used to compute the
**          average between specific latitudes and longitudes. The
**          routine assumes that data is available over the entire
**          globe (KLATI=JPJG*2,KLONI=JPMG), and that one of the
**          following output scenarios is required:
**             1. output data for a single latitude range around the
**                entire globe (KLATO=1, KLONO=KLONI, KELEMO=KLONI))
**             2. output data for a single longitude range for the
**                complete north-south range (KLATO=KLATI, KLONO=1,
**                KELEMO=KLATI))
**             3. output data for a subset of both the latitude and
**                longitude range (KLATO=1, KLONO=1, KELEMO=1)
**          (Here, LAT=latitude and LON=longitude, I=input, O=output.)
**          Note that the data field arrays do not contain wrap around
**          data - each element refers to a unique location.
**    Args in -
**               KTYPE   - One of 1, 2 or 3 - corresponding to the list
**                         above
**               KLONI   - Number of gridboxes in input grid in the
**                         west-east direction around the entire globe
**               PLONOW  - Western limit on the output gridbox (not
**                         used if KTYPE=1) in degrees
**               PLONOE  - Eastern limit on the output gridbox (not
**                         used if KTYPE=1) in degrees
**               PLATI   - Array containing input gridbox latitude
**                         boundaries in degrees of dimension KLATI+1
**               KLATI   - Number of gridboxes north-south for the input
**                         grid (pole to pole)
**               PLATON  - Northern limit on the output grid (not used
**                         if KTYPE=2) in degrees
**               PLATOS  - Southern limit on the output grid (not used
**                         if KTYPE=2) in degrees
**               PDATAI  - Input data - array of size (KLONI,KLATI)
**               KELEMO  - Number of output data values returned
**               LPSUM   - .TRUE. if output field to contain data
**                         values of average times area, else areal
**                         averages returned
**    Args out -
**               PDATAO  - Output data - array of size (KELEMO).
**    Args for work -
**               PLONI   - Array space of size KLONI+1 to hold wrap
**                         around input longitudes defining the input
**                         box boundaries
**               PLONO   - Array space of size KLONI+1 to hold wrap
**                         around output longitudes defining the output
**                         box boundaries
**               PLATO   - Array space of size KLATI+1 to hold output
**                         box boundary latitudes
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GMOUT,GZOUT,HROUT,OPPHTD,PHINST,THOUT,TMOUT,TZOUT
**    Calls - ABORT,AWIS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PLONI(KLONI+1),PLONO(KLONI+1),PLATI(KLATI+1),
     -      PLATO(KLATI+1),PDATAI(KLONI,KLATI),PDATAO(KELEMO)
      LOGICAL LPSUM

**    Error check on KTYPE
      IF(KTYPE.LT.1.OR.(KTYPE.GT.3)) THEN
         WRITE(6,6000)KTYPE
6000     FORMAT(1X,'***BOXAV : INVALID KTYPE = ',I3)
         CALL ABORT
      ENDIF

**    Error check on KELEMO
      IF((KTYPE.EQ.1.AND.KELEMO.NE.KLONI).OR.
     -      (KTYPE.EQ.2.AND.KELEMO.NE.KLATI).OR.
     -      (KTYPE.EQ.3.AND.KELEMO.NE.1)) THEN
         WRITE(6,6010) KELEMO,KTYPE
6010     FORMAT(1X,'***BOXAV : INVALID KELEMO, KTYPE = ',I3,',',I3)
         CALL ABORT
      ENDIF

**    Input box longitude boundaries - specified from model truncation.
**          Note that these boundaries wrap around the globe
      PLONI(1)=-180.0/FLOAT(KLONI)
      DO 100 J=2,KLONI+1
      PLONI(J)=PLONI(J-1)+360.0/FLOAT(KLONI)
100   CONTINUE

**    Output box longitude boundaries - again, these wrap around
      IF(KTYPE.EQ.1) THEN
         DO 200 J=1,KLONI+1
         PLONO(J)=PLONI(J)
200      CONTINUE
**       ILONO - number of output boxes west-east
         ILONO=KLONI
      ELSE
         PLONO(1)=PLONOW
         PLONO(2)=PLONOE
         IF(PLONO(1).GT.PLONO(2)) PLONO(1)=PLONO(1)-360.0
         PLONO(3)=PLONO(1)+360.0
         ILONO=1
      ENDIF

**    Input box latitude boundaries (from 90.0 to -90.0 degrees) are
**          defined via the argument list. Now determine the output
**          latitude box boundaries.
      IF(KTYPE.EQ.2) THEN
         DO 300 J=1,KLATI+1
         PLATO(J)=PLATI(J)
**       ILATO - number of output boxes, north-south
         ILATO=KLATI
300      CONTINUE
      ELSE
         PLATO(1)=PLATON
         PLATO(2)=PLATOS
         ILATO=1
      ENDIF

**    Perform area averaging
      CALL AWIS(KLONI,KLONI,PLONI,KLATI,PLATI,PDATAI,
     -      ILONO,ILONO,PLONO,ILATO,PLATO,PDATAO,IERR,LPSUM)
      IF(IERR.NE.0) THEN
         WRITE(6,6020)IERR
6020     FORMAT(1X,'***BOXAV: IERR RETURNED FROM AWI = ',I5)
         CALL ABORT
      ENDIF

      RETURN
      END
      SUBROUTINE DAYCHK(KB1PAR,PDAY,PRDDAY,KFAIL,LPEC)
**    Function - To check day number in GRIB block 1 against requested
**          day. This version is valid for ECMWF analyses & forecasts
**          and for data from UGCM integrations up to 179 years.
**    Args in - none
**               KB1PAR  - Integer array containing GRIB product
**                         definition information.
**               PDAY    - Requested day number.
**               LPEC    - .TRUE. if ECMWF analysis file in use
**    Args out -
**               PRDDAY  - Day number deduced from times in GRIB block
**                         1.
**               KFAIL   - Error code:
**                            0:  successful completion and day number
**                            agrees.
**                            1: unexpected value of time range flag.
**                            2: time 2 in GRIB is non-zero.
**                            3: time range in minutes differs from
**                               requested day no.
**                            4: time range in hours differs from
**                               requested day no.
**                            5: time range in days differs from
**                               requested day no.
**                            6: unexpected value of unit of time range.
**                            7: Day number read from GRIB differs from
**                               requested day.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - DECOMD,DECOMS,DECOMU,GETFIL
**    Calls - IDAT2C, CD2DAT(date format conversion routines)
**    Files read - none
**    Files written - none
**    Author - M Blackburn, with modifications by R Brugge, University
**          of Reading

**    Method:
**       On the first call, the GRIB date/time information is used to
**    create a day zero time which is used as the baseline for day
**    numbering throughout the data time series.  It is converted to a
**    century day (N0CD) and minute-in-day (N0MD) using ECMWF calender
**    routines and saved across subsequent calls to DAYCHK.
**    For ECMWF analyses this is the time of the first analysis.
**    For ECMWF model & UGCM integrations it is the initial data time.
**    In most cases this is just the reference time in the GRIB header.
**    However for UGCM integrations beyond generally 7.5years, the
**    integration period cannot be accomodated in the GRIB time range
**    and the reference time is the current time in the integration,
**    with the time range set to zero.  In this case the initial data
**    time is computed on the first call by subtracting the *requested*
**    day number from the reference (current) time.  It is printed to
**    allow verification.
**       On all calls, the date/time of the data is computed from the
**    GRIB date/time information.  The day number is obtained by sub-
**    tracting the day zero information stored on the first call.  This
**    is checked against the requested day number.

**    Saved integers are day-in-century and minute-in-day of day zero.
**    Saved logical is a flag of first call to the routine.
      INTEGER KB1PAR(18),IN0CD,IN0MD
      LOGICAL LOCALL,LPEC
      SAVE IN0CD,IN0MD,LOCALL
      DATA LOCALL/.TRUE./

CC    TEMPORARY CODE
      PRINT *,'DAYCHK CALLED - ERROR -- ABORT'
      CALL ABORT

C**    The following code is only executed when reading ECMWF analysis
C**    files
C      IF((KB1PAR(15).EQ.0).AND.LPEC) THEN
C         PRDDAY=DAYFUN(KB1PAR(9),KB1PAR(10),KB1PAR(11),KB1PAR(12),
C     -         KB1PAR(13))
C      ENDIF

C**    Security variable for day number calculations.
C      ZEPDAY=1.E-3

C**    Preset return code.
C      KFAIL=0

C**    Check that data is valid at a single time and not an average or
C**          accumulation over a period.  This is determined by the time
C**          range indicator (GRIB table 5).  The second time value
C**          should be zero.
C      IFLAG=KB1PAR(17)
C      IF (IFLAG.NE.0.AND.IFLAG.NE.1.AND.IFLAG.NE.10) THEN
C         WRITE(6,*) ' ***DAYCHK : UNEXPECTED TIME RANGE FLAG = ',IFLAG
C         KFAIL=1
C         RETURN
C      ENDIF
C      IF (KB1PAR(16).NE.0) THEN
C         WRITE(6,*) ' ***DAYCHK : SECOND TIME VALUE INCLUDED IN GRIB'
C         KFAIL=2
C         RETURN
C      ENDIF

C**    Extract reference date/time.
C      IRYEAR=KB1PAR(9)
C      IRMONT=KB1PAR(10)
C      IRDAY =KB1PAR(11)
C      IRHOUR=KB1PAR(12)
C      IRMIN =KB1PAR(13)

C**    Convert to century-day and minute-in-day.
C      IRCD=IDAT2C(IRDAY,IRMONT,IRYEAR)
C      IRMD=IRHOUR*60+IRMIN

C**    For first call, copy to day zero date/time.
C**    Will be modified if time range is zero but requested day positive.
C      IF (LOCALL) THEN
C         IN0CD=IRCD
C         IN0MD=IRMD
C         WRITE(6,'(/2X,72(''*''))')
C      ENDIF

C**    Extract time range and convert to days and minutes.
C**    This is the time to be added to the reference time
C**          to obtain the valid time of the data.
C      IRANGE=KB1PAR(15)
C      IF (IRANGE.EQ.0) THEN
C         ITRDAY=0
C         ITRMIN=0
C         ZTRDAY=0.0
C         IF (LOCALL.AND.PDAY.GT.ZEPDAY) THEN
C**          On first call, modify day zero by subtracting *requested*
C**          day number in run from reference time (current time).
C**          This will occur for diagnosis of ECMWF analyses beginning
C**          after the first analysis and for diagnosis of model
C**          integrations > 7.5 years where the reference time is the
C**          current time.  In both cases the day zero time cannot be
C**          computed from the GRIB information.
C            WRITE(6,*) ' ***DAYCHK : GRIB BLOCK 1 TIME RANGE IS ZERO'
C     -            ,' ON FIRST CALL. '
C            WRITE(6,*) ' *** DAY ZERO WILL BE REFERENCE TIME LESS'
C     -            ,' *REQUESTED* DAY NUMBER (',PDAY,')'
C            WRITE(6,*) ' *** PLEASE CHECK FOLLOWING DATES CAREFULLY ***'
C            ITDAY=INT(PDAY)
C            ITMIN=NINT((PDAY-FLOAT(ITDAY))*60.*24.)
C            IN0CD=IN0CD-ITDAY
C            IN0MD=IN0MD-ITMIN
C            IF (IN0MD.LT.0) THEN
C               IN0CD=IN0CD-1
C               IN0MD=IN0MD+24*60
C            ENDIF
C         ENDIF
C      ELSE IF (KB1PAR(14).EQ.0) THEN
C**       Time range in minutes.
C         ITRDAY=IRANGE/(24*60)
C         ITRMIN=IRANGE-ITRDAY*24*60
C         ZTRDAY=FLOAT(IRANGE)/(24.*60.)
C         IF (ABS(PDAY-ZTRDAY).GT.ZEPDAY) THEN
C            WRITE(6,*) ' ***DAYCHK : TIME RANGE = ',ZTRDAY,' DAYS'
C     -            ,' IS DIFFERENT FROM REQUESTED DAY = ',PDAY
C            PRDDAY=ZTRDAY
C            KFAIL=3
C            RETURN
C         ENDIF
C      ELSE IF (KB1PAR(14).EQ.1) THEN
C**       Time range in hours.
C         ITRDAY=IRANGE/24
C         ITRMIN=(IRANGE-ITRDAY*24)*60
C         ZTRDAY=FLOAT(IRANGE)/24.
C         IF (ABS(PDAY-ZTRDAY).GT.ZEPDAY) THEN
C            WRITE(6,*) ' ***DAYCHK : TIME RANGE = ',ZTRDAY,' DAYS'
C     -            ,' IS DIFFERENT FROM REQUESTED DAY = ',PDAY
C            PRDDAY=ZTRDAY
C            KFAIL=4
C            RETURN
C         ENDIF
C      ELSE IF (KB1PAR(14).EQ.2) THEN
C**       Time range in days.
C         ITRDAY=IRANGE
C         ITRMIN=0
C         ZTRDAY=FLOAT(IRANGE)
C         IF (ABS(PDAY-ZTRDAY).GT.ZEPDAY) THEN
C            WRITE(6,*) ' ***DAYCHK : TIME RANGE = ',ZTRDAY,' DAYS'
C     -            ,' IS DIFFERENT FROM REQUESTED DAY = ',PDAY
C            PRDDAY=ZTRDAY
C            KFAIL=5
C            RETURN
C         ENDIF
C      ELSE
C**       Unexpected unit of time range.
C         WRITE(6,*) ' ***DAYCHK : UNEXPECTED UNIT OF TIME RANGE'
C         KFAIL=6
C         RETURN
C      ENDIF

C**    Calculate valid time of data as century-day and minute-in-day.
C      ICD=IRCD+ITRDAY
C      IMD=IRMD+ITRMIN
C      IF (IMD.GE.24*60) THEN
C         ICD=ICD+1
C         IMD=IMD-24*60
C      ENDIF

C**    Subtract day zero to obtain day number.
C      ID=ICD-IN0CD
C      IM=IMD-IN0MD
C      IF (IM.LT.0) THEN
C         ID=ID-1
C         IM=IM+24*60
C      ENDIF
C      PRDDAY=FLOAT(ID)+FLOAT(IM)/(24.*60.)

C**    Check against requested day number.
C      IF (ABS(PDAY-PRDDAY).GT.ZEPDAY) THEN
C         WRITE(6,*) ' ***DAYCHK : DAY NUMBER ON GRIB HEADER (',PRDDAY
C     -         ,') IS DIFFERENT FROM REQUESTED DAY (',PDAY,')'
C         KFAIL=7
C      ENDIF

C**    On first call, print details of day zero and first analysis in
C**          the diagnostic period.
C      IF (LOCALL) THEN
C         CALL CD2DAT(IN0CD,I0DAY,I0MONT,I0YEAR)
C         I0HOUR=IN0MD/60
C         I0TIME=100*I0HOUR+(IN0MD-I0HOUR*60)
C         CALL CD2DAT(ICD,IDDAY,IDMONT,IDYEAR)
C         IDHOUR=IMD/60
C
C         IDTIME=100*IDHOUR+(IMD-IDHOUR*60)
C         WRITE(6,*) ' ***DAYCHK : DAY ZERO FOR THE DATA TIME SERIES IS '
C     -         ,I0TIME,' HOURS ON ',I0DAY,'/',I0MONT,'/',I0YEAR
C         WRITE(6,*) ' ***DAYCHK : DIAGNOSTIC PERIOD BEGINS AT          '
C     -         ,IDTIME,' HOURS ON ',IDDAY,'/',IDMONT,'/',IDYEAR
C         WRITE(6,'(2X,72(''*'')/)')
C         LOCALL=.FALSE.
C      ENDIF

      RETURN
      END
      FUNCTION DAYFUN(KANN,KMON,KDAY,KHOU,KMIN)
**    Function - calculates the day from the integer GRIB units. Eg
**          1st January 1900 at 0000GMT is given by (KANN=0, KMON=1,
**          KDAY=1, KHOU=12, KMIN=0), and corresponds to
**          day = -ZDAY0 (see below).
**    Args in -
**               KANN    - Integer year counter
**               KMON    - Integer month counter
**               KDAY    - Integer day counter
**               KHOU    - Integer hour counter
**               KMIN    - Integer minute counter
**    Args out -
**               DAYFUN  - Day number
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - DAYCHK
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on an algorithm
**          by D Stephenson

**    The following day number represents the time 00 GMT on 1st
**        September 1990, and enables the routine to return
**        DAYFUN=0.0 for this time.
      PARAMETER(JPORIG=33116)
      LOGICAL LOLEAP
      DIMENSION IMNLEN(12)
      SAVE IMNLEN
      DATA IMNLEN/0,31,59,90,120,151,181,212,243,273,304,334/

      ZDAY0=JPORIG

**    Years, accounting for the leap years. Note that the year 1900
**          (although not a leap year) is treated as one in this
**          calculation. Thus JPORIG must be take account of this.
      LOLEAP=.FALSE.
      IF(4*(KANN/4).EQ.KANN) LOLEAP=.TRUE.
      IDAYS=KANN*365
      IF(LOLEAP) THEN
         IDAYS=IDAYS+KANN/4
      ELSE
         IDAYS=IDAYS+1+KANN/4
      ENDIF

**    Add number of days depending upon the month.
      IDAYS=IDAYS+IMNLEN(KMON)
      IF(LOLEAP.AND.(KMON.GT.2)) IDAYS=IDAYS+1

**    Add number of days to current day in the month
      IDAYS=IDAYS+KDAY-1

**    Add contribution from time of day
      DAYFUN=FLOAT(IDAYS)+FLOAT(KHOU)/24.0+FLOAT(KMIN)/1440.0-ZDAY0

      RETURN
      END
      SUBROUTINE DLSGCR(KCOL,PF,PRGG,PDF,KDIM,KNL)
**    Function - routine to take vertical derivative of a 2D array (with
**          respect to ln(eta) on the model's vertical co-ordinate
**          levels using the PRGG matrix
**    Args in -
**               KCOL    - Number of columns of data - should be equal
**                         to KDIM
**               PF      - Array to be vertically differenced
**               PRGG    - Array used to compute vertical derivatives
**               KDIM    - First dimension (ie horizontal) of PF and PDF
**               KNL     - Second dimension (ie vertical) of PF and PDF.
**                         This should also define the size of RGG
**    Args out -
**               PDF     - Vertical derivative of PF
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GRMULT
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on an algorithm
**          in UFLUX2F

      DIMENSION PF(KDIM,KNL),PDF(KDIM,KNL),PRGG(KNL,KNL)

**    Method:
**    PDF=PRGG*PF may be re-written as
**    PDF=   d(PF)/dln(eta)   =   (eta)d(PF)/d(eta).

**    The routine calculates PDF at KNL levels for KCOL columns from the
**    array PF. It uses vector loops over KCOL at each level. Note that
**    for KCOL <= 3 inner loops unroll to give vectorisation over
**    levels. The routine uses explicit values of PRGG matrix rather
**    than function SDOT over KNL elements of PRGG at each level.  Due
**    to sparse nature of PRGG, this gives large speed-up for KNL >> 3.

**    Initial checks
      IF(KCOL.GT.KDIM) THEN
         WRITE(6,6000) KCOL,KDIM
6000     FORMAT(/' ***ABORT IN DLSGCR: MORE COLUMNS THAN ARRAY',
     -          ' DIMENSION; KCOL KDIM =',2I10)
         CALL ABORT
      ENDIF

      INLM=KNL-1
      INLMM=KNL-2

**    Top and bottom levels.
      DO 10 JI=1,KCOL
      PDF(JI,1 )=PF(JI,1)*PRGG(1,1)+PF(JI,2)*PRGG(2,1)+
     -      PF(JI,3)*PRGG(3,1)
      PDF(JI,KNL)=PF(JI,INLMM)*PRGG(INLMM,KNL)+
     -      PF(JI,INLM)*PRGG(INLM,KNL)+PF(JI,KNL)*PRGG(KNL,KNL)
10    CONTINUE

**    Intermediate levels.
      IF(INLM.GE.2) THEN
         DO 20 JL=2,INLM
         DO 20 JI=1,KCOL
         PDF(JI,JL)=PF(JI,JL-1)*PRGG(JL-1,JL)+PF(JI,JL+1)*PRGG(JL+1,JL)
20       CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE EXTRNS(PX0,PLAT0,PX1,PLAT1,
     -            PX2,PLAT2,KDIMX)
**    Function - To extrapolate a field north/south using information
**          from the two adjacent gridpoints - assume
**          d(field)/d(sin(latitude)) is constant. No account is taken
**          of the possible presence of 'underground' data, ie the
**          land/air mask is not used.
**    Args in -
**               PLAT0   - Latitude for which the extrapolated field is
**                         to be be computed
**               PX1     - Field at nearest latitude to ALAT0
**               PLAT1   - Latitude at which PX1 is located
**               PX2     - Field located two latitudes from ALAT0
**               PLAT2   - Latitude at which PX2 is located
**               KDIMX   - Dimension of PX0, PX1 and PX2
**    Args out -
**               PX0     - Extrapolated field values
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - WELAT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PX0(KDIMX),PX1(KDIMX),PX2(KDIMX)

      GPI=ATAN2(0.0,-1.0)

      ZSIN0=SIN(PLAT0*GPI/180.0)
      ZSIN1=SIN(PLAT1*GPI/180.0)
      ZSIN2=SIN(PLAT2*GPI/180.0)
      ZS0112=(ZSIN0-ZSIN1)/(ZSIN1-ZSIN2)
      ZS0212=(ZSIN0-ZSIN2)/(ZSIN1-ZSIN2)

      DO 100 J=1,KDIMX
      PX0(J)=PX1(J)*ZS0212-PX2(J)*ZS0112
100   CONTINUE

      RETURN
      END
      SUBROUTINE FTNN(KU,YPLCU)
**    Function - Return fortran unit name for unicos, left adjusted as
**          'fort.'KU If invalid unit number is supplied, returns
**          'fort.NN '.
**    Args in -
**               KU      - fortran unit number
**    Args out -
**               YPLCU   - character string containing file name
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - CHOPEN,RELEAS
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code
**          by M Blackburn

      CHARACTER*8 YPLCU

      IF (KU.GT.102) THEN
         WRITE(*,6900) KU
6900     FORMAT(//' ***FORTN: ATTEMPT TO SET UP FILENAME FORT.',I3
     -         ,'  : ONLY UNIT NUMBERS UP TO 102 ALLOWED'//)
         WRITE(YPLCU,'(''fort.NN '')') KU
      ELSE IF (KU.GE.100) THEN
         WRITE(YPLCU,'(''fort.'',I3)') KU
      ELSE IF (KU.GE.10) THEN
         WRITE(YPLCU,'(''fort.'',I2,'' '')') KU
      ELSE IF (KU.GT.0) THEN
         WRITE(YPLCU,'(''fort.'',I1,''  '')') KU
      ELSE
         WRITE(*,6910) KU
 6910    FORMAT(//' ***FORTN: ATTEMPT TO SET UP FILENAME FOR FORTRAN'
     -         ,' UNIT',I10//)
         WRITE(YPLCU,'(''fort.NN '')') KU
      ENDIF

      RETURN
      END
      SUBROUTINE INTCOL(PX,KMG,KJGG,KNL,PXPF,LPEXTR,
     -      PDIST,KMGW,KMGE,KLATN,KLATS,PLAT1,PLAT,PLAT2)
**    Function - to compute a single column profile at a non-gridpoint
**          location. Assumes linear interpolation in longitude, and
**          that d(field)/d(sin(latitude)) is constant. No account is
**          of underground data; ie no land/air masks are employed.
**    Args in -
**               PX      - 3D array from which the profile will be
**                         extracted
**               KMG     - Number of data values per latitude line
**               KJGG    - Number of latitude lines of data
**               KNL     - Number of data levels
**               LPEXTR  - .TRUE. if north-south extrapolation towards
**                         poles is required
**               PDIST   - Fractional distance of profile from KWEST
**                         towards KEAST
**               KMGW    - )Gridlines immediately to the west
**               KMGE    - )and east of the profile location.
**               KLATN   - )Gaussian latitude counter to the north and
**               KLATS   - )the south, or nearest and next-nearest if
**                         extrapolating (in the range 1-KJGG)
**               PLAT    - Profile latitude
**               PLAT1   - Gaussian latitude to the north of PLAT, or
**                         the nearest Gaussian latitude to PLAT if
**                         extrapolating
**               PLAT2   - Gaussian latitude to the south of PLAT, or
**                         the next nearest Gaussian latitude to PLAT if
**                         extrapolating
**    Args out -
**               PXPF    - Profile with KNL data values
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - PROFIL
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PX(KMG,KJGG,KNL),PXPF(KNL)
      LOGICAL LPEXTR

**    Note that interpolation and extrapolation use the same code. This
**    duplication is kept for the present, since the use of LOEXTR
**    allows for a future change in the extrapolation algorithm if
**    required.

      GPI=ATAN2(0.0,-1.0)

      IF(.NOT.LPEXTR) THEN
**       Interpolate
         ZSIN1=SIN(PLAT1*GPI/180.0)
         ZSIN0=SIN(PLAT*GPI/180.0)
         ZSIN2=SIN(PLAT2*GPI/180.0)
         Z1=(ZSIN1-ZSIN0)/(ZSIN1-ZSIN2)
         Z2=(ZSIN0-ZSIN2)/(ZSIN1-ZSIN2)
         DO 100 JL=1,KNL
         ZN=PX(KMGW,KLATN,JL)*(1.0-PDIST)+PX(KMGE,KLATN,JL)*PDIST
         ZS=PX(KMGW,KLATS,JL)*(1.0-PDIST)+PX(KMGE,KLATS,JL)*PDIST
         PXPF(JL)=ZN*Z2+ZS*Z1
100      CONTINUE
      ELSE
**       Extrapolate
         ZSIN1=SIN(PLAT1*GPI/180.0)
         ZSIN0=SIN(PLAT*GPI/180.0)
         ZSIN2=SIN(PLAT2*GPI/180.0)
         Z1=(ZSIN1-ZSIN0)/(ZSIN1-ZSIN2)
         Z2=(ZSIN0-ZSIN2)/(ZSIN1-ZSIN2)
         DO 200 JL=1,KNL
         ZN=PX(KMGW,KLATN,JL)*(1.0-PDIST)+PX(KMGE,KLATN,JL)*PDIST
         ZS=PX(KMGW,KLATS,JL)*(1.0-PDIST)+PX(KMGE,KLATS,JL)*PDIST
         PXPF(JL)=ZN*Z2+ZS*Z1
200      CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE INTREW(PX,KDIMX,KDIMY,KDIMZ,KWEST,KEAST,PZONAL,PDIST)
**    Function - To interpolate a gridpoint field in the west-east
**          direction on to a specified line of longitude, assuming that
**          the field has a constant gradient between gridpoints in this
**          direction. Note that no account is taken of 'underground'
**          data; ie no land/sea masks are employed.
**    Args in -
**               PX      - Array containing instantaneous PH data for a
**                         single field
**               KDIMX   - First dimension of PX (longitude)
**               KDIMY   - Second dimension of PX, and dimension of
**                         PZONAL (latitude)
**               KDIMZ   - Third dimension of PX, and second of PZONAL
**                         (vertical)
**               KWEST   - Western gridpoint limit to the interpolation
**               KEAST   - Eastern gridpoint limit to the interpolation
**               PDIST   - The output array will be interpolated to a
**                         longitude a fraction PDIST to the east of
**                         KWEST. (0.0<=PDIST<=1.0)
**    Args out -
**               PZONAL  - Interpolated zonal array
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - NSLONG
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PX(KDIMX,KDIMY,KDIMZ),PZONAL(KDIMY,KDIMZ)

**    Check validity of KWEST and KEAST
      IF(KEAST.LT.1.OR.(KEAST.GT.KDIMX)) THEN
         WRITE(6,6000)KEAST
6000     FORMAT(1X,'***INTREW: INCORRECT VALUE FOR KEAST =',I5)
         CALL ABORT
      ENDIF
      IF(KWEST.LT.1.OR.(KWEST.GT.KDIMX)) THEN
         WRITE(6,6010)KWEST
6010     FORMAT(1X,'***INTREW: INCORRECT VALUE FOR KWEST =',I5)
         CALL ABORT
      ENDIF

**    Interpolate
      DO 100 JK=1,KDIMZ
      DO 100 J=1,KDIMY
      PZONAL(J,JK)=(1.0-PDIST)*PX(KWEST,J,JK)+PDIST*PX(KEAST,J,JK)
100   CONTINUE

      RETURN
      END
      SUBROUTINE INTRNS(PXN,PLATN,PX0,PLAT0,PXS,PLATS,KDIMX)
**    Function - To interpolate a field of values north/south onto
**          another latitude - assume d(field)/d(sin(latitude)) is
**          constant. Note that no account is taken of
**          'underground' data; ie no land/sea masks are employed.
**    Args in -
**               PXN     - Field at latitude to north
**               PLATN   - Northern latitude
**               PLAT0   - Latitude at which interpolated values
**                         required
**               PXS     - Field at latitude to south
**               PLATS   - Southern latitude
**               KDIMX   - Dimension of PXN, PX0 and PXS
**    Args out -
**               PX0     - Interpolated field of values
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - WELAT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PX0(KDIMX),PXN(KDIMX),PXS(KDIMX)

      GPI=ATAN2(0.0,-1.0)
      ZSINN=SIN(PLATN*GPI/180.0)
      ZSIN0=SIN(PLAT0*GPI/180.0)
      ZSINS=SIN(PLATS*GPI/180.0)
      ZS0SNS=(ZSIN0-ZSINS)/(ZSINN-ZSINS)
      ZSN0NS=(ZSINN-ZSIN0)/(ZSINN-ZSINS)
      DO 100 J=1,KDIMX
      PX0(J)=PXN(J)*ZS0SNS+PXS(J)*ZSN0NS
100   CONTINUE

      RETURN
      END
      INTEGER FUNCTION LENSIG(YPCREC)
**    Function - To determine the length of the significant part of
**          a character string by searching for the first non-blank
**          character from the end
**    Args in -
**               YPCREC  - Character string
**    Args out -
**               LENSIG  - Length of YPCREC
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - CHOPEN,G14OUT,RELEAS
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code by
**          M Blackburn

      CHARACTER YPCREC*(*),YOBLNK*1

      YOBLNK=' '
      ICLEN=LEN(YPCREC)
      IL=ICLEN+1
      DO 100 I=ICLEN,1,-1
      IL=IL-1
      IF (YPCREC(I:I).NE.YOBLNK) GOTO 200
100   CONTINUE
      IL=IL-1
200   CONTINUE
      LENSIG=IL

      RETURN
      END
      SUBROUTINE LGNDRE(KJL,KJH,PSINL,PCOSL,PALP,PDALP,KMJP,KJGL,KMOCT,
     -      KMFP,KNFP)
**    Function - to calculate Associated Legendre Functions and their
**          meridional derivatives. Spectral truncation is jagged
**          triangular at total wavenumber JPNN, with equal numbers of
**          even and odd functions for each zonal wavenumber.
**          Includes zonal wavenumbers 0, KMOCT, 2*KMOCT,... to maximum
**          KNFP-1.
**    Args in -
**               KJL     - Latitude counter, refelecting the fact that
**                         only Legendre functions for KJGL latitudes
**                         are stored in memory simultaneously
**               KJH     - Counter for current latitude
**               PSINL   - Sine of the current latitude
**               PCOSL   - Cosine of the current latitude
**               KMJP    - Used to dimension PALP and PDALP
**               KJGL    - Used to dimension PALP and PDALP
**               KMOCT   - Longitude symmetry imposed
**               KMFP    - m
**               KNFP    - n
**    Args out -
**               PALP    - Associated Legendre function Pnm
**               PDALP   - Meridional derivative of PALP,
**                         = (1/a).(1-mu**2)dPnm/dmu
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - INILAT
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University (based on the algorithm in UFLUX2F)

      DIMENSION PALP(KMJP,KJGL),PDALP(KMJP,KJGL)

      ILM=2
      PALP(1,KJL)=SQRT(.5)
      ZF1M=SQRT(1.5)
      PALP(2,KJL)=ZF1M*PSINL
      PDALP(1,KJL)=0.

**    Zonal wavenumber loop
      DO 400 JM1=1,KMFP
      IM=JM1-1
      ZM=FLOAT(IM)
      Z2M=FLOAT(IM+IM)
      ZE2=SQRT(Z2M+3.)
      IF (IM.EQ.0) GOTO 100
      ZF2M=-ZF1M*PCOSL/SQRT(Z2M)
      ZF1M=ZF2M*ZE2
      IF (IM.NE.IMMO) GOTO 400
      ILM=ILM+1
      PALP(ILM,KJL)=ZF2M
      ILM=ILM+1
      PALP(ILM,KJL)=ZF1M*PSINL
      PDALP(ILM-1,KJL)=-ZM*PALP(ILM,KJL)/ZE2

100   CONTINUE
      IM2=IM+2
      IMMO=IM+KMOCT
      JFM=((KNFP-JM1)/2)*2+IM2-1
      IF (JFM.LT.IM2) GOTO 300
      IK=ILM-IM2+1
      ZMSQ=ZM*ZM
      DO 200 JN=IM2,JFM
      ZAN=JN
      ZAN2=JN*JN
      ZANM2=(JN-1)*(JN-1)
      ZE1=SQRT((ZANM2-ZMSQ)/(4.*ZANM2-1.))
      ZE2=SQRT((4.*ZAN2-1.)/(ZAN2-ZMSQ))
      PALP(IK+JN,KJL)=ZE2*(PSINL*PALP(IK+JN-1,KJL)-
     -      ZE1*PALP(IK+JN-2,KJL))
      PDALP(IK+JN-1,KJL)=(1.-ZAN)*PALP(IK+JN,KJL)/ZE2+
     -      ZAN*ZE1*PALP(IK+JN-2,KJL)
200   CONTINUE
      ILM=ILM+JFM-IM2+1

300   CONTINUE
      PDALP(ILM,KJL)=-ZAN*PSINL*PALP(ILM,KJL)+(ZAN+ZAN+1.)
     -     *PALP(ILM-1,KJL)/ZE2
400   CONTINUE


      RETURN
      END
      SUBROUTINE LLCONV(PXI,KI1,KI2,KI3,KI4,PXO,KO1,KO2,KO3,KLEV,
     -      LPWORK,PTEMP,KT1,KT2,KT3,KT4,LPEQV,KCHAN)
**    Function - to switch the indices of an SG-type array to an
**          easier-to-use longitude-by-latitude-by-height format
**    Args in -
**               PXI     - Input array
**               KI1     - First index of input array (eg JPMGPP)
**               KI2     - Second index of input array (eg JPNHEM)
**               KI3     - Third index of input array (eg JPNL)
**               KI4     - Fourth index of input array (eg JPJG)
**               KO1     - First index of output array (eg JPMGPP or
**                         JPMG)
**               KO2     - Second index of output array (eg JPJGG)
**               KO3     - Third index of output array (eg JPNL)
**               KLEV    - Number of levels containing 'real' data
**               LPWORK  - .TRUE. if the work array PTEMP can be used
**               KT1     - First index of work array
**               KT2     - Second index of work array
**               KT3     - Third index of work array
**               KT4     - Fourth index of work array
**               LPEQV   - .TRUE. if PXI and PXO are equivalenced to
**                         each other by the CALL statement
**               KCHAN   - Scratch channel that can be used for
**                         temporary storage
**    Args out -
**               PXO     - Output (re-arranged) array
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - COLTOT,SGINST,OPSG,OPTR,TRINST
**    Calls - ABORT
**    Files read - KCHAN
**    Files written - KCHAN
**    Author - R Brugge, University of Reading

      LOGICAL LPWORK,LPEQV,LOWORK
      DIMENSION PXI(KI1,KI2,KI3,KI4),PXO(KO1,KO2,KO3),
     -      PTEMP(KT1,KT2,KT3,KT4)

      LOWORK=LPWORK

**    Check that the index dimensions agree
      IF((KI1.LT.KO1).OR.(KI3.NE.KO3).OR.(KI2*KI4.NE.KO2)) THEN
         WRITE(6,6000)KI1,KI2,KI3,KI4,KO1,KO2,KO3
6000     FORMAT(1X,'***LLCONV: ERROR IN ARRAY DIMENSIONS',/10X,7I6)
         CALL ABORT
      ENDIF

      IF(KI2.NE.2) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***LLCONV: ERROR - ROUTINE WILL NOT WORK IF',
     -         ' KI2.NE.2')
         CALL ABORT
      ENDIF

      IF(.NOT.LPEQV) THEN
**    Since input and output arrays are not equivalenced, simply copy
**          from the input array to the output array
         DO 400 JLV=1,KLEV
         DO 410 JLAT=1,KI4
         ILAT=2*KI4+1-JLAT
         DO 420 JLNG=1,KO1
         PXO(JLNG,JLAT,JLV)=PXI(JLNG,1,JLV,JLAT)
         PXO(JLNG,ILAT,JLV)=PXI(JLNG,2,JLV,JLAT)
420      CONTINUE
410      CONTINUE
400      CONTINUE
         RETURN
      ENDIF

      IF(LOWORK) THEN
**    Cannot use work array unless its dimensions are correct
         IF((KT1.LT.KI1).OR.(KT2.LT.KI2).OR.(KT3.LT.KI3).OR.
     -         (KT4.LT.KI4)) LOWORK=.FALSE.
      ENDIF

      IF(LOWORK.AND.LPEQV) THEN
**    Copy input array to work array, and then copy elements of work
**          array to output array
         DO 1000 J4=1,KI4
         DO 1000 J3=1,KI3
         DO 1000 J2=1,KI2
         DO 1000 J1=1,KI1
         PTEMP(J1,J2,J3,J4)=PXI(J1,J2,J3,J4)
1000     CONTINUE
         DO 1100 JLV=1,KLEV
         DO 1110 JLAT=1,KI4
         ILAT=2*KI4+1-JLAT
         DO 1120 JLNG=1,KO1
         PXO(JLNG,JLAT,JLV)=PTEMP(JLNG,1,JLV,JLAT)
         PXO(JLNG,ILAT,JLV)=PTEMP(JLNG,2,JLV,JLAT)
1120     CONTINUE
1110     CONTINUE
1100     CONTINUE
         RETURN
      ENDIF

      IF((.NOT.LOWORK).AND.(LPEQV)) THEN
**    Input and output arrays are equivalenced, and no work space is
**          available - use KCHAN to store input array
         REWIND KCHAN
         DO 100 JLV=1,KLEV
         DO 110 JLAT=1,KI4
         WRITE(KCHAN)(PXI(JLNG,1,JLV,JLAT),JLNG=1,KI1)
110      CONTINUE
         DO 120 JLAT=KI4,1,-1
         WRITE(KCHAN)(PXI(JLNG,2,JLV,JLAT),JLNG=1,KI1)
120      CONTINUE
100      CONTINUE

         REWIND KCHAN
         DO 200 JLV=1,KLEV
         DO 210 JLAT=1,KO2
         READ(KCHAN)(PXO(JLNG,JLAT,JLV),JLNG=1,KO1)
210      CONTINUE
200      CONTINUE
         RETURN
      ENDIF

      END
      SUBROUTINE LMERGE(PELEM,KDIME,PSCAN,KDIMS,PINSRT,KDIMI,PMASK)
**    Function - to merge height/level elements into an array. An
**          array PSCAN is scanned to find the position of the element
**          containing the nearest value to element PELEM. PELEM is then
**          merged into array PINSRT at this position. After the insert,
**          the position in PSCAN is filled with PMASK, which should be
**          a value well outside the range of values expected in PSCAN,
**          such that repeated scans of this array will not reference
**          the element position again. In this way a sequence of
**          elements can be merged into PINSRT by repeated calls to this
**          routine, without overwriting any data that has previously
**          been inserted. The process is repeated until all PELEM
**          values have been merged.
**    Args in -
**               PELEM   - Elements to be merged into array PINSRT
**               KDIME   - Dimension of PELEM
**               PSCAN   - Array to be scanned to determine position of
**                         PELEM in PINSRT
**               KDIMS   - Dimension of PSCAN
**               PINSRT  - Array to be modified by insertion
**               KDIMI   - Dimension of PINSRT
**               PMASK   - Mask value to be incorporated into PSCAN
**    Args out -
**               PINSRT  - Modified by insertion of PELEM
**               PSCAN   - modified by inclusion of mask value
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - INIPLV,INTHLV
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PSCAN(KDIMS),PINSRT(KDIMI),PELEM(KDIME)

**    Check size of KDIME, KDIMS and KDIMI
      IF(KDIMS.NE.KDIMI) THEN
         WRITE(6,6000)KDIMS,KDIMI
6000     FORMAT(1X,'LMERGE: ERROR DIFFERENT VALUES FOR KDIMS, KDIMI: ',
     -         2I5)
         CALL ABORT
      ENDIF
      IF(KDIME.GT.KDIMS) THEN
         WRITE(6,6010)KDIMS,KDIME
6010     FORMAT(1X,'LMERGE: KDIME TOO LARGE: KDIMS, KDIME = ',
     -         2I5)
         CALL ABORT
      ENDIF

      IF(KDIMS.EQ.1) THEN
         PINSRT(1)=PELEM(1)
         PSCAN(1)=PMASK
         RETURN
      ENDIF

      DO 100 JE=1,KDIME
**    Check through PSCAN and find closest value to PELEM(JE)
      IPOS=1
      IDIFFN=ABS(PELEM(JE)-PSCAN(1))
      DO 1000 J=2,KDIMS
         IDIFF1=ABS(PELEM(JE)-PSCAN(J))
         IF(IDIFF1.LT.IDIFFN) THEN
            IPOS=J
            IDIFFN=IDIFF1
         ENDIF
1000  CONTINUE

      PINSRT(IPOS)=PELEM(JE)
      PSCAN(IPOS)=PMASK
100   CONTINUE

      RETURN
      END
      SUBROUTINE MRGLBM(PM,K1,K3,PG,PLVWT)
**    Function - To compute a global mean from a meridional mean,
**          using a weighting factor at each level in the vertical. Note
**          that land/air masks are not employed and therefore the
**          routine does not distinguish 'underground' data.
**    Args in -
**               PM      - Meridional mean data array
**               K1      - First (longitude) data dimension
**               K3      - Second (vertical) data dimension
**               PLVWT   - Vertical weighting factor
**    Args out -
**               PG      - Global mean
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - PHINST
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PM(K1,K3),PLVWT(K3)

      ZK1=1.0/FLOAT(K1)
      PG=0.0
      DO 100 JK=1,K3
      PG=PG+SSUM(K1,PM(1,JK),1)*ZK1*PLVWT(JK)
100   CONTINUE

      RETURN
      END
      SUBROUTINE NSLONG(PLON,KMG,PX,K1,K2,K3,PZ)
**    Function - To extract a 2D north-south slice at a specified
**          longitude from a 3D array of data. land/air masks are not
**          employed, and the routine does not distinguish
**          'underground' data.
**    Args in -
**               PLON    - Longitude where data required
**               KMG     - Number of equally-spaced longitudes where
**                         gridpoint data is known
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**    Args out -
**               PZ      - Zonal slice at required longitude
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - PHINST,OPPHTD,GZOUT,TZOUT
**    Calls - INTREW
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PX(K1,K2,K3),PZ(K2,K3)

      ZLON=PLON
100   CONTINUE
      IF(ZLON.LT.0.0) ZLON=ZLON+360.0
      IF(ZLON.GT.360.0) ZLON=ZLON-360.0
      IF(ZLON.GT.360.0.OR.(ZLON.LT.0.0)) GO TO 100

      ZDLON=360.0/FLOAT(KMG)
      IF(ZLON.GT.360.0-ZDLON) THEN
         IWEST=KMG
         IEAST=1
         ZDIST=(ZLON-360.0+ZDLON)/ZDLON
      ELSE
**       Determine west (IWEST) and east (IEAST) model longitudes
**       bordering ZLON
         ICNT=0
         ZLONW=-ZDLON
         ZLONE=0.0
500      ICNT=ICNT+1
         ZLONW=ZLONW+ZDLON
         ZLONE=ZLONE+ZDLON
         IF((ZLON.GE.ZLONW).AND.(ZLON.LE.ZLONE)) THEN
            IWEST=ICNT
            IEAST=ICNT+1
            ZDIST=(ZLON-ZLONW)/(ZLONE-ZLONW)
            GO TO 520
         ENDIF
         GO TO 500
      ENDIF
520   CONTINUE
      CALL INTREW(PX,K1,K2,K3,IWEST,IEAST,PZ,ZDIST)

      RETURN
      END
      SUBROUTINE RDNUGP(KCODE,PXNUGP,KIDIM,KJLATN,KJLATX,KHEM,KMGPP,
     -      KNUGP,KJG)
**    Function - Routine to read initial gridpoint data file
**    Args in -
**               KERR    - Error flag (set to 999 if fatal error found)
**               KCODE   - Code number defining fields to be read
**               KIDIM   - Dimension of PXNUGP array
**               KJLATN  - First latitude for which KNUGP will be read
**               KJLATX  - End latitude for which KNUGP will be read
**               KHEM    - Number of hemispheres for which data is
**                         stored on KNUGP
**               KMGPP   - Number of data elements on each latitude
**                         circle
**               KNUGP   - Initial gridpoint data file
**               KJG     - Total number of model latitudes in one
**                         hemisphere
**    Args out -
**               PXNUGP  - Contains KNUGP data from latitudes KJLATN to
**                         KJLATX, beginning in first element of the
**                         array. Data will be stored in (north, south)
**                         pairs if KHEM=2, from pole to equator. The
**                         data is not-non-dimensionalised by this
**                         routine.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - JPNFLD,JPDDRL
**    Called by - IGPDAT,INIROG,NLATLS
**    Calls - UNPAKX,ABORT
**    Files read - KNUGP(Initial gridpoint data file)
**    Files written - none
**    Author - R.Brugge, University of Reading

      PARAMETER (JPNFLD=39,JPDDRL=3072)
      DIMENSION PXNUGP(KIDIM)
      DIMENSION ICODM(JPNFLD),IDDR(JPDDRL),IPOS(JPNFLD)
      LOGICAL LOFND,LOUPCK,LOCALL
      SAVE IPOS,ICODM
      DATA ICODM/ 1, 6,11,42,12,43,13,44,45,46,61,62,63,64,65,
     -           55,56,14,15,16,66,67,68,69,70,71,72,73,74,48,
     -           49,50,51,17,52,53,18,54,19/
      DATA IPOS/   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 0,11,11,11,11,
     -           12,13,14,15,16, 0,17,18,19, 0,20,21,22,23,24,
     -           25,26,27,28,29,30,31,32,33/
      DATA LOCALL/.TRUE./

**    IPOS : Position on each KNUGP record of each of the fields
**          (0 indicates field not present)
**    ICODM : Code numbers of the fields on KNUGP (present and future
**          fields - ECMWF Research Manual 2, Table 6.9)

**    Key to KNUGP codes listed above
**        Codes marked + are not in use
**    Field:                                        F/cst name   Code:
**      Orography                                     GEOSP         1
**      Surface pressure                              APS           6
**      Surface temperature                           TS           11
**      Deep temperature                              TD           42
**      Surface moisture                              WS           12
**      Deep moisture                                 WD           43
**      Snow depth                                    SN           13
**      Land/sea mask                                 SLM          44
**      Roughness length                              AZ0          45
**      Solar albedo                                  ALB          46
**    Packed orographic variances:                    VARP         61+
**      E-W orographic variance                                    62
**      N-S orographic variance                                    63
**      NW-SE orographic variance                                  64
**      NE-SW orographic variance                                  65
**      Climate deep temperature                      TDCL         55
**      Climate deep moisture                         WDCL         56
**      Large scale precipitation                     APRL         14
**      Convective precipitation                      APRC         15
**      Snowfall precipitation                        APRS         16
**    Packed: Vegetation ratio, skin reservoir
**       content, variance of subgridscale orography  VEGRAT       66+
**      U component of GWD stress                     USTRGW       67
**      V component OF GWD stress                     VSTRGW       68
**      Vertical dissipation due to GWD               VDISGW       69
**      Accumulated cloud cover                       ALLCOV       70+
**      Accumulated rate of convective precipitation  ARPRC        71
**      Convective cloud tops                         NTOPC        72
**      Convective cloud bases                        NBASEC       73
**      Average vertical velocity in lowest layer     AVVEL        74
**      Surface solar radiation                       SRADS        48
**      Surface thermal radiation                     TRADS        49
**      Top solar radiation                           SRAD0        50
**      Top thermal radiation                         TRAD0        51
**      Vertical dissipation                          VDIS         17
**      U-stress                                      USTR         52
**      V-stress                                      VSTR         53
**      Sensible heat flux                            AHFS         18
**      Evaporation                                   EVAP         54
**      Latent heat flux                              AHFL         19

**    Check that KJLATN>=1 and KJLATX<=KJG
      IF(KJLATN.LT.1.OR.(KJLATX.GT.KJG)) THEN
         WRITE(6,6400)
6400     FORMAT(/,' ***RDNUGP: INVALID VALUE(S) FOR KJLATN AND/OR',
     -         ' KJLATX')
         CALL ABORT
      ENDIF
**    Check that KJLATX >= KJLATN
      IF(KJLATX.LT.KJLATN) THEN
         WRITE(6,6410)
6410     FORMAT(/,' ***RDNUGP: ERROR - KJLATX < KJLATN')
         CALL ABORT
      ENDIF

**    Check that array space declared is sufficient to hold the data to
**          be read
      ISIZE1=KIDIM
      ISIZE2=(KJLATX-KJLATN+1)*KHEM*KMGPP
      IF(ISIZE2.GT.ISIZE1) THEN
         WRITE(6,6000)
6000     FORMAT(/,' ***RDNUGP: INSUFFICIENT ARRAY SPACE PROVIDED FOR',
     -         ' DATA')
         WRITE(6,6010)ISIZE1,ISIZE2
6010     FORMAT('            WORDS PROVIDED: ',I15,
     -          ' WORDS REQUIRED: ',I15)
         CALL ABORT
      ENDIF

**    Check that the code number for the requested field is valid
      LOFND=.FALSE.
      DO 1000 JK=1,JPNFLD
      IF(KCODE.EQ.ICODM(JK)) THEN
         IPOSF=IPOS(JK)
         LOFND=.TRUE.
         IF((KCODE.EQ.61).OR.(KCODE.EQ.66).OR.(KCODE.EQ.70)) THEN
**          Valid code number - but not currently in use
            WRITE(6,6100)KCODE
6100        FORMAT(/,' ***RDNUGP: CODE ',I3,' NOT CURRENTLY IN USE')
            CALL ABORT
         ENDIF
         IF((KCODE.GE.62).AND.(KCODE.LE.65)) THEN
**          Valid code number - packed data
            LOUPCK=.TRUE.
**          IPKPOS - packed position of array
            IPKPOS=KCODE-61
         ENDIF
         IF((KCODE.EQ.1).OR.(KCODE.EQ.6).OR.(KCODE.GE.11.AND.
     -         KCODE.LE.19).OR.(KCODE.GE.42.AND.KCODE.LE.46).OR.
     -         (KCODE.EQ.48).OR.(KCODE.EQ.49).OR.(KCODE.GE.50.AND.
     -         KCODE.LE.56).OR.(KCODE.GE.67.AND.KCODE.LE.69).OR.
     -         (KCODE.GE.71.AND.KCODE.LE.74)) THEN
**          Valid code number - unpacked data
            LOUPCK=.FALSE.
         ENDIF
      ENDIF
      IF(LOFND) GO TO 20
1000  CONTINUE
      IF(.NOT.LOFND) THEN
**       Incorrect code number specified
         WRITE(6,6200)
6200     FORMAT(/,' ***RDNUGP: INCORRECT FIELD CODE NUMBER')
         WRITE(6,6210)KCODE
6210     FORMAT(' CODE NUMBER SUPPLIED WAS ',I3)
         CALL ABORT
      ENDIF

**    PROCESS DDRS AT BEGINNING OF FILE.

20    CONTINUE
      INDDR=0
      REWIND KNUGP
      READ(KNUGP) INEXT
      BACKSPACE KNUGP
30    READ(KNUGP) (IDDR(JI),JI=1,INEXT)
      INEXT=IDDR(3)
      INDDR=INDDR+1
      IF(LOCALL) WRITE(6,6300) INDDR,IDDR(1)
6300  FORMAT(/' DDR',I1,'   LENGTH = ',I5)
      IF (INDDR.EQ.1.AND.LOCALL) WRITE(6,6310) (IDDR(I),I=15,18)
6310  FORMAT(' DDR1 : NUMBER OF DDRS          =',I6/
     -       '        NUMBER OF DATA RECORDS  =',I6/
     -       '        MAX. DDR LENGTH         =',I6/
     -       '        MAX. DATA RECORD LENGTH =',I6)
      IF (INEXT.NE.0) GOTO 30
      IF(LOCALL) WRITE(6,6320) INDDR
6320  FORMAT(/' NUMBER OF DDRS READ = ',I4/)

**    Now read in the data, latitude by latitude
**    If(LOUPCK) then the data needs to be unpacked

**    ISKIPL - number of latitude pairs to be skipped
      ISKIPL=KJLATN-1

      IF(ISKIPL.GE.1) THEN
         DO 2000 J=1,ISKIPL
         READ(KNUGP)DUMMY
2000     READ(KNUGP)DUMMY
      ENDIF
**    INLATR - NUMBER OF LATITUDES TO READ
      INLATR=KJLATX-KJLATN+1

**    IRECSK (=IPOSF-1) is the number of fields to be skipped on each
**          record
      IRECSK=IPOSF-1
**    NSKIPD - number of data elements to skip on each record
      NSKIPD=IRECSK*KMGPP
      IGC=KMGPP*KHEM

      IF(IRECSK.EQ.0) THEN
         DO 3000 J=1,INLATR
         IOF=(J-1)*IGC
         READ(KNUGP)(PXNUGP(JI),JI=IOF+1,IOF+KMGPP)
         IF(KHEM.EQ.2)THEN
            READ(KNUGP)(PXNUGP(JI),JI=IOF+KMGPP+1,IOF+IGC)
         ENDIF
3000     CONTINUE
       ELSE
         DO 3100 J=1,INLATR
         IOF=(J-1)*IGC
         READ(KNUGP)(DUMMY,JI=1,NSKIPD),(PXNUGP(JI),JI=IOF+1,IOF+KMGPP)
         IF(KHEM.EQ.2)THEN
            READ(KNUGP)(DUMMY,JI=1,NSKIPD),(PXNUGP(JI),JI=IOF+KMGPP+1,
     -            IOF+IGC)
         ENDIF
3100     CONTINUE
      ENDIF

**    Rewind initial data file in case it is used later
      REWIND KNUGP

**    Now unpack the field if necessary
      IF(LOUPCK) THEN
         CALL UNPAKX(PXNUGP,KIDIM,IPKPOS)
      ENDIF

**    Prevent DDR output in future calls to this routine
      LOCALL=.FALSE.

      RETURN
      END
      SUBROUTINE RELEAS(KRTC,KU)
**    Function - Close fortran unit KU and delete associated unix file
**          'fort.'KU. Use CLOSE(..,STATUS='DELETE') rather than unix
**          command 'rm'. Open file first if necessary to recreate
**          connection.
**    Args in -
**               KU      - fortran unit number
**    Args out -
**               KRTC    - return code as follows:
**                            0 : successful completion.
**                            -1: error on INQUIRE.
**                            -2: unit not open and file does not
**                                exist.
**                            -3: close fails to delete file for opened
**                                unit.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - CHCLOS
**    Calls - FTNN,LENSIG
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code by
**          M Blackburn

      LOGICAL LOEXIS,LOPEN,LONAME
      CHARACTER YOFORT*8,YONAME*80

      KRTC=0
      CALL FTNN(KU,YOFORT)
      IFLEN=LENSIG(YOFORT)

**    Check status of fortran unit.
      INQUIRE(KU,ERR=90,OPENED=LOPEN,NAMED=LONAME,NAME=YONAME)

**    Check file name and setup as 'fort.'KU if not named.
      ILEN=0
      IF (LONAME) THEN
         ILEN=LENSIG(YONAME)
      ELSE
         ILEN=IFLEN
         YONAME(1:8)=YOFORT
      ENDIF
      WRITE(6,6000)KU,YONAME(1:ILEN)
6000  FORMAT(1X,'***RELEAS : UNIT ',I5,' : FILE ',/A)

**    If unit not opened, check for existence of file and open.
      IF (.NOT.LOPEN) THEN
         INQUIRE(FILE=YONAME(1:ILEN),ERR=91,EXIST=LOEXIS)
         IF (.NOT.LOEXIS) THEN
            WRITE(6,6010)YONAME(1:ILEN)
6010        FORMAT(1X,'***RELEAS : NON-EXISTENT FILE ',/A)
            KRTC=-2
            RETURN
         ENDIF
         OPEN(KU,FILE=YONAME(1:ILEN))
         WRITE(6,6020)KU,YONAME(1:ILEN)
6020     FORMAT(1X,'***RELEAS : UNIT ',I5,' FIRST REOPENED AS ',/A)
      ENDIF

**    Now close unit, deleting file.
      CLOSE(KU,STATUS='DELETE')
      INQUIRE(FILE=YONAME(1:ILEN),ERR=92,EXIST=LOEXIS)
      IF (LOEXIS) THEN
         WRITE(6,6030)KU,YONAME(1:ILEN)
6030     FORMAT(1X,'***RELEAS : UNIT ',I5,' : FILE NOT DELETED',/A)
         KRTC=-3
      ENDIF
      RETURN

**    Error trapping for inquire statements.
90    CONTINUE
      WRITE(6,6090)KU
6090  FORMAT(1X,'***RELEAS : ERROR ON INQUIRE ON UNIT ',I5)
      KRTC=-1
      RETURN

91    CONTINUE
      WRITE(6,6091)YONAME(1:ILEN)
6091  FORMAT(1X,'***RELEAS : ERROR ON INQUIRE ON FILE ',/A)
      KRTC=-1
      RETURN

92    CONTINUE
      WRITE(6,6092)YONAME(1:ILEN)
6092  FORMAT(1X,'***RELEAS : ERROR ON INQUIRE ON FILE AFTER CLOSE',/A)
      KRTC=-1

      RETURN
      END
      SUBROUTINE RESEQ1(PIN,KDIM1,KDIM2,KDIM3,POUT,KDIMX,KDIMY)
**    Function - to alter the sequencing of data in an 2D horizontal
**          array, and to output the new sequence in a different array
**    Args in -
**               PIN     - input array
**               KDIM1   - number of elements in input array along each
**                         latitude circle
**               KDIM2   - number of hemispheres of data contained in
**                         PIN
**               KDIM3   - number of latitudes of data per hemisphere
**                         contained in PIN
**               KDIMX   - number of elements in x-direction of output
**                         array
**               KDIMY   - number of elements in y-direction of output
**                         array
**    Args out -
**               POUT    - output array
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - IGPDAT,INIROG
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PIN(KDIM1,KDIM2,KDIM3),POUT(KDIMX,KDIMY)

      KERR=0
**    Check dimensions are correct for this routine
      IF(KDIM1.NE.KDIMX+2) THEN
         WRITE(6,6000) KDIM1,KDIMX
6000     FORMAT(1X,'***RESEQ1 ERROR: KDIM1, KDIMX = ',2I10)
         KERR=1
      ENDIF
      IF(KDIMY.NE.KDIM2*KDIM3) THEN
         WRITE(6,6020) KDIMY,KDIM2,KDIM3
6010     FORMAT(1X,'***RESEQ1 ERROR: KDIM2, KDIM3, KDIMY = ',3I10)
         KERR=1
      ENDIF
      IF(KDIM2.NE.1.AND.KDIM2.NE.2) THEN
         WRITE(6,6020) KDIM2
6020     FORMAT(1X,'***RESEQ1 ERROR: KDIM2 = ',I10)
         KERR=1
      ENDIF
      IF(KERR.EQ.1) CALL ABORT

**    Perform resequencing
      IJGGP=KDIM2*KDIM3+1
      DO 1000 J=1,KDIM3
      DO 1000 JHEM=1,KDIM2
      IF(JHEM.EQ.1) THEN
         JJ=J
      ELSE
         JJ=IJGGP-J
      ENDIF
      DO 1000 JI=1,KDIMX
      POUT(JI,JJ)=PIN(JI,JHEM,J)
1000  CONTINUE

      RETURN
      END
      SUBROUTINE SKIPF(KRTC,KUNIT,KNF)
**    Function - To skip forward past end-of-files on a fortran file.
**          Multiple EOF's skipped, allowing positioning of multi-file
**          COS datasets.
**    Args in -
**               KUNIT   - Fortran channel number of the file
**               KNF     - Number of files (EOFs) to be skipped
**    Args out -
**               KRTC    - Return code
**                            KRTC=0  : successful completion.
**                            KRTC=-1 : error on INQUIRE.
**                            KRTC=-2 : unit not opened.
**                            KRTC=-3 : EOF not reached.
**                            KRTC=-4 : End-of-data reached.
**                            KRTC=-5 : attempt to skip backwards : not
**                                      supported.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GETFIL
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code by
**          M Blackburn

      LOGICAL LOPEN,LOEOF
      CHARACTER YOFORM*11,YODUM*1

      KRTC=0

**    Check unit status and details.
      INQUIRE(KUNIT,ERR=900,OPENED=LOPEN,FORM=YOFORM)
      IF (.NOT.LOPEN) THEN
         PRINT *, ' ***SKIPF : UNIT ',KUNIT,
     -         ' NOT OPEN : SKIPF ABANDONED'
         KRTC=-2
         RETURN
      ENDIF

**    Forward skipping : position after KNF following EOF's.
      IF (KNF.GT.0 ) THEN
         IRMAX=1000000
         LOEOF=.FALSE.
         DO 400 JNF=1,KNF
         DO 100 JIR=1,IRMAX
         IF (YOFORM(1:9).EQ.'FORMATTED') THEN
            READ(KUNIT,*,END=200) YODUM
         ELSE
            READ(KUNIT,END=400)
         ENDIF
         LOEOF=.FALSE.
100      CONTINUE
         WRITE(6,*)' ***SKIPF : FAILED TO FIND EOF ',JNF,
     -         ' ON UNIT ',KUNIT
     -         ,' : ONLY ',JIR,' RECORDS SKIPPED IN LAST FILE'
         KRTC=-3
         RETURN
200      CONTINUE
         IF (LOEOF) THEN
            WRITE(6,*)' ***SKIPF : END OF DATA FOUND AFTER ',JNF,
     -            ' FILES WHILE SKIPPING ',KNF,' FILES ON UNIT ',KUNIT
            KRTC=-4
            RETURN
         ENDIF
         LOEOF=.TRUE.
400      CONTINUE
      ENDIF

      IF (KNF.LE.0) THEN
         WRITE(6,*)' ***SKIPF : ON UNIT ',KUNIT,
     -         ' : ATTEMPT TO SKIP ',KNF
     -         ,' FILES : BACKWARD SKIPPING NOT SUPPORTED'
         KRTC=-5
      ENDIF

      RETURN

**    Error trapping from inquire statement.
900   WRITE(6,*)' ***SKIPF : ERROR ON INQUIRE ON UNIT ',KUNIT
      KRTC=-1
      RETURN

      END
      SUBROUTINE UNPAKX(P,KLEN,KPKPOS)
**    Function - to unpack four fields stored in one array as 4 16-bit
**          integers, scaled by a factor 2*ITRUNC, and to return just
**          one (selected) field.
**    Args in -
**               P       - array containing four packed fields
**               KLEN    - length of array P
**               KPKPOS  - position of the unpacked field (1, 2, 3 OR 4)
**    Args out -
**               P       - the unpacked field
**    Aargs for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - RDNUGP
**    Calls - ABORT
**    Files read - none
**    Files written - none
**    Author - R.Brugge, University of Reading, based on code by
**          J.Thuburn

      DIMENSION P(KLEN)

      PRINT *,'UNPAKX HAS BEEN CALLED -- ABORT'
      CALL ABORT

**    Check that KPKPOS is in range 1 to 4
C      IF(KPKPOS.LT.0.OR.(KPKPOS.GT.5)) THEN
C         WRITE(6,6000)KPKPOS
C6000     FORMAT(/,'  KPKPOS .NE. 1, 2, 3 OR 4: VALUE IS ',I3)
C         CALL ABORT
C      ENDIF

C      ITRUNC=7
C      ITM48=ITRUNC-48
C      ITM32=ITRUNC-32
C      ITM16=ITRUNC-16

C      IMASK=SHIFTR(MASK(16),ITM48)

C      IF(KPKPOS.EQ.1) THEN
C         DO 100 I=1,KLEN
C         IP=P(I)
C         IA=AND(SHIFTR(IP,ITM48),IMASK)
C         P(I)=FLOAT(IA)
C100      CONTINUE
C      ELSE IF(KPKPOS.EQ.2) THEN
C         DO 200 I=1,KLEN
C         IP=P(I)
C         IA=AND(SHIFTR(IP,ITM32),IMASK)
C         P(I)=FLOAT(IA)
C200      CONTINUE
C      ELSE IF(KPKPOS.EQ.3) THEN
C         DO 300 I=1,KLEN
C         IP=P(I)
C         IA=AND(SHIFTR(IP,ITM16),IMASK)
C         P(I)=FLOAT(IA)
C300      CONTINUE
C      ELSE IF(KPKPOS.EQ.4) THEN
C         DO 400 I=1,KLEN
C         IP=P(I)
C         IA=AND(SHIFTR(IP,ITRUNC),IMASK)
C         P(I)=FLOAT(IA)
C400      CONTINUE
C      ENDIF

      RETURN
      END
      SUBROUTINE WELAT(PLAT,ALAT,PX,K1,K2,K3,PM)
**    Function - To extract a 2D west-east slice at a specified latitude
**          from a 3D array of data. Land/air masks are not employed,
**          and the routine does not distinguish 'underground' data.
**    Args in -
**               PLAT    - Latitude where data required
**               ALAT    - Latitudes where gridpoint data is known (deg)
**               PX      - Array containing data
**               K1      - First (longitude) data dimension
**               K2      - Second (latitude) data dimension
**               K3      - Third (vertical) data dimension
**    Args out -
**               PM      - Meridional slice at required latitude
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - PHINST,OPPHTD,GMOUT,TMOUT
**    Calls - ABORT,INTRNS,EXTRNS
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION PX(K1,K2,K3),ALAT(K2),PM(K1,K3)

**    Error checking
      IF(PLAT.LT.-90.0.OR.(PLAT.GT.90.0)) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***WELAT: ERROR IN VALUE OF PLAT =', F12.5)
         CALL ABORT
      ENDIF

      ZLATN=90.0
      ZLATS=ALAT(1)
      IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
         DO 100 JK=1,K3
         CALL EXTRNS(PM(1,JK),PLAT,PX(1,1,JK),ALAT(1),
     -         PX(1,2,JK),ALAT(2),K1)
100      CONTINUE
         RETURN
      ENDIF
      ZLATN=ZLATS
      DO 400 J=2,K2
      ZLATS=ALAT(J)
      IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
         DO 200 JK=1,K3
         CALL INTRNS(PX(1,J-1,JK),ZLATN,PM(1,JK),PLAT,PX(1,J,JK),
     -         ZLATS,K1)
200      CONTINUE
         RETURN
      ENDIF
      ZLATN=ZLATS
400   CONTINUE
      ZLATS=-90.0
      IF(PLAT.GE.ZLATS.AND.PLAT.LE.ZLATN) THEN
         DO 300 JK=1,K3
         CALL EXTRNS(PM(1,JK),PLAT,PX(1,K2,JK),ALAT(K2),
     -         PX(1,K2-1,JK),ALAT(K2-1),K1)
300      CONTINUE
         RETURN
      ENDIF

      END
      SUBROUTINE ASCOUT(PARRAY,KPTS,PGMIN,PGMAX,KCHAN,KCHAR)
**    Function - Pack and write a data array as a set of pairs of
**          characters. Uses the characters 0-9 and lower and upper case
**          A-Z only.
**    Args in -
**               PARRAY  - Real data array.
**               KPTS    - Dimension of array.
**               PGMIN   - Minimum value of array.
**               PGMAX   - Maximum value of array. Values larger than
**                         this will be assigned this value.
**               KCHAN   - Fortran channel for data output.
**               KCHAR   - Number of characters used to represent
**                         each datum value (2 in UTF 1.3)
**    Args out -
**               KCHAR   - Reset if invalid value supplied
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - JPCMAX,JPNASC,JPRECL
**    Called by - WTFUTF
**    Calls - none
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code written by
**          Kevin Dunn and Mike Blackburn (1989) and Max Rowe (1987)

      PARAMETER(JPCMAX=2,JPNASC=62,JPRECL=64)
      DIMENSION PARRAY(KPTS),ICODE(JPCMAX)
      CHARACTER*1 YOLKUP(63),YOASC(2*JPRECL)
      LOGICAL LASCII
      SAVE YOLKUP

**    UTF 1.3 only allows KCHAR=2
      IF(KCHAR.NE.2) KCHAR=2

**    Find scaling factor. Set to unity for zero field range.

      ZGAMAX=AMAX1(ABS(PGMAX),ABS(PGMIN))
      ZRANGE=PGMAX-PGMIN
      ZARANG=FLOAT(JPNASC**KCHAR)-1.0
      INTEGX=NINT(ZARANG)
      IF (ZRANGE.LE.ZGAMAX*1.E-3) THEN
         ZSCALE=0.
      ELSE
         ZSCALE=ZARANG/ZRANGE
      ENDIF

**    Scale data using range of field and encode each value
**    using subscript of look-up table character.
      ICBUFF=0
      DO 100 J=1,KPTS
      INTEG=MIN0(INTEGX,NINT((PARRAY(J)-PGMIN)*ZSCALE))
      INTEG=MAX0(INTEG,0)
      ICODE(1)=1+INTEG/JPNASC
      ICODE(2)=1+MOD(INTEG,JPNASC)
      YOASC(ICBUFF+1)=YOLKUP(ICODE(1))
      YOASC(ICBUFF+2)=YOLKUP(ICODE(2))
      ICBUFF=ICBUFF+KCHAR
      IF(ICBUFF.GE.JPRECL) THEN
**       Buffer ICBUFF contains more than a card image of data :
**       write out to KCHAN
         WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,JPRECL)
         DO 110 JJ=1,ICBUFF-JPRECL
         YOASC(JJ)=YOASC(JJ+JPRECL)
110      CONTINUE
         ICBUFF=ICBUFF-JPRECL
      ENDIF
100   CONTINUE
      IF(ICBUFF.NE.0) THEN
**       Flush character buffer
**       Write encoded data.
         WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,ICBUFF)
         ICBUFF=0
      ENDIF

      RETURN
      ENTRY ASCSET
**    Function - Define look-up table of characters. Table includes 0-9
**          and lower and upper case characters A-Z but not control
**          characters. ASCII or EBCDIC character sets are allowed and
**          test made to determine current set. Characters 1-JPNASC in
**          YOLKUP are used to represent integer values 1-JPNASC. The
**          range of the data field is scaled to JPNASC*JPNASC and KCHAR
**          characters used to represent each datum (KCHAR digits in
**          base JPNASC). 63rd character in YOLKUP is blank for possible
**          future masking.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GHDUTF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      LASCII=ICHAR('0').NE.240
      IF (LASCII) THEN
**       Implementation for ASCII characters.
         DO 210 J=1,10
210      YOLKUP(J)=CHAR(J+47)
         DO 220 J=11,36
220      YOLKUP(J)=CHAR(J+54)
         DO 230 J=37,62
230      YOLKUP(J)=CHAR(J+60)
         YOLKUP(63)=CHAR(32)
      ELSE
**       Implementation for EBCDIC characters
         DO 310 J=1,10
310      YOLKUP(J)=CHAR(J+239)
         DO 320 J=11,19
320      YOLKUP(J)=CHAR(J+182)
         DO 330 J=20,28
330      YOLKUP(J)=CHAR(J+189)
         DO 340 J=29,36
340      YOLKUP(J)=CHAR(J+197)
         DO 350 J=37,45
350      YOLKUP(J)=CHAR(J+92)
         DO 360 J=46,54
360      YOLKUP(J)=CHAR(J+99)
         DO 370 J=55,62
370      YOLKUP(J)=CHAR(J+107)
         YOLKUP(63)=CHAR(64)
      ENDIF

      RETURN
      END
      SUBROUTINE ENDUTF(KCHAN)
**    Note - this subroutine is applicable to UTF version 1.3
**    Function - To write end of data record
**    Args in -
**               KCHAN   - Fortran channel for data output.
**    Args out - None
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - MAINUF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      CHARACTER*21 YOEND,YOVER

      YOVER='***UTF 1.3***        '
      YOEND='***END OF DATA***    '
      WRITE(KCHAN,'(2(A21,4X),''.'')') YOEND,YOVER

      RETURN
      END
      SUBROUTINE GHDUTF(KNCHAN,KHR1,PALOND,KJPMG,PALAT,KJGG,
     -      PASIG,KNL,PBEGDY,PENDDY,PNTAPE,KNAME)
**    Note - this subroutine is applicable to UTF version 1.3
**    Function - to write the UTF global header
**    Args in -
**               KNCHAN  - Output channel for the UTF
**               KHR1    - 15 element array containing integers defining
**                         data/grid size
**               PALOND  - Longitude in degrees, eastwards from 0 deg
**               KJPMG   - Number of longitude values passed in PALOND
**               PALAT   - Latitudes in degress from north to south
**               KJGG    - Number of latitudes
**               PASIG   - Vertical level values
**               KNL     - Number of levels in the vertical
**               PBEGDY  - Start day of data
**               PENDDY  - End day of data
**               PNTAPE  - Run identifier
**               KNAME   - second global header title
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - /COMUTF/all elements
**    Params used - none
**    Called by - INIUTF
**    Calls - ASCSET
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION KHR1(15),PALOND(KJPMG),PALAT(KJGG),PASIG(KNL)
      INTEGER KNAME(2)
      CHARACTER*21 YOHDR,YOVER,YODAT
      CHARACTER*50 YOHT1,YOHT2
      CHARACTER*50 YFT1,YFT2D,YFT2T
      COMMON /COMUTF/YFT1,YFT2D,YFT2T

      YOHDR='***START OF HEADER***'
      YOVER='***UTF 1.3***        '
      YODAT='***START OF DATA***  '

      WRITE(KNCHAN,'(2(A21,4X),''.'')') YOHDR,YOVER
      WRITE(KNCHAN,'(15I5)') (KHR1(I),I=1,15)
      WRITE(KNCHAN,'((10F7.2))') (PALOND(I),I=1,KJPMG)
      WRITE(KNCHAN,'((10F7.2))') (PALAT(J),J=1,KJGG)
      IF (KNL.LE.19) THEN
         WRITE(KNCHAN,'((10F7.1))') (PASIG(L),L=1,KNL)
      ELSE IF (KNL.GT.19) THEN
         WRITE(KNCHAN,'(1P,5(1X,E12.5))') (PASIG(L),L=1,KNL)
      ENDIF
      WRITE(YOHT1,'(''RUN '',F8.3,5X,''DAYS '',F10.2,'' TO'',F10.2,5X)')
     -      PNTAPE,PBEGDY,PENDDY
      WRITE(KNCHAN,'(A50,''.'')') YOHT1
      WRITE(YOHT2,'(2A8,34X)') (KNAME(I),I=1,2)
      WRITE(KNCHAN,'(A50,''.'')') YOHT2
      WRITE(KNCHAN,'(2(A21,4X),''.'')') YODAT,YOVER

**    Initialise UTF field header arrays.
      WRITE(YFT1,'(50X)')
      WRITE(YFT2D,'(''RUN '',F8.3,3X,''DAY'',32X)') PNTAPE
      WRITE(YFT2T,'(''RUN '',F8.3,3X,''DAY'',10X,'' TO'',10X
     -      ,'' AVERAGE '')') PNTAPE

**    Initialise character look-up table for ASCOUT.
      CALL ASCSET

      RETURN
      END
      SUBROUTINE WTFUTF(PG,KX,KY,KPTYP,KCSTYL,KFDTYP,KLVTYP,KFRAME,KMSK
     -      ,PFMIN,PFMAX,PGINC,PDAY1,PDAY2,YPNAME,KCHAR,KCHAN,KASCII,
     -      KFAIL)
**    Note - this subroutine is applicable to UTF version 1.3
**    Function - To write array data field to the UTF output file
**    Args in -
**               PG      - The array containing data field
**               KX      - First dimension of data field
**               KY      - Second dimension of data field
**               KPTYP   - Integer value denoting plot type
**               KCSTYL  - Integer value denoting contour style or
**                         spacing of plotted vectors on grid
**               KFDTYP  - Integer value denoting type of field
**               KLVTYP  - Integer value denoting type of level
**               KFRAME  - Integer switch (0 or 1) specifying whether
**                         this field begins a new plot
**               KMSK    - Integer switch for orographic mask
**               PFMIN   - If non-zero, denotes minimum contour value
**               PFMAX   - If non-zero, denotes maximum contour value
**               PGINC   - Contour interval, or standard vector
**                         magnitude
**               PDAY1   - Day number of the data, or the first of a
**                         range of days
**               PDAY2   - End day of a range of days if PDAY2>PDAY1
**               YPNAME  - Name of field to be processed
**               KCHAR   - Character length of YPNAME
**               KCHAN   - Fortran channel for data output.
**               KASCII  - Number of characters used to encode each
**                         field value
**    Args out -
**               KFAIL   - Return error code
**                            0 : no errors
**                            1 : invalid parameter values
**                            2 : zero range of data
**    Args for work - none
**    Com used - none
**    Com changed - /COMUTF/YFT1,YFT2D,YFT2T
**    Params used - none
**    Called by - S13OUT,U13OUT
**    Calls - ASCOUT
**    Files read - none
**    Files written - KCHAN(UTF output file)
**    Author - R Brugge, University of Reading, based on code written by
**          Mike Blackburn

      CHARACTER*50 YFT1,YFT2D,YFT2T
      COMMON /COMUTF/YFT1,YFT2D,YFT2T
      DIMENSION PG(KX*KY)
      CHARACTER YPNAME*(*)
      DIMENSION IFR3(15)

      KFAIL=0
**    Error checking
      IF((KPTYP.LT.0).OR.(KPTYP.GT.13).OR.(KPTYP.EQ.9).OR.
     -      (KPTYP.EQ.10)) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***WTFUTF - INVALID VALUE FOR KPTYP')
         KFAIL=1
      ENDIF
      IF(KCSTYL.LT.-1.OR.(KCSTYL.GT.2))THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***WTFUTF - INVALID VALUE FOR KCSTYL')
         KFAIL=1
      ENDIF
      IF(KFDTYP.LT.0.OR.(KFDTYP.GT.6)) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'***WTFUTF - INVALID VALUE FOR KFDTYP')
         KFAIL=1
      ENDIF
      IF(KLVTYP.LT.0.OR.(KLVTYP.GT.3)) THEN
         WRITE(6,6030)
6030     FORMAT(1X,'***WTFUTF - INVALID VALUE FOR KLVTYP')
         KFAIL=1
      ENDIF
      IF(KFRAME.LT.0.OR.(KFRAME.GT.1)) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'***WTFUTF - INVALID VALUE FOR KFRAME')
         KFAIL=1
      ENDIF
      IF(KFAIL.EQ.1) RETURN

      IXY=KX*KY

**    Calculate minimum and maximum values of field if input values
**    are zero.
      IF (PFMIN.EQ.0.0.AND.PFMAX.EQ.0.0) THEN
         ZGMAX=PG(1)
         ZGMIN=PG(1)
         DO 1000 J=2,IXY
         ZGMAX=AMAX1(ZGMAX,PG(J))
         ZGMIN=AMIN1(ZGMIN,PG(J))
1000     CONTINUE
      ELSE
         ZGMIN=PFMIN
         ZGMAX=PFMAX
      ENDIF

**    Check range of field.
      ZRANGE=ZGMAX-ZGMIN
      ZGAMAX=AMAX1(ABS(ZGMIN),ABS(ZGMAX))
      IF (ZRANGE.LE.ZGAMAX*1.E-3) THEN
         WRITE(6,6910) YPNAME
6910     FORMAT(' ***WTFUTF : WARNING : ',A,' HAS ZERO RANGE')
         KFAIL=2
      ENDIF

**    Set up integer switch record.
      DO 400 I=1,15
      IFR3(I)=0
400   CONTINUE
      IFR3(1)=KX
      IFR3(2)=KY
      IFR3(3)=KPTYP
      IFR3(4)=KCSTYL
      IFR3(5)=KFDTYP
      IFR3(6)=KLVTYP
      IFR3(7)=KFRAME
      IFR3(9)=KMSK

**    Set up field title.
      WRITE(YFT1,'(50X)')
      INCHAR=MIN0(50,KCHAR)
      WRITE(YFT1(1:INCHAR),'(A)') YPNAME(1:INCHAR)

**    Write field header.
      WRITE(KCHAN,'(A50,''.'')') YFT1
      IF (PDAY1.GE.PDAY2) THEN
         WRITE(YFT2D(19:28),'(F10.2)') PDAY1
         WRITE(KCHAN,'(A50,''.'')') YFT2D
      ELSE
         WRITE(YFT2T(19:28),'(F10.2)')PDAY1
         WRITE(YFT2T(32:41),'(F10.2)')PDAY2
         WRITE(KCHAN,'(A50,''.'')') YFT2T
      ENDIF
      WRITE(KCHAN,'(15I5)') (IFR3(I),I=1,15)
      WRITE(KCHAN,'(1P,3E15.7)') ZGMIN,ZGMAX,PGINC

**    Pack and write data.
      CALL ASCOUT(PG,IXY,ZGMIN,ZGMAX,KCHAN,KASCII)

      RETURN
      END
      SUBROUTINE AOUT14(PARRAY,KPTS,PGMIN,PGMAX,KCHAN,KSCHAR)
**    Function - Pack and write a data array as a set of
**          characters. Uses the characters 0-9 and lower and upper case
**          A-Z only. Applicable to UTF1.4 only. The sign of PGMIN
**          must have been previously checked to ensure that logs
**          of the data can be taken if KSCHAR<0.
**    Args in -
**               PARRAY  - Real data array.
**               KPTS    - Dimension of array.
**               PGMIN   - Minimum value of array.
**               PGMAX   - Maximum value of array. Data with values
**                         greater than this will be assigned
**                         character codes representing PGMAX
**               KCHAN   - Fortran channel for data output.
**               KSCHAR  - Number of characters used to represent
**                         each datum value. If negative, then logs to
**                         base 10 are taken of the data before packing
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - JPNASC,JPRECL
**    Called by - WTFU14,WTGU14
**    Calls - ABORT
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code written by
**          Kevin Dunn and Mike Blackburn (1989) and Max Rowe (1987)

      PARAMETER(JPNASC=62,JPRECL=64,JPCMAX=20)
      DIMENSION PARRAY(KPTS),ICODE(JPCMAX)
      CHARACTER*1 YOLKUP(63),YOASC(2*JPRECL)
      LOGICAL LASCII
      SAVE YOLKUP

**    Only 20 ascii characters allowed (maximum) to pack each datum
**          value
      KCHAR=IABS(KSCHAR)
      IF(KCHAR.GT.JPCMAX) THEN
         WRITE(6,6000) JPCMAX
6000     FORMAT(1X,'***AOUT14 - NEED TO INCREASE JPCMAX TO ',I5)
         CALL ABORT
      ENDIF

      IF(KSCHAR.GT.0) THEN
**       Find scaling factor. Set to unity for zero field range.
         ZGAMAX=AMAX1(ABS(PGMAX),ABS(PGMIN))
         ZRANGE=PGMAX-PGMIN
         ZARANG=FLOAT(JPNASC**KCHAR)-1.0
         IF (ZRANGE.LE.ZGAMAX*1.E-3) THEN
            ZSCALE=0.
         ELSE
            ZSCALE=ZARANG/ZRANGE
         ENDIF
         INTEGX=NINT(ZARANG)

**       Scale data using range of field and encode each value
**       using subscript of look-up table character.
         IF(KCHAR.EQ.2) THEN
            ICBUFF=0
            DO 100 J=1,KPTS
            INTEG=MIN0(NINT((PARRAY(J)-PGMIN)*ZSCALE),INTEGX)
            INTEG=MAX0(INTEG,0)
            ICODE(1)=1+INTEG/JPNASC
            ICODE(2)=1+MOD(INTEG,JPNASC)
            YOASC(ICBUFF+1)=YOLKUP(ICODE(1))
            YOASC(ICBUFF+2)=YOLKUP(ICODE(2))
            ICBUFF=ICBUFF+KCHAR
            IF(ICBUFF.GE.JPRECL) THEN
**             Buffer ICBUFF contains more than a card image of data :
**             write out to KCHAN
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,JPRECL)
               DO 110 JJ=1,ICBUFF-JPRECL
               YOASC(JJ)=YOASC(JJ+JPRECL)
110            CONTINUE
               ICBUFF=ICBUFF-JPRECL
            ENDIF
100         CONTINUE
            IF(ICBUFF.NE.0) THEN
**             Flush character buffer
**             Write encoded data.
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,ICBUFF)
               ICBUFF=0
            ENDIF
         ELSE
            ICBUFF=0
            DO 200 J=1,KPTS
            INTEG=MIN0(NINT((PARRAY(J)-PGMIN)*ZSCALE),INTEGX)
            INTEG=MAX0(INTEG,0)
            DO 300 JC=KCHAR,1,-1
            ICODE(JC)=1+MOD(INTEG,JPNASC)
            YOASC(ICBUFF+JC)=YOLKUP(ICODE(JC))
            INTEG=INTEG/JPNASC
300         CONTINUE
            ICBUFF=ICBUFF+KCHAR
            IF(ICBUFF.GE.JPRECL) THEN
**             Buffer ICBUFF contains more than a card image of data :
**             write out to KCHAN
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,JPRECL)
               DO 3100 JJ=1,ICBUFF-JPRECL
               YOASC(JJ)=YOASC(JJ+JPRECL)
3100           CONTINUE
               ICBUFF=ICBUFF-JPRECL
            ENDIF
200         CONTINUE
            IF(ICBUFF.NE.0) THEN
**             Flush character buffer
**             Write encoded data.
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,ICBUFF)
               ICBUFF=0
            ENDIF
         ENDIF
      ELSE IF(KSCHAR.LT.0) THEN
         ZLGMIN=ALOG10(PGMIN)
**       Take logs to base 10 before packing
**       Find scaling factor. Set to unity for zero field range.
         ZGAMAX=AMAX1(ABS(ALOG10(PGMAX)),ABS(ZLGMIN))
         ZRANGE=ALOG10(PGMAX)-ZLGMIN
         ZARANG=FLOAT(JPNASC**KCHAR)-1.0
         INTEGX=NINT(ZARANG)
         IF (ZRANGE.LE.ZGAMAX*1.E-3) THEN
            ZSCALE=0.
         ELSE
            ZSCALE=ZARANG/ZRANGE
         ENDIF

**       Scale data using range of log field and encode each value
**       using subscript of look-up table character.
         IF(KCHAR.EQ.2) THEN
            ICBUFF=0
            DO 5100 J=1,KPTS
            INTEG=MIN0(NINT((ALOG10(PARRAY(J))-ZLGMIN)*ZSCALE),
     -            INTEGX)
            INTEG=MAX0(INTEG,0)
            ICODE(1)=1+INTEG/JPNASC
            ICODE(2)=1+MOD(INTEG,JPNASC)
            YOASC(ICBUFF+1)=YOLKUP(ICODE(1))
            YOASC(ICBUFF+2)=YOLKUP(ICODE(2))
            ICBUFF=ICBUFF+KCHAR
            IF(ICBUFF.GE.JPRECL) THEN
**             Buffer ICBUFF contains more than a card image of data :
**             write out to KCHAN
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,JPRECL)
               DO 5110 JJ=1,ICBUFF-JPRECL
               YOASC(JJ)=YOASC(JJ+JPRECL)
5110           CONTINUE
               ICBUFF=ICBUFF-JPRECL
            ENDIF
5100        CONTINUE
            IF(ICBUFF.NE.0) THEN
**             Flush character buffer
**             Write encoded data.
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,ICBUFF)
               ICBUFF=0
            ENDIF
         ELSE
            ICBUFF=0
            DO 5200 J=1,KPTS
            INTEG=MIN0(NINT((ALOG10(PARRAY(J))-ZLGMIN)*ZSCALE),
     -            INTEGX)
            INTEG=MAX0(INTEG,0)
            DO 5300 JC=KCHAR,1,-1
            ICODE(JC)=1+MOD(INTEG,JPNASC)
            YOASC(ICBUFF+JC)=YOLKUP(ICODE(JC))
            INTEG=INTEG/JPNASC
5300        CONTINUE
            ICBUFF=ICBUFF+KCHAR
            IF(ICBUFF.GE.JPRECL) THEN
**             Buffer ICBUFF contains more than a card image of data :
**             write out to KCHAN
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,JPRECL)
               DO 8100 JJ=1,ICBUFF-JPRECL
               YOASC(JJ)=YOASC(JJ+JPRECL)
8100           CONTINUE
               ICBUFF=ICBUFF-JPRECL
            ENDIF
5200        CONTINUE
            IF(ICBUFF.NE.0) THEN
**             Flush character buffer
**             Write encoded data.
               WRITE(KCHAN,'(64A1)') (YOASC(JC),JC=1,ICBUFF)
               ICBUFF=0
            ENDIF
         ENDIF
      ENDIF

      RETURN
      ENTRY ASCS14
**    Function - Define look-up table of characters. Table includes 0-9
**          and lower and upper case characters A-Z but not control
**          characters. ASCII or EBCDIC character sets are allowed and
**          test made to determine current set. Characters 1-JPNASC in
**          YOLKUP are used to represent integer values 1-JPNASC. The
**          range of the data field is scaled to JPNASC*JPNASC and KCHAR
**          characters used to represent each datum (KCHAR digits in
**          base JPNASC). 63rd character in YOLKUP is blank for possible
**          future masking.
**    Args in - none
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - GHDU14
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      LASCII=ICHAR('0').NE.240
      IF (LASCII) THEN
**       Implementation for ASCII characters.
         DO 210 J=1,10
210      YOLKUP(J)=CHAR(J+47)
         DO 220 J=11,36
220      YOLKUP(J)=CHAR(J+54)
         DO 230 J=37,62
230      YOLKUP(J)=CHAR(J+60)
         YOLKUP(63)=CHAR(32)
      ELSE
**       Implementation for EBCDIC characters
         DO 310 J=1,10
310      YOLKUP(J)=CHAR(J+239)
         DO 320 J=11,19
320      YOLKUP(J)=CHAR(J+182)
         DO 330 J=20,28
330      YOLKUP(J)=CHAR(J+189)
         DO 340 J=29,36
340      YOLKUP(J)=CHAR(J+197)
         DO 350 J=37,45
350      YOLKUP(J)=CHAR(J+92)
         DO 360 J=46,54
360      YOLKUP(J)=CHAR(J+99)
         DO 370 J=55,62
370      YOLKUP(J)=CHAR(J+107)
         YOLKUP(63)=CHAR(64)
      ENDIF

      RETURN
      END
      SUBROUTINE EUTF14(KCHAN)
**    Note - this subroutine is applicable to UTF version 1.4
**    Function - To write end of data record
**    Args in -
**               KCHAN   - Fortran channel for data output.
**    Args out - None
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - MAINUF
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading (Tested 21-07-92)

      CHARACTER*21 YOEND,YOVER

      YOVER='***UTF 1.4***        '
      YOEND='***END OF DATA***    '
      WRITE(KCHAN,'(2(A21,4X),''$'')') YOEND,YOVER

      RETURN
      END
      SUBROUTINE GHDU14(KNCHAN,KHR1,PALOND,KJPMG,PALAT,KJGG,
     -      PASIG,KNL,PBEGDY,PENDDY,PNTAPE,KNAME,PFRQDY)
**    Note - this subroutine is applicable to UTF version 1.4
**    Function - to write the UTF global header
**    Args in -
**               KNCHAN  - Output channel for the UTF
**               KHR1    - 15 element array containing integers defining
**                         data/grid size
**               PALOND  - Longitude in degrees, eastwards from 0 deg
**               KJPMG   - Number of longitude values passed in PALOND
**               PALAT   - Latitudes in degress from north to south
**               KJGG    - Number of latitudes
**               PASIG   - Vertical level values
**               KNL     - Number of levels in the vertical
**               PBEGDY  - Start day of data
**               PENDDY  - End day of data
**               PNTAPE  - Run identifier
**               KNAME   - second global header title
**               PFRQDY  - Time interval (days) between data in time
**                         series
**    Args out - none
**    Args for work - none
**    Com used - none
**    Com changed - /COMUTF/all elements
**    Params used - none
**    Called by - INIU14
**    Calls - AOUT14
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      DIMENSION KHR1(15),PALOND(KJPMG),PALAT(KJGG),PASIG(KNL)
      INTEGER KNAME(2)
      CHARACTER*21 YOHDR,YOVER,YODAT
      CHARACTER*50 YOHT1,YOHT2
      CHARACTER*50 YFT1,YFT2D,YFT2T
      COMMON /COMUTF/YFT1,YFT2D,YFT2T

      YOHDR='***START OF HEADER***'
      YOVER='***UTF 1.4***        '
      YODAT='***START OF DATA***  '

      WRITE(KNCHAN,'(2(A21,4X),''$'')') YOHDR,YOVER
      WRITE(KNCHAN,'(11I5,I5.4,I5.4,I5.2,I5)') (KHR1(I),I=1,15)
      WRITE(KNCHAN,'((10F7.2))') (PALOND(I),I=1,KJPMG)
      WRITE(KNCHAN,'((10F7.2))') (PALAT(J),J=1,KJGG)
      WRITE(KNCHAN,'(1P,5(1X,E12.5))') (PASIG(L),L=1,KNL)

      IF(KHR1(11).NE.0) THEN
         ID1=0
         ID2=NINT((PENDDY-PBEGDY)/PFRQDY)
         ID3=1
         WRITE(KNCHAN,'(5(1X,F13.5))')(PBEGDY+FLOAT(JID)*PFRQDY,
     -         JID=ID1,ID2,ID3)
      ENDIF

      WRITE(YOHT1,'(''RUN '',F8.3,5X,''DAYS '',F10.2,'' TO'',F10.2,5X)')
     -      PNTAPE,PBEGDY,PENDDY
      WRITE(KNCHAN,'(A50,''$'')') YOHT1
      WRITE(YOHT2,'(2A8,34X)') (KNAME(I),I=1,2)
      WRITE(KNCHAN,'(A50,''$'')') YOHT2
      WRITE(KNCHAN,'(2(A21,4X),''$'')') YODAT,YOVER

**    Initialise UTF field header arrays in /COMUTF/
      WRITE(YFT1,'(50X)')
      WRITE(YFT2D,'(''RUN '',F8.3,3X,''DAY'',32X)') PNTAPE
      WRITE(YFT2T,'(''RUN '',F8.3,3X,''DAY'',10X,'' TO'',10X
     -      ,''         '')') PNTAPE

**    Initialise character look-up table for ASCOUT.
      CALL ASCS14

      RETURN
      END
      SUBROUTINE INIU14(KNAME,KNCHAN,KFAIL,KMG,KJG,KNL,KNHEM,KMOCT,
     -      KJTYP,KLTYP,KMM,KNN,KNWJ2,KTIME,KYEAR,KDAY,KMIN,PALOND,
     -      PASIG,PALAT,KJGG,PBEGDY,PENDDY,PFRQDY,PNTAPE)
**    Note - this subroutine is applicable to UTF version 1.4
**    Function - to initialise the UTF data
**    Args in -
**               KNAME   - Second global title for the UTF header
**               KNCHAN  - Output channel for the UTF
**               KMG     - Number of longitudes
**               KJG     - Number of latitudes (pole-equator)
**               KNL     - Number of data levels
**               KNHEM   - Number of hemispheres
**               KMOCT   - Global symmetry factor
**               KJTYP   - Latitude coordinate type
**               KLTYP   - Vertical coordinate type used in header
**                         record
**               KMM     - Highest zonal wavenumber in spectral
**                         truncation
**               KNN     - Highest total wavenumber in spectral
**                         truncation
**               KNWJ2   - Number of odd or even spectral coefficients
**                         in spectral truncation
**               KTIME   - Size of header array containing coordinate
**                         time points
**               KYEAR   - Year and month of data in file or date of
**                         initial data
**               KDAY    - Day and hour of data in file
**               KMIN    - Minutes of data in file
**               PALOND  - Longitudes in degrees
**               PASIG   - Vertical levels from top to bottom
**               PALAT   - Latitudes in degrees from north to south
**               KJGG    - Dimension of PALAT
**               PBEGDY  - Day number of start of data
**               PENDDY  - Day number of end of data
**               PFRQDY  - Day interval between data
**               PNTAPE  - Job identification number
**    Args out -
**               KFAIL   - Error code returned
**                            0 : no errors detected
**                            1 : invalid parameter(s)
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - UTF14
**    Calls - GHDU14
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      INTEGER KNAME(2)
      DIMENSION IHR1(15),PALOND(KMG)
      DIMENSION PASIG(KNL),PALAT(KJGG)

      KFAIL=0
**    Parameter checking
      IF(KMG.LE.0) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KMG')
         KFAIL=1
      ENDIF
      IF(KJG.LE.0) THEN
         WRITE(6,6001)
6001     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KJG')
         KFAIL=1
      ENDIF
      IF(KNL.LE.0) THEN
         WRITE(6,6002)
6002     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KNL')
         KFAIL=1
      ENDIF
      IF(KNHEM.NE.2.AND.KNHEM.NE.1) THEN
         WRITE(6,6003)
6003     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KNHEM')
         KFAIL=1
      ENDIF
      IF(KMOCT.LE.0) THEN
         WRITE(6,6004)
6004     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KMOCT')
         KFAIL=1
      ENDIF
      IF(KJTYP.NE.0.AND.KJTYP.NE.1) THEN
         WRITE(6,6005)
6005     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KJTYP')
         KFAIL=1
      ENDIF
      IF(KLTYP.LT.0.OR.(KJTYP.GT.4)) THEN
         WRITE(6,6006)
6006     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KLTYP')
         KFAIL=1
      ENDIF
      IF(KMM.LE.0) THEN
         WRITE(6,6007)
6007     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KMM')
         KFAIL=1
      ENDIF
      IF(KNN.LE.0) THEN
         WRITE(6,6008)
6008     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KNN')
         KFAIL=1
      ENDIF
      IF(KNWJ2.LE.0) THEN
         WRITE(6,6009)
6009     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KNWJ2')
         KFAIL=1
      ENDIF
      IF(KTIME.LT.0) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KTIME')
         KFAIL=1
      ENDIF
      IF(KYEAR.LT.0) THEN
         WRITE(6,6011)
6011     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KYEAR')
         KFAIL=1
      ENDIF
      IF(KDAY.LT.0) THEN
         WRITE(6,6012)
6012     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KDAY')
         KFAIL=1
      ENDIF
      IF(KMIN.LT.0) THEN
         WRITE(6,6013)
6013     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KMIN')
         KFAIL=1
      ENDIF
      IF(KJGG.LE.0) THEN
         WRITE(6,6014)
6014     FORMAT(1X,'***INIU14 : INVALID VALUE FOR KJGG')
         KFAIL=1
      ENDIF

      IF(KFAIL.GT.1) RETURN

**    Set up the UTF global header data
      IHR1(1)=KMG
      IHR1(2)=KJG
      IHR1(3)=KNL
      IHR1(4)=KNHEM
      IHR1(5)=KMOCT
      IHR1(6)=KJTYP
      IHR1(7)=KLTYP
      IHR1(8)=KMM
      IHR1(9)=KNN
      IHR1(10)=KNWJ2
      IHR1(11)=KTIME
      IHR1(12)=KYEAR
      IHR1(13)=KDAY
      IHR1(14)=KMIN
      IHR1(15)=0

**    Write out the UTF global header
      CALL GHDU14(KNCHAN,IHR1,PALOND,KMG,PALAT,KJGG,PASIG,KNL,
     -      PBEGDY,PENDDY,PNTAPE,KNAME,PFRQDY)
      RETURN
      END
      SUBROUTINE U14OUT(PX,KDIMX,KDIMY,KDATX,KPTYP,KCSTYL,KFDTYP,
     -      KLVTYP,KFRAME,KMSK,PCINT,KHEM,YPNAME,
     -      KCHAR,KCHAN,KASCII,KFAIL,PDAY1,PDAY2,PXVALS,PYVALS,
     -      YPXLAB,YPYLAB,KCX,KCY,KTFLAG,PPX)
**    Function - To control UTF14 production for a field to be
**          contoured, or for a field of vector components
**    Args in -
**               PX      - Array containing data for a
**                         single field
**               KDIMX   - First dimension of PX
**               KDIMY   - Second dimension of PX
**               KDATX   - Number of 'real' data values in first
**                         dimension
**               KPTYP   - Integer value denoting plot type
**               KCSTYL  - Integer value denoting contour style or
**                         spacing of plotted vectors on grid
**               KFDTYP  - Integer value denoting type of field
**               KLVTYP  - Integer value denoting type of level
**               KFRAME  - Integer switch (0 or 1) specifying whether
**                         this field begins a new plot
**               KMSK    - Integer switch for orographic mask
**               PCINT   - Contour interval supplied by user, or length
**                         of the standard arrow
**               KHEM    - Number of hemispheres in array PX
**               PDAY1   - Current day number, or the first of a
**                         range of days
**               PDAY2   - End of a range of days, if PDAY2>PDAY1
**               YPNAME  - Character array name
**               KCHAR   - Number of characters in YPNAME
**               KCHAN   - Channel to which UTF is written
**               PXVALS  - X-axis coordinates - used if KPTYP=0
**               PYVALS  - Y-axis coordinates - used if KPTYP=0
**               YPXLAB  - X-axis label - used if KPTYP=0
**               YPYLAB  - Y-axis label - used if KPTYP=0
**               KCX     - Number of characters in x-axis label
**               KCY     - Number of characters in y-axis label
**               KASCII  - Number of characters used to encode each
**                         field value
**               KFAIL   - Return error code
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time-average
**                            2 : time-series
**    Args out - none
**    Args for work - none
**               PPX     - Stores a copy of PX, with 'real' data only
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - HROUT,IGPDAT,INIROG,MSKPL,OPPHTD,OPPHTS,OPSGTS,OPTRTS,
**          OPXPTS,PHINST,SGVEC,THOUT
**    Calls - GPREP,WTFU14
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

      CHARACTER*(*) YPNAME,YPXLAB,YPYLAB
      DIMENSION PX(KDIMX,KDIMY),PXVALS(KDATX),PYVALS(KDIMY)
      DIMENSION PPX(KDATX,KDIMY)

      KFAIL=0

      IF(KDATX.GT.KDIMX) THEN
         KFAIL=999
      ELSE
         DO 100 JJ=1,KDIMY
         DO 100 JI=1,KDATX
         PPX(JI,JJ)=PX(JI,JJ)
100      CONTINUE

**       Determine maximum and minimum array values and determine
**             contour interval
         IF(KFDTYP.EQ.1.OR.KFDTYP.EQ.2) THEN
**          Vectors
            ZINT=0.0
         ELSE
**          Contours
            ZINT=PCINT
         ENDIF
         CALL GPREP(PPX,KDATX*KDIMY,ZINT,ZGINC,ZGMAX,ZGMIN,KFAIL)
         IF(KFDTYP.EQ.1.OR.KFDTYP.EQ.2) THEN
**          Vectors; use PCINT to determine arrow length, and ignore the
**          value of ZGINC returned from GPREP
            ZGINC=PCINT
         ENDIF
      ENDIF

**    Finally, write out the UTF field
      IF(KFAIL.EQ.0) THEN
         CALL WTFU14(PPX,KDATX,KDIMY,KPTYP,KCSTYL,KFDTYP,
     -         KLVTYP,KFRAME,KMSK,ZGMIN,ZGMAX,ZGINC,PDAY1,PDAY2,
     -         YPNAME,KCHAR,KCHAN,PXVALS,PYVALS,YPXLAB,
     -         YPYLAB,KCX,KCY,KASCII,KFAIL,KTFLAG)
      ELSE
         WRITE(6,6020)KFAIL
6020     FORMAT(1X,'***U14OUT : KFAIL = ',I5)
         WRITE(6,6030)PDAY1,PDAY2,YPNAME
6030     FORMAT(1X,'***U14OUT : NO UTF AT DAY ',E10.3,'-',E10.3,
     -         ' FOR FIELD :',/A)
      ENDIF

      RETURN
      END
      SUBROUTINE WTAU141(KPTS, KATTR, KTRAJ, KASCII, YPATTR, PATTR,
     -      KCHAN, KFAIL)
**    Function - To write out optional trajectory attributes to a
**          UTF, version 1.4.
**    Args in -
**               KPTS    - Number of points along a single trajectory
**               KATTR   - Number of attributes per trajectory
**               KTRAJ   - Number of trajectories
**               KASCII  - Number of characters per packed data value
**                         in UTF
**               YPATTR  - Character*42 array containing all the
**                         attribute titles
**               PATTR   - Array containing all the attributes for all
**                         the points along the trajectories, ordered
**                         (KPTS,KTRAJ,KATTR).
**               KCHAN   - Output channel, must already be open.
**    Args out -
**               KFAIL   - Error flag. Returns 0 on success, while 1
**                         indicates an invalid argument.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by -
**    Calls - ARBNDS,AOUT14
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code written
**          by Glenn Carver (ACMG) and Jeff Cole (CGAM).

      DIMENSION PATTR(KPTS,KTRAJ,KATTR)
      CHARACTER*50 YPATTR(KATTR)

**    Initialise local variables and check input arguments
      KFAIL = 0
      KLEN = KPTS*KTRAJ
      IF ( KPTS .LT. 1 ) THEN
         WRITE(6, 6001)
6001     FORMAT (1X, '** ERROR IN WTAU141: KPTS MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KATTR .LT. 1 ) THEN
         WRITE(6, 6002)
6002     FORMAT (1X, '** ERROR IN WTAU141: KATTR MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KTRAJ .LT. 1 ) THEN
         WRITE(6, 6003)
6003     FORMAT (1X, '** ERROR IN WTAU141: KTRAJ MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KASCII .LT. 1 ) THEN
         WRITE(6, 6004)
6004     FORMAT (1X, '** ERROR IN WTAU141: KASCII MUST BE  GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF

      IF ( KFAIL .NE. 0 ) RETURN

**    Pack the optional attribute records
      DO 410 J = 1, KATTR
      WRITE (KCHAN,9922) YPATTR(J)
9922  FORMAT(A50, '$')
      CALL ARBNDS(PATTR(1,1,J), KLEN, ZMIN, ZMAX, KFAIL)
      WRITE (KCHAN, '(1P,2E15.7)') ZMIN, ZMAX
      CALL AOUT14(PATTR(1,1,J), KLEN, ZMIN, ZMAX, KCHAN, KASCII)
410   CONTINUE

      RETURN
      END

      SUBROUTINE WTAU140(KPTS, KATTR, KTRAJ, KASCII, YPATTR, PATTR,
     -      KCHAN, KFAIL)
**    Function - To write out optional trajectory attributes to a
**          UTF, version 1.4.
**    Args in -
**               KPTS    - Number of points along a single trajectory
**               KATTR   - Number of attributes per trajectory
**               KTRAJ   - Number of trajectories
**               KASCII  - Number of characters per packed data value
**                         in UTF
**               YPATTR  - Character*42 array containing all the
**                         attribute titles
**               PATTR   - Array containing all the attributes for all
**                         the points along the trajectories, ordered
**                         (KPTS,KTRAJ,KATTR).
**               KCHAN   - Output channel, must already be open.
**    Args out -
**               KFAIL   - Error flag. Returns 0 on success, while 1
**                         indicates an invalid argument.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by -
**    Calls - ARBNDS,AOUT14
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code written
**          by Glenn Carver (ACMG) and Jeff Cole (CGAM).

      DIMENSION PATTR(KPTS,KTRAJ,KATTR)
      CHARACTER*50 YPATTR(KATTR)

**    Initialise local variables and check input arguments
      KFAIL = 0
      IF ( KPTS .LT. 1 ) THEN
         WRITE(6, 6001)
6001     FORMAT (1X, '** ERROR IN WTAU140: KPTS MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KATTR .LT. 1 ) THEN
         WRITE(6, 6002)
6002     FORMAT (1X, '** ERROR IN WTAU140: KATTR MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KTRAJ .LT. 1 ) THEN
         WRITE(6, 6003)
6003     FORMAT (1X, '** ERROR IN WTAU140: KTRAJ MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KASCII .LT. 1 ) THEN
         WRITE(6, 6004)
6004     FORMAT (1X, '** ERROR IN WTAU140: KASCII MUST BE  GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF

      IF ( KFAIL .NE. 0 ) RETURN

**    Pack the optional attribute records
      DO 420 JT = 1, KTRAJ
      DO 410 J = 1, KATTR
      WRITE (KCHAN,9922) YPATTR(J)
9922  FORMAT(A50, '$')
      CALL ARBNDS(PATTR(1,JT,J), KPTS, ZMIN, ZMAX, KFAIL)
      WRITE (KCHAN, '(1P,2E15.7)') ZMIN, ZMAX
      CALL AOUT14(PATTR(1,JT,J), KPTS, ZMIN, ZMAX, KCHAN, KASCII)
410   CONTINUE
420   CONTINUE

      RETURN
      END
      SUBROUTINE WTFU14(PG,KX,KY,KPTYP,KCSTYL,KFDTYP,KLVTYP,KFRAME
     -      ,KMSK,PFMIN,PFMAX,PGINC,PDAY1,PDAY2,YPNAME,KCHAR,KCHAN
     -      ,PXVALS,PYVALS,YPXLAB,YPYLAB,KCX,KCY,KASCII,KFAIL,KTFLAG)
**    Note - this subroutine is applicable to UTF version 1.4
**    Function - To write data field to the UTF output file
**    Args in -
**               PG      - The array containing data field
**               KX      - First dimension of data field
**               KY      - Second dimension of data field
**               KPTYP   - Integer value denoting plot type
**               KCSTYL  - Integer value denoting contour style or
**                         spacing of plotted vectors on grid
**               KFDTYP  - Integer value denoting type of field
**               KLVTYP  - Integer value denoting type of level
**               KFRAME  - Integer switch (0 or 1) specifying whether
**                         this field begins a new plot
**               KMSK    - Integer switch for orographic mask
**               PFMIN   - If non-zero, denotes minimum contour value
**               PFMAX   - If non-zero, denotes maximum contour value
**               PGINC   - Contour interval, or standard vector
**                         magnitude
**               PDAY1   - Day number of the data, or the first of a
**                         range of days
**               PDAY2   - End day of a range of days if PDAY2>PDAY1
**               YPNAME  - Name of field to be processed
**               KCHAR   - Character length of YPNAME
**               KCHAN   - Fortran channel for data output
**               PXVALS  - X-axis coordinates - used if KPTYP=0
**               PYVALS  - Y-axis coordinates - used if KPTYP=0
**               YPXLAB  - X-axis label - used if KPTYP=0
**               YPYLAB  - Y-axis label - used if KPTYP=0
**               KCX     - Number of characters in x-axis label
**               KCY     - Number of characters in y-axis label
**               KASCII  - Number of characters used to encode each
**                         field value
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time-average
**                            2 : time-series
**    Args out -
**               KFAIL   - Return error code
**                            0 : no error
**                            1 : invalid parameter value
**                            2 : zero data range
**    Args for work - none
**    Com used - none
**    Com changed - /COMUTF/YFT1,YFT2D,YFT2T
**    Params used - none
**    Called by - U14OUT
**    Calls - AOUT14
**    Files read - none
**    Files written - KCHAN(UTF output file)
**    Author - R Brugge, University of Reading, based on code written by
**          Mike Blackburn

      CHARACTER*50 YFT1,YFT2D,YFT2T
      COMMON /COMUTF/YFT1,YFT2D,YFT2T
      DIMENSION PG(KX*KY),PXVALS(KX),PYVALS(KY)
      CHARACTER*(*) YPNAME,YPXLAB,YPYLAB
      DIMENSION IFR3(15)

      KFAIL=0
**    Error checking
      IF((KPTYP.LT.0).OR.(KPTYP.GT.24)) THEN
         WRITE(6,6000)
6000     FORMAT(1X,'***WTFU14 - INVALID VALUE FOR KPTYP')
         KFAIL=1
      ENDIF
      IF((KCSTYL.LT.-1.OR.(KCSTYL.GT.2)).AND.KFDTYP.NE.0)THEN
         WRITE(6,6010)
6010     FORMAT(1X,'***WTFU14 - INVALID VALUE FOR KCSTYL')
         KFAIL=1
      ENDIF
      IF(KFDTYP.LT.0.OR.(KFDTYP.GT.6)) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'***WTFU14 - INVALID VALUE FOR KFDTYP')
         KFAIL=1
      ENDIF
      IF(KLVTYP.LT.0.OR.(KLVTYP.GT.5)) THEN
         WRITE(6,6030)
6030     FORMAT(1X,'***WTFU14 - INVALID VALUE FOR KLVTYP')
         KFAIL=1
      ENDIF
      IF(KFRAME.LT.0.OR.(KFRAME.GT.1)) THEN
         WRITE(6,6040)
6040     FORMAT(1X,'***WTFU14 - INVALID VALUE FOR KFRAME')
         KFAIL=1
      ENDIF
      IF(KFAIL.EQ.1) RETURN

      IXY=KX*KY
**    Calculate minimum and maximum values of field if input values
**    are zero.
      IF (PFMIN.EQ.0.0.AND.PFMAX.EQ.0.0) THEN
         ZGMAX=PG(1)
         ZGMIN=PG(1)
         DO 1000 J=2,IXY
         ZGMAX=AMAX1(ZGMAX,PG(J))
         ZGMIN=AMIN1(ZGMIN,PG(J))
1000     CONTINUE
      ELSE
         ZGMIN=PFMIN
         ZGMAX=PFMAX
      ENDIF

**    Check range of field.
      ZRANGE=ZGMAX-ZGMIN
      ZGAMAX=AMAX1(ABS(ZGMIN),ABS(ZGMAX))
      IF (ZRANGE.LE.ZGAMAX*1.E-3) THEN
         WRITE(6,6050) YPNAME
6050     FORMAT(' ***WTFU14 : WARNING : ',A,' HAS ZERO RANGE')
         KFAIL=2
      ENDIF

**    Check that logarithms can be taken
      IF(ZGMIN.LE.0.0.AND.KASCII.LT.0) THEN
         IASC=IABS(KASCII)
         WRITE(6,6060)
6060     FORMAT(1X,'***WTFU14: LOGARITHMS REQUESTED FOR A FIELD ',
     -         'CONTAINING VALUES <=0 ; LOGS NOT TAKEN')
      ELSE
         IASC=KASCII
      ENDIF
      IF(IASC.EQ.0) IASC=2

**    Set up integer switch record.
      DO 400 I=1,15
      IFR3(I)=0
400   CONTINUE
      IFR3(1)=KX
      IFR3(2)=KY
      IFR3(3)=KPTYP
      IFR3(4)=KCSTYL
      IFR3(5)=KFDTYP
      IFR3(6)=KLVTYP
      IFR3(7)=KFRAME
      IFR3(9)=KMSK
      IFR3(10)=IASC

**    Set up field title.
      WRITE(YFT1,'(50X)')
      INCHAR=MIN0(50,KCHAR)
      WRITE(YFT1(1:INCHAR),'(A)') YPNAME(1:INCHAR)

**    Write field header.
      WRITE(KCHAN,'(A50,''$'')') YFT1
      IF (PDAY1.GE.PDAY2) THEN
         WRITE(YFT2D(19:28),'(F10.2)') PDAY1
         WRITE(KCHAN,'(A50,''$'')') YFT2D
      ELSE
         WRITE(YFT2T(19:28),'(F10.2)')PDAY1
         WRITE(YFT2T(32:41),'(F10.2)')PDAY2
         IF(KTFLAG.EQ.1) THEN
            WRITE(YFT2T(43:49),'(''AVERAGE'')')
         ELSE IF(KTFLAG.EQ.2) THEN
            WRITE(YFT2T(43:49),'(''SERIES '')')
         ENDIF
         WRITE(KCHAN,'(A50,''$'')') YFT2T
      ENDIF
      WRITE(KCHAN,'(15I5)') (IFR3(I),I=1,15)

      IF(KPTYP.EQ.0) THEN
**       Output axis information
         INCHAR=MIN0(50,KCX)
         WRITE(YFT1,'(50X)')
         WRITE(YFT1(1:INCHAR),'(A)')YPXLAB(1:INCHAR)
         WRITE(KCHAN,'(A50,''$'')') YFT1
         INCHAR=MIN0(50,KCY)
         WRITE(YFT1,'(50X)')
         WRITE(YFT1(1:INCHAR),'(A)')YPYLAB(1:INCHAR)
         WRITE(KCHAN,'(A50,''$'')') YFT1
         WRITE(KCHAN,'(1P,6E12.5)')(PXVALS(J),J=1,KX)
         WRITE(KCHAN,'(1P,6E12.5)')(PYVALS(J),J=1,KY)
      ENDIF

      IF(IASC.GT.0) THEN
         WRITE(KCHAN,'(1P,3E15.7)') ZGMIN,ZGMAX,PGINC
      ELSE
         WRITE(KCHAN,'(1P,3E15.7)')ALOG10(ZGMIN),ALOG10(ZGMAX),PGINC
      ENDIF

**    Pack and write data.
      CALL AOUT14(PG,IXY,ZGMIN,ZGMAX,KCHAN,IASC)
      KFAIL=0

      RETURN
      END
      SUBROUTINE WTGU14(PX,PY,KPTS,KCURVE,KPTYP,KSTYL,KFDTYP,KLVTYP,
     -      KFRAME,KCODE,KXTYP,PXMIN,PXMAX,YPTITL,YPXLAB,YPYLAB,
     -      YPLLAB,PDAY1,PDAY2,KNPCA,KASCII,KFAIL,KTFLAG)
**    Function - Writes the graph data fields to the UTF.
**          The routine assumes that the
**          UTF file has been initialised and that the global header has
**          been written. This version is compatible with UTF1.4.
**    Args in -
**               PX      - Array containing the x-axis data. This data
**                         is only written to the UTF if KXTYP is zero.
**               PY      - Array containing y-axis values of the curves.
**               KPTS    - Number of data points on each curve. The size
**                         of PX and the first dimension of PY.
**               KCURVE  - Number of curves, second dimension of PY.
**               KPTYP   - Plot type, in the range 31 to 34 inclusive.
**               KSTYL   - Orientation of dependent variable axis. May
**                         be either 0 (horizontal) or 1 (vertical).
**               KFDTYP  - Field type (must be 6 for graphs).
**               KLVTYP  - Level type. Only used if KXTYP=3.
**               KFRAME  - Switch for this plot to begin a new frame.
**                         Either 0 or 1.
**               KCODE   - MARS field code (not currently used)
**               KXTYP   - Type of x-axis (independent variable).
**                            0 - x-axis data written to UTF
**                         For non-zero values, data is not written to
**                         UTF but should be taken from global header:
**                            1 - latitude
**                            2 - longitude
**                            3 - levels
**                            4 - time
**               PXMIN   - )Min and max of x-axis. If KXTYP=0, these
**               PXMAX   - )values are not used. If KXTYP is non-zero
**                         )they indicate the min and max on the x-axis
**                         )from the selected global header.
**               YPTITL  - CHARACTER*50 graph title.
**               YPXLAB  - CHARACTER*50 label for x-axis.
**               YPYLAB  - CHARACTER*50 label for y-axis.
**               YPLLAB  - Line labels, CHARACTER*8 YPLLAB(5).
**               PDAY1   - Day number, or first of a range of days if
**                         PDAY1,PDAY2.
**               PDAY2   - Last of a range of days if PDAY1<PDAY2.
**               KNPCA   - Channel number of the UTF.
**               KASCII  - Number of ascii characters used to pack the
**                         data. A negative treated is treated as
**                         positive.
**               KTFLAG  - Integer flag to specify type of time-slice
**                            0 : instantaneous
**                            1 : time-average
**                            2 : time-series
**    Args out -
**               KFAIL   - 0 : routine was successful, else non-zero.
**                         1 : input parameter not valid, out of range.
**                         3 : x-axis data <=0 and log is required.
**                         4 : either PXMIN, PXMAX is <=0 and log is
**                             required.
**                         5 : y-axis data <=0 and log is required.
**    Args for work - none
**    Com used - none
**    Com changed - /COMUTF/YFT2D,YFT2T
**    Params used - none
**    Called by - G14OUT
**    Calls - AOUT14
**    Files read - none
**    Files written - KNPCA
**    Author - R Brugge, University of Reading, based on code by
**          G Carver for UFLUX2H

      CHARACTER*50 YFT1,YFT2D,YFT2T
      COMMON /COMUTF/YFT1,YFT2D,YFT2T
      DIMENSION PX(KPTS),PY(KPTS,KCURVE)
      CHARACTER*50 YPTITL,YPXLAB,YPYLAB
      CHARACTER*8 YPLLAB(KCURVE)
      LOGICAL LOLOG
      DIMENSION IFR3(15)

      KFAIL = 0

**    Check input parameters
      IF(KCURVE.LT.1) THEN
         WRITE(6,6001)
6001     FORMAT(1X,'** ERROR IN WTGUTF: KCURVE MUST BE BETWEEN 1 AND 5',
     -         ' INCLUSIVE.',/)
         KFAIL=1
      ENDIF
      IF(KPTYP.LT.31.OR.KPTYP.GT.34) THEN
         WRITE (6,6002)
6002     FORMAT(1X,'** ERROR IN WTGUTF: KPTYP MUST BE BETWEEN 31 AND',
     -         ' 34 INCLUSIVE.',/)
         KFAIL=1
      ENDIF
      IF(KSTYL.LT.0.OR.KSTYL.GT.1) THEN
         WRITE(6,6003)
6003     FORMAT(1X,'** ERROR IN WTGUTF: KSTYL MUST BE EITHER 0 OR 1.'/)
         KFAIL=1
      ENDIF
      IF(KFDTYP.NE.6) THEN
         WRITE(6,6004)
6004     FORMAT(1X,'** ERROR IN WTGUTF: KFDTYP MUST BE 6.'/)
         KFAIL=1
      ENDIF
      IF(KLVTYP.LT.0.OR.KLVTYP.GT.5) THEN
         WRITE(6,6005)
6005     FORMAT(1X,'** ERROR IN WTGUTF: KLVTYP MUST BE BETWEEN 0 AND 4',
     -         ' INCLUSIVE.'/)
         KFAIL=1
      ENDIF
      IF(KFRAME.LT.0.OR.KFRAME.GT.1) THEN
         WRITE(6,6006)
6006     FORMAT(1X,'** ERROR IN WTGUTF: KFRAME MUST BE 0 OR 1.'/)
         KFAIL=1
      ENDIF
      IF(KXTYP.LT.0.OR.KXTYP.GT.4) THEN
         WRITE(6,6007)
6007     FORMAT(1X,'** ERROR IN WTGUTF: KXTYP MUST BE BETWEEN 0 AND 4',
     -         ' INCLUSIVE.'/)
         KFAIL=1
      ENDIF
      IF(KASCII.EQ.0) THEN
         WRITE(6,6008)
6008     FORMAT(1X,'** ERROR IN WTGUTF : KASCII MUST BE NON-ZERO'/)
         KFAIL=1
      ENDIF

      IF(KFAIL.GT.0) RETURN

**    Compute max and min values of the data
      IF(KXTYP.EQ.0) THEN
         ZDMIN=PX(1)
         ZDMAX=ZDMIN
         DO 200 J=1,KPTS
         ZDMIN=AMIN1(ZDMIN,PX(J))
         ZDMAX=AMAX1(ZDMAX,PX(J))
200      CONTINUE
      ENDIF
      ZYMIN=PY(1,1)
      ZYMAX=ZYMIN
      DO 210 JC=1,KCURVE
      DO 210 J=1,KPTS
      ZYMIN=AMIN1(ZYMIN,PY(J,JC))
      ZYMAX=AMAX1(ZYMAX,PY(J,JC))
210   CONTINUE

**    The following piece of code is not part of the UTF standard.
**    It is used to search for those data elements that may represent
**    masked data points.
**    ZMSKVC is equivalent to AMSKVC in /COMMSK/

C*****hack:limit on exponent for single prec ifc
C     ZMSKVC=1.0E40
      ZMSKVC=1.0E35

**    If the maximum value found corresponds to a mask value, find
**    the second highest value
      IF(KXTYP.EQ.0) THEN
         IF(ZDMAX.GT.ZMSKVC) THEN
            ZDMAX=ZDMIN
            DO 100 J=1,KPTS
            IF(PX(J).LT.ZMSKVC) ZDMAX=AMAX1(ZDMAX,PX(J))
100         CONTINUE
         ENDIF
      ENDIF
      IF(ZYMAX.GT.ZMSKVC) THEN
         ZYMAX=ZYMIN
         DO 102 JC=1,KCURVE
         DO 102 J=1,KPTS
         IF(PY(J,JC).LT.ZMSKVC) ZYMAX=AMAX1(ZYMAX,PY(J,JC))
102      CONTINUE
      ENDIF

**    If the minimum value found corresponds to a mask value, find
**    the second lowest value
      ZNMASK=-ZMSKVC
      IF(KXTYP.EQ.0) THEN
         IF(ZDMIN.LT.ZNMASK) THEN
            ZDMIN=ZDMAX
            DO 101 J=1,KPTS
            IF(PX(J).GT.ZNMASK) ZDMIN=AMIN1(ZDMIN,PX(J))
101         CONTINUE
         ENDIF
      ENDIF
      IF(ZYMIN.LT.ZNMASK) THEN
         ZYMIN=ZYMAX
         DO 103 JC=1,KCURVE
         DO 103 J=1,KPTS
         IF(PY(J,JC).GT.ZNMASK) ZYMIN=AMIN1(ZYMIN,PY(J,JC))
103      CONTINUE
      ENDIF
**    End of the non-standard UTF code

      IF(KXTYP.EQ.0) THEN
         ZXMAX=ZDMAX
         ZXMIN=ZDMIN
      ELSE
         ZXMIN=PXMIN
         ZXMAX=PXMAX
      ENDIF
      IASCII=KASCII

**    Set up the field header
      DO 215 J=1,15
      IFR3(J)=0
215   CONTINUE
      IFR3(1)=KPTS
      IFR3(2)=KCURVE
      IFR3(3)=KPTYP
      IFR3(4)=KSTYL
      IFR3(5)=KFDTYP
      IFR3(6)=KLVTYP
      IFR3(7)=KFRAME
      IFR3(8)=KXTYP
      IFR3(10)=IASCII

**    Check if log of the x-data required and, if so, that all values
**    are positive
      LOLOG=IASCII.LT.0

**    X values - check ZDMIN, ZXMIN, ZDMAX and ZXMAX
      IF(LOLOG.AND.
     -      (KXTYP.NE.0.AND.(PXMIN.LT.0.0.OR.PXMAX.LT.0.0))) KFAIL=4
      IF(LOLOG.AND.
     -      (KXTYP.EQ.0.AND.(ZDMIN.LT.0.0.OR.ZDMAX.LT.0.0))) KFAIL=3
      IF(KFAIL.NE.0 ) THEN
         WRITE(6,6010)
6010     FORMAT(1X,'**ERROR IN WTGUTF: EITHER X AXIS DATA CONTAINS',
     -         ' NON-POSITIVE DATA OR PXMIN OR PXMAX ARE NON-POSITIVE')
         LOLOG=.FALSE.
         IASCII=IABS(IASCII)
         IFR3(10)=IASCII
         WRITE(6,6011)
6011     FORMAT(1X,'***WTGUTF - NON-LOG PACKING WILL BE USED')
      ENDIF

**    Y values - check ZYMAX, ZYMIN
      IF(LOLOG.AND.
     -      (ZYMIN.LT.0.0.OR.ZYMAX.LT.0.0)) KFAIL=5
      IF(KFAIL.EQ.5) THEN
         WRITE(6,6020)
6020     FORMAT(1X,'**ERROR IN WTGUTF: Y AXIS DATA CONTAINS ',
     -         'NON-POSITIVE VALUES')
         LOLOG=.FALSE.
         IASCII=IABS(IASCII)
         IFR3(10)=IASCII
         WRITE(6,6021)
6021     FORMAT(1X,'***WTGUTF - NON-LOG PACKING WILL BE USED')
      ENDIF

**    Write out UTF field header
      WRITE(KNPCA,6030) YPTITL
6030  FORMAT(A50,'$')
      IF(PDAY1.GT.PDAY2) THEN
         WRITE (YFT2D(19:28),'(F10.2)')PDAY1
         WRITE (KNPCA,6030) YFT2D
      ELSE
         WRITE (YFT2T(19:28),'(F10.2)')PDAY1
         WRITE (YFT2T(32:41),'(F10.2)')PDAY2
         IF(KTFLAG.EQ.1) THEN
            WRITE(YFT2T(43:49),'(''AVERAGE'')')
         ELSE IF(KTFLAG.EQ.2) THEN
            WRITE(YFT2T(43:49),'(''SERIES '')')
         ENDIF
         WRITE (KNPCA,6030) YFT2T
      ENDIF
      WRITE (KNPCA,'(15I5)') (IFR3(J),J=1,15)
      IF(LOLOG) THEN
         ZXMAXT=ALOG10(ZXMAX)
         ZXMINT=ALOG10(ZXMIN)
         ZYMAXT=ALOG10(ZYMAX)
         ZYMINT=ALOG10(ZYMIN)
      ELSE
         ZXMAXT=ZXMAX
         ZXMINT=ZXMIN
         ZYMAXT=ZYMAX
         ZYMINT=ZYMIN
      ENDIF

      WRITE(KNPCA,'(1P,4E15.7)')ZXMINT,ZXMAXT,ZYMINT,ZYMAXT

**    If KXTYP is zero, write out the X-axis data
      IF(KXTYP.EQ.0) THEN
         WRITE(KNPCA,6030)YPXLAB
         CALL AOUT14(PX,KPTS,ZXMIN,ZXMAX,KNPCA,IASCII)
      ENDIF

**    Write out the Y-axis curves
      WRITE(KNPCA,6030)YPYLAB
      WRITE(KNPCA,6040)(YPLLAB(J),J=1,KCURVE)
6040  FORMAT(5(A8,'$',1X))
      CALL AOUT14(PY,KPTS*KCURVE,ZYMIN,ZYMAX,KNPCA,IASCII)

      RETURN
      END
      SUBROUTINE WTTU14(YPT1, YPT2, KPTS, KCOORDS, KPTYP, KLVTYP,
     -           KFRAME, KATTR, KTRAJ, KASCII, PTIME, PLONG, PLAT,
     -           PLEV, KCHAN, KFAIL)
**    Function - to write out the mandatory part of trajectory
**          information to the UTF (version 1.4). The routine enables any
**          number of trajectories to be encoded.
**    Args in -
**               YPT1    - Character*50 field title 1.
**               YPT2    - Character*50 field title 2.
**               KPTS    - Number of points along a single trajectory.
**                         The first dimension of the trajectory arrays.
**               KCOORDS - Number of coordinate types for trajectory
**                         data. Must be either 3 or 4. A value of 3
**                         will suppress the output of level data.
**               KPTYP   - Plot type, to set the desired projection.
**               KLVTYP  - Level type, for levels that data is present.
**               KFRAME  - set to 1 for a new frame, else set to 0.
**               KATTR   - Number of attributes per trajectory. Attribute
**                         records aare optional.
**               KTRAJ   - Number of trajectories. The second dimension
**                         of the input trajectory arrays.
**               KASCII  - Number of characters to be used when packing
**                         data into the UTF. It cannot be negative
**                         since log-packing of negative latitudes is
**                         not allowed.
**               PTIME   - The time coordinates of the trajectories
**                         in units of days.
**               PLONG   - The longitude coordinates of all the
**                         trajectories.
**               PLAT    - The latitudes of all the trajectories.
**               PLEV    - The level coordinates of the trajectories.
**                         Not used if KCOORDS.eq.3.
**               KCHAN   - UTF output channel.
**    Args out -
**               KFAIL   - Error code. 0 indicates success, 1 indicates
**                         invalid argument passed to routine.
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by -
**    Calls - ARBNDS,AOUT14
**    Files read - none
**    Files written - KCHAN
**    Author - R Brugge, University of Reading, based on code
**          by Glenn Carver (ACMG) and Jeff Cole (CGAM).

      DIMENSION      PTIME(KPTS), PLONG(KPTS,KTRAJ), PLAT(KPTS,KTRAJ)
      DIMENSION      PLEV(KPTS,KTRAJ)
      CHARACTER*50   YPT1, YPT2

**    Initialise local variables and check input arguments.

      KFAIL = 0
      IUNUSED = 0
      IFDTYP  = 5
      KLEN = KPTS*KTRAJ
      IF ( KPTS .LT. 1 ) THEN
         WRITE(6, 6001)
6001     FORMAT (1X, '** ERROR IN WTTU14: KPTS MUST BE GREATER',
     -         ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KCOORDS .NE. 3 .AND. KCOORDS .NE. 4 ) THEN
         WRITE(6, 6002)
6002     FORMAT (1X, '** ERROR IN WTTU14: KOORDS MUST BE EITHER',
     -               ' 3 OR 4.'/)
         KFAIL = 1
      ENDIF
      IF ( KPTYP .LT. 1 .OR. KPTYP .GT. 10 ) THEN
         WRITE(6, 6003)
6003     FORMAT (1X, '** ERROR IN WTTU14: KPTYP MUST BE BETWEEN 1 AND',
     -               ' 10 INCLUSIVE.'/)
         KFAIL = 1
      ENDIF
      IF ( KLVTYP .LT. 0 .OR. KLVTYP .GT. 5 ) THEN
         WRITE(6, 6004)
6004     FORMAT (1X, '** ERROR IN WTTU14: KLVTYP MUST BE BETWEEN 0 AND',
     -               ' 4 INCLUSIVE.'/)
         KFAIL = 1
      ENDIF
      IF ( KFRAME .NE. 0 .AND. KFRAME .NE. 1 ) THEN
         WRITE(6, 6005)
6005     FORMAT (1X, '** ERROR IN WTTU14: KFRAME MUST BE EITHER',
     -               ' 0 OR 1.'/)
         KFAIL = 1
      ENDIF
      IF ( KATTR .LT. 0 ) THEN
         WRITE(6, 6006)
6006     FORMAT (1X, '** ERROR IN WTTU14: KATTR MUST BE GREATER',
     -               ' THAN -1.'/)
         KFAIL = 1
      ENDIF
      IF ( KTRAJ .LT. 1 ) THEN
         WRITE(6, 6007)
6007     FORMAT (1X, '** ERROR IN WTTU14: KTRAJ MUST BE GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF
      IF ( KASCII .LT. 1 ) THEN
         WRITE(6, 6008)
6008     FORMAT (1X, '** ERROR IN WTTU14: KASCII MUST BE  GREATER',
     -               ' THAN 0.'/)
         KFAIL = 1
      ENDIF

      IF ( KFAIL .NE. 0 ) RETURN

**    Write out the trajectory header - titles and integer switches
      WRITE (KCHAN,9920) YPT1, YPT2
9920  FORMAT(A50,'$',/,A50,'$')
      WRITE (KCHAN,9921) KPTS, KCOORDS, KPTYP, IUNUSED, IFDTYP, KLVTYP,
     -      KFRAME, KATTR, KTRAJ, KASCII, IUNUSED, IUNUSED, IUNUSED,
     -      IUNUSED, IUNUSED
9921  FORMAT( 15I5 )

**    Pack the mandatory trajectory records
      CALL ARBNDS( PTIME, KPTS, ZMIN, ZMAX, KFAIL )
      WRITE (KCHAN, '(1P,2E15.7)') ZMIN, ZMAX
      CALL AOUT14( PTIME, KPTS, ZMIN, ZMAX, KCHAN, KASCII )
C
      CALL ARBNDS( PLONG, KLEN, ZMIN, ZMAX, KFAIL )
      WRITE (KCHAN, '(1P,2E15.7)') ZMIN, ZMAX
      CALL AOUT14( PLONG, KLEN, ZMIN, ZMAX, KCHAN, KASCII )
C
      CALL ARBNDS( PLAT, KLEN, ZMIN, ZMAX, KFAIL )
      WRITE (KCHAN, '(1P,2E15.7)') ZMIN, ZMAX
      CALL AOUT14( PLAT, KLEN, ZMIN, ZMAX, KCHAN, KASCII )
C
      IF ( KCOORDS .EQ. 4 ) THEN
         CALL ARBNDS( PLEV, KLEN, ZMIN, ZMAX, KFAIL )
         WRITE (KCHAN, '(1P,2E15.7)') ZMIN, ZMAX
         CALL AOUT14( PLEV, KLEN, ZMIN, ZMAX, KCHAN, KASCII )
      ENDIF

      RETURN
      END
      SUBROUTINE ALLCHP(KP,KLEN,KERR)
**    Function - To allocate memory from the heap, acting as an
**          interface to a Cray library routine. The routine will abort
**          if an error occurs.
**    Args in - none
**               KLEN    - Length of space requested (words)
**    Args out -
**               KP      - Pointer to space
**               KERR    - Error code returned by HPALLOC
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - ITRACR,OPPHTS,OPSGTS,OPTRTS,OPXPTS
**    Calls - HPALLOC(Cray library routine to allocate space),ABORT
**    Files read - none
**    Files written - none
**    Author - G Carver, Cambridge University (27.03.90)
**    Modified by - R Brugge, University of Reading (13.08.92) for
**          UFLUX3

CC    TEMPORARY FIX TO RUN ON SUNS
      PRINT *,'ALLCHP CALLED -- ERROR -- ABORT'
      CALL ABORT

C      KERR=0
C      CALL HPALLOC(KP,KLEN,KERR,0)
C      IF(KERR.NE.0)THEN
C         IF(KERR.EQ.-2)THEN
C            WRITE (6,6001)
C6001        FORMAT(1X,'***ABORT IN ALLOCHP: CANNOT ALLOCATE',
C     -            ' ARRAY. INCREASE MEMORY LIMIT OF JOB.')
C         ELSE
C            WRITE(6,6002)KERR
C6002        FORMAT(1X,'***ABORT IN ALLOCHP: CANNOT ALLOCATE',
C     -            ' ARRAY.  HPALLOC RETURNED ERROR CODE OF ',I3)
C         ENDIF
C         CALL ABORT
C      ENDIF

      RETURN
      END
      SUBROUTINE DEHEAP(KP,KERR)
**    Function - To release heap space, acting as an
**          interface to a Cray library routine. The routine will abort
**          if an error occurs.
**    Args in - none
**               KP      - Pointer to space
**    Args out -
**               KERR    - Error code returned by HPDEALLC
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - ENDOP,OPPHTS,OPSGTS,OPTRTS,OPXPTS
**    Calls - HPDEALLC(Cray library routine return memory to the
**          heap),ABORT
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading

CC    TEMPORARY FIX TO RUN ON SUNS
      PRINT *,'DEHEAP CALLED -- ERROR -- ABORT'
      CALL ABORT

C      KERR=0
C      CALL HPDEALLC(KP,KERR,0)
C      IF(KERR.EQ.-3)THEN
C         WRITE (6,6001)
C6001     FORMAT(1X,'***ABORT IN DEHEAP: ADDRESS IS OUTSIDE',
C     -         ' BOUNDS OF THE HEAP')
C         CALL ABORT
C      ELSE IF(KERR.EQ.-5) THEN
C         WRITE(6,6002)
C6002     FORMAT(1X,'***ABORT IN DEHEAP: ADDRESS IS NOT AT ',
C     -            'BEGINNING OF THE BLOCK')
C         CALL ABORT
C      ENDIF

      RETURN
      END
      SUBROUTINE DAYCHK0(KB1PAR,PDAY,PRDDAY,KFAIL)
**    Function - Check day number from MARS header.
**    Args in -
**               KB1PAR  - Integer array containing GRIB product
**                         definition information
**               PDAY    - Day number should correspond to PDAY
**               PRDDAY  - Day number read from GRIB code
**    Args out -
**               KFAIL   - Error flag
**    Args for work - none
**    Com used - none
**    Com changed - none
**    Params used - none
**    Called by - not currently used
**    Calls - none
**    Files read - none
**    Files written - none
**    Author - R Brugge, University of Reading, based on code by
**          M Blackburn

      INTEGER KB1PAR(18)

      IF (KB1PAR(17).NE.0.AND.KB1PAR(17).NE.1.AND.KB1PAR(17).NE.2
     -      .AND.KB1PAR(17).NE.10) THEN
            KFAIL=1
            RETURN
      ENDIF
      IF (KB1PAR(16).NE.0) THEN
         KFAIL=2
         RETURN
      ENDIF

      IF (KB1PAR(14).EQ.2) THEN
         PRDDAY=FLOAT(KB1PAR(15))
      ELSE IF (KB1PAR(14).EQ.1) THEN
         PRDDAY=FLOAT(KB1PAR(15))/24.
      ELSE IF (KB1PAR(14).EQ.0) THEN
         PRDDAY=FLOAT(KB1PAR(15))/1440.
      ELSE
         KFAIL=3
         RETURN
      ENDIF
      IF (ABS(PRDDAY-PDAY).GT.1.E-3) THEN
         KFAIL=4
         RETURN
      ENDIF

**    No errors detected
      KFAIL=0
      RETURN
      END
****************DUMMY ROUTINES

